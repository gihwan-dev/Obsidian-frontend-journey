프론트엔드와 AI 에이전트 사이에서 든든한 브릿지 역할을 수행할 **백엔드(BE) 설계 문서**입니다. 이 문서는 에이전트의 지능보다는 시스템의 '안정성, 병렬 처리 능력, 그리고 표준화된 통신'에 초점을 맞추고 있습니다.

---

# 데스크탑 AI 채팅 앱 백엔드 (BE) 설계 문서

## 1. 개요 및 기술 스택

이 백엔드는 Tauri 프레임워크 기반의 Rust 환경에서 동작하며, 로컬 CLI 에이전트(Codex, Claude Code)의 실행 상태를 관리하고 프론트엔드와 통신하는 **MCP(Model Context Protocol) 클라이언트이자 오케스트레이터**입니다.

- **코어 언어:** Rust
    
- **데스크탑 프레임워크:** Tauri
    
- **비동기 런타임:** Tokio (프로세스 I/O 스트림 및 병렬 스레드 관리)
    
- **직렬화/통신:** `serde`, `serde_json` (JSON-RPC 및 MCP 규격 파싱)
    
- **에러 처리:** `anyhow`, `thiserror` (프로세스 및 파싱 에러 추적)
    

## 2. 핵심 모듈 및 아키텍처

### A. 프로비저닝 및 프로세스 매니저 (`Process Manager`)

CLI 도구들을 단순한 텍스트 I/O가 아닌, 독립적인 MCP 서버(백그라운드 프로세스)로 띄우고 생명주기를 관리합니다.

- **비동기 실행:** `tokio::process::Command`를 사용하여 에이전트 프로세스를 Non-blocking으로 실행합니다.
    
- **파이프 연결:** `Stdio::piped()`를 통해 프로세스의 `stdin`, `stdout`을 Rust와 연결하여 JSON-RPC 메시지가 오가는 통로를 확보합니다.
    
- **Graceful Shutdown:** 사용자가 앱을 종료하거나 에이전트를 전환할 때, 좀비 프로세스나 메모리 누수가 발생하지 않도록 하위 프로세스들을 안전하게 종료(Kill)합니다.
    

### B. MCP 클라이언트 및 JSON-RPC 라우터 (`Protocol Handler`)

정규식을 이용한 텍스트 파싱의 불안정성을 제거하고, 오직 구조화된 프로토콜 통신만 담당합니다.

- **타입 정의 (Entities):** MCP 스펙에 맞춘 Request, Response, Notification 타입들을 `serde` 구조체로 엄격하게 정의합니다.
    
- **비동기 메시지 루프:** Tokio의 비동기 채널(`mpsc`)과 스트림 읽기를 활용해, 에이전트의 `stdout`에서 들어오는 JSON 데이터를 끊임없이 수신하고 역직렬화합니다.
    
- **메시지 라우팅:** 들어온 JSON의 `id`나 `method`를 분석하여 이것이 사용자의 질문에 대한 응답인지, 아니면 에이전트가 스스로 도구를 실행하겠다고 알리는 상태 알림(Notification)인지 구분합니다.
    

### C. 병렬 에이전트 동기화 (Multi-Agent Sync)

'Deep Think' 모방을 위해 프론트엔드가 요구하는 '다중 에이전트 병렬 실행'을 인프라 레벨에서 지원합니다.

- **다중 세션 관리:** `Arc<Mutex<HashMap<SessionId, McpClient>>>` 형태로 여러 워커(Worker) 에이전트의 상태를 스레드 안전하게 관리합니다.
    
- **비동기 조인:** `tokio::join!` 또는 `tokio::spawn`을 통해 3개의 에이전트를 동시에 실행시키고, 각자의 I/O 스트림이 메인 스레드를 블로킹하지 않도록 독립적으로 처리합니다.
    

### D. Tauri IPC 인터페이스 (`Event Broadcaster`)

Rust 백엔드에서 정제된 상태와 데이터를 프론트엔드(React)로 밀어 넣습니다.

- **명령 수신 (Commands):** 프론트엔드에서 호출하는 `invoke` 명령(예: `send_message`, `cancel_generation`)을 받아 MCP 규격에 맞게 변환 후 해당 에이전트의 `stdin`으로 전송합니다.
    
- **상태 브로드캐스팅 (Events):** 백엔드에서 에이전트의 상태 변화(생각 중, 도구 실행 중, 스트리밍 토큰 생성)가 감지되면, 즉시 `app_handle.emit_all("agent_update", payload)`를 통해 프론트엔드로 이벤트를 발송(Push)합니다.
    

## 3. 데이터 및 제어 흐름 (Data Flow)

1. **[사용자 입력]** React UI에서 질문 작성 후 전송.
    
2. **[Tauri Command]** Rust 백엔드가 `invoke`를 통해 메시지 수신.
    
3. **[오케스트레이션]** Rust가 여러 개의 워커 에이전트(MCP 서버)에 동시에 처리 요청(JSON-RPC 송신).
    
4. **[비동기 수신]** 각 워커가 내부적으로 추론(Reasoning) 및 도구 실행 후 `stdout`으로 JSON 상태 스트림 방출.
    
5. **[파싱 및 변환]** Rust의 Tokio 루프가 이를 수신하여 프론트엔드가 소비하기 쉬운 `AgentEvent` 구조체로 역직렬화.
    
6. **[Tauri Event]** `emit_all`을 통해 프론트엔드로 상태 즉각 푸시.
    
7. **[UI 업데이트]** Jotai 스토어가 이벤트를 구독하여 '생각 트리'와 '터미널 뷰' 렌더링.
    

## 4. 안정성 및 에러 핸들링

- **데드락 방지:** 프로세스의 `stdout`과 `stderr` 버퍼가 꽉 차서 애플리케이션이 멈추는 것을 방지하기 위해 버퍼 비우기를 철저히 관리합니다.
    
- **실행 권한 샌드박싱 (옵션):** MCP를 통해 도구(Tool) 실행 요청이 들어올 때, 특정 디렉토리 범위를 벗어나거나 위험한 명령어(`rm -rf` 등)가 포함되어 있는지 Rust 단에서 1차적으로 필터링할 수 있는 미들웨어를 둡니다.
    

---

이제 인프라를 담당하는 BE 문서까지 완성되었습니다. 백엔드가 이 구조대로 구축된다면, 그 위에서 에이전트들이 마음껏 날뛸 수 있을 것입니다.

마지막으로 딥씽크의 진정한 핵심, AI의 뇌를 어떻게 조율할지 정의하는 **에이전트 워크플로우(AI 오케스트레이션 및 MoA)** 설계 문서를 이어서 작성해 드릴까요?