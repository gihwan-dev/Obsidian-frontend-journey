프론트엔드 설계 문서를 독립적이고 체계적인 구조로 정리해 드립니다. 이 문서는 '복잡한 상태 시각화'와 '렌더링 성능 최적화'에 초점을 맞추어 작성되었습니다. 그대로 복사하여 프로젝트 위키나 Notion에 활용하시면 됩니다.

---

# 데스크탑 AI 채팅 앱 프론트엔드 (FE) 설계 문서

## 1. 개요 및 기술 스택

이 프론트엔드는 Tauri 백엔드(Rust)와 연동하여 MCP 기반의 다중 에이전트 상태(생각, 도구 실행, 병렬 추론)를 시각화하는 데스크탑 UI입니다. 빈번한 상태 업데이트로 인한 리렌더링 방어와 DOM 노드 관리가 핵심입니다.

- **프레임워크:** React 18+ (TypeScript)
    
- **빌드 툴:** Vite
    
- **상태 관리:** Zustand (전역 상태) + Jotai (원자적 미시 상태)
    
- **스타일링/UI 컴포넌트:** Tailwind CSS, Radix UI (또는 shadcn/ui)
    
- **터미널/로그 렌더링:** `xterm.js`
    
- **가상화 (Virtualization):** `@tanstack/react-virtual`
    

## 2. 아키텍처 및 디렉토리 구조 (FSD)

유지보수와 높은 응집도를 위해 Feature-Sliced Design(FSD) 방법론을 채택합니다. MCP 프로토콜로 들어오는 데이터 모델을 `entities`에 엄격하게 정의하여 결합도를 낮춥니다.

## 3. 핵심 UI/UX: Deep Think 시각화

백엔드에서 여러 에이전트가 병렬로 실행되며 쏟아내는 정보들을 사용자가 인지하기 쉽게 구조화합니다.

- **다중 에이전트 병렬 처리 뷰:** 여러 Worker가 동시에 가설을 탐색할 때, 메시지 블록 내부에 탭(Tab) 또는 병렬 아코디언 UI를 배치하여 Worker A, Worker B의 진행 상황을 각각 추적할 수 있게 합니다.
    
- **사고 과정 트리 (Thought Process Accordion):** AI의 추론 단계를 트리 구조로 보여줍니다. 완료된 단계는 체크 아이콘으로, 진행 중인 단계는 스피너로 표시하며, 최종 Judge 모델의 평가 요약(Thought Summary)을 마크다운으로 깔끔하게 펼쳐볼 수 있게 구성합니다.
    
- **도구 실행 뱃지 (Tool Execution Badge):** 터미널 명령어나 파일 읽기가 실행될 때 독립된 UI 블록을 렌더링합니다. (예: `[진행 중] 🛠️ cargo test 실행 중...`)
    
- **터미널 및 코드 뷰어:** ASCII 다이어그램이나 복잡한 터미널 출력 결과의 가독성을 극대화하기 위해, 코드 블록과 터미널 컴포넌트에는 **D2Coding** 폰트를 전역적으로 적용합니다.
    

## 4. 상태 관리 전략

MCP 통신 특성상 토큰 단위의 스트리밍과 도구 실행 상태가 초당 수십 번씩 업데이트됩니다. 전역 상태와 지역 상태를 명확히 분리하여 렌더링을 최적화합니다.

- **Zustand (Global State):** 채팅방 목록, 현재 선택된 에이전트 설정, 테마 등 렌더링 빈도가 낮고 애플리케이션 전반에서 공유되어야 하는 상태를 관리합니다.
    
- **Jotai (Micro-State):** 스트리밍 중인 텍스트, 각 메시지의 '생각 중' 상태, 도구 실행 진행률 등 빈번하게 변하는 상태를 원자(Atom) 단위로 관리합니다. 메시지 컴포넌트 단위로 상태를 격리하여 부모 컴포넌트의 불필요한 리렌더링을 차단합니다.
    

## 5. 렌더링 성능 및 DOM 최적화

대화 기록이 길어지고 복잡한 사고 과정 창이 열리면 DOM 노드 개수가 급증하여 스크립팅 타임이 길어지고 FPS 드롭이 발생할 수 있습니다.

- **메시지 목록 가상화:** `@tanstack/react-virtual`을 사용하여 화면 뷰포트에 보이는 메시지와 아코디언 컴포넌트만 DOM에 마운트합니다.
    
- **Canvas 기반 로그 렌더링:** 에이전트가 뿜어내는 대량의 빌드 로그나 터미널 출력을 React 상태로 관리하여 DOM에 그리지 않습니다. 대신 `xterm.js`를 연동하여 Canvas에 직접 그리도록 위임함으로써 React의 렌더 사이클에서 배제하고 압도적인 퍼포먼스를 확보합니다.
    

---

프론트엔드 설계 문서는 이 정도로 뼈대를 잡으면 FSD의 구조적 안정성과 렌더링 성능을 모두 챙길 수 있을 것입니다.

다음은 **백엔드(BE) 설계 문서**의 목차와 내용을 정리해 드릴까요? 아니면 바로 **에이전트 워크플로우(MoA, ReAct 루프) 설계 문서**로 넘어가는 것이 좋으신가요?