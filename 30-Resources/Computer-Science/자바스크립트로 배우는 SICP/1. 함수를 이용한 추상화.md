> 단순 관념(simple idea)에 그 힘을 행사하는 지성의 행위는 주로 다음 세 가지다.
> 
> 1. 단수의 단순 관념을 하나의 복합 관념으로 조합한다. 복잡한 관념들은 모두 이런 식으로 만들어진다.
> 2. 둘째는 두 관념(단순 관념이든 복합 관념이든)을 가져와 또 다른 관념으로 설정함으로써 그 둘을 하나의 관념으로 통합하지 않고도 두 관념을 한 번에 볼 수 있게 만드는 것이다. 관계에 관한 관념은 모두 이런식으로 만들어진다.
> 3. 셋째는 하나의 관념을 그 실제 존재에 수반하는 다른 모든 관념으로부터 분리하는 것이다. 이를 추상화라고 부르며, 일반적인 관념은 모두 이런 식으로 만들어진다.
>
> *존 로크 - An Essay Concerning Human Understanding*

**계산적 과정(computational process)**
- 어떤 구체적인 산술 계산을 수행하는 과정보다는 좀 더 넓은 개념
- "그 과정의 세부절차 단계들을 명확히 규정할 수 있으며 형식화할 수 있는 과정"을 말함
- 컴퓨터 안에 사는 추상적인 존재

**프로그램**
- 과정은 점차 전개되며 데이터라고 부르는 또 다른 존재를 조작
- 하나의 과장은 일정한 규칙들의 패턴에 따라 전개
- 그러한 패턴이 프로그램
- 프로그래밍 언어로 만들어진 기호 표현식들로 구성되며, 과정이 수행해야 할 과제들을 상세하게 기술

## 1.1 프로그래밍의 기본 요소
- 프로그래밍 언어는 컴퓨터가 수행할 과제를 지시하는 수단 이상의 어떤 것
- 과정에 관한 생각들을 조직화하는 틀로도 작용
- 단순한 아이디어들을 조합해 좀 더 복잡한 아이디어를 만드는데 사용하는 수단에 주의를 기울여야 함
- 모든 강력한 언어는 다음 세 가지 메커니즘을 제공
	- **원시 표현식:** 언어와 관련한 가장 단순한 개체(entity)를 나타냄
	- **조합 수단:** 단순한 요소들로부터 복합적인 요소를 만드는 데 쓰임
	- **추상화 수단:** 복합적인 요소들에 이름을 붙여 하나의 단위로 다루는 데 쓰임
- 모든 프로그래밍 언어는 원시 데이터와 원시 함수를 서술하는 기능이 있어야 하며, 함수들과 데이터를 조합하고 추상화하는 수단들을 제공해야함

### 1.1.1 표현식
- 사람과 해석기의 전형적인 상호작용 방식은 사람이 해석기의 프롬프트에서 **문장(statement)** 을 입력하고, 해석기가 그 문장을 **평가(evaluation)** 해서 그 결과를 화면에 표시하는 것.
- 표현식 문장은 **표현식(expression)** 과 **세미콜론(;)** 으로 구성
- 표현식은 하나 이상의 **원시 표현식(primitive expression)** 으로 구성
	- 예를 들어 수(number; 또는 수치)가 있음. `486;`
- 이러한 표현식들을 조합해 복합 표현식을 만들 수 있음
	- `137 + 349;`  => 486으로 해석됨
- 다른 표현식을 구성요소로 담고 있는 표현식을 가리켜 **조합(combination)** 이라고 부름
- 가운데 **연산자(operator)** 가 있고 그 왼쪽과 오른쪽에 **피연산자(operand)** 가 있는 조합을 **연산자 조합(operator combination)** 이라고 부름
- 연산자 조합의 값은 연산자로 지정된 함수를 **인수(argument)** 들, 즉 피연산자 값들에 적용해서 구함

> `137 + 349`에서 `+`는 "두 수를 받아서 합을 돌려주는 함수"로 보는 거야. 책에서 프로그래밍 언어의 요소를 **함수(procedure/function)**와 **데이터(data)**로 나눈다고 했는데, 그 프레임으로 보면 `137`과 `349`는 데이터이고, `+`는 함수인 셈이지.
> 
> 이게 SICP 원판(Scheme)에서는 더 명확하게 드러나는데, `(+ 137 349)`처럼 쓰거든. 함수 호출 `f(a, b)`와 완전히 같은 구조야. 연산자가 그냥 함수 이름 자리에 있을 뿐이지.
> 
> JavaScript 에디션에서는 `137 + 349`라는 중위(infix) 문법을 쓰니까 함수 호출처럼 안 보이지만, 의미론적으로는 동일하다는 게 책의 요점이야. 실제로 JavaScript에서도 `+`의 동작을 풀어 쓰면 결국 "두 인수를 받아 결과를 반환하는 함수"와 다를 바 없으니까.
> 
> 이렇게 **연산자도 함수의 일종**으로 통일해서 바라보면, 나중에 나오는 고차 함수나 추상화 개념들이 자연스럽게 연결돼. "특별한 것은 없고, 다 함수와 데이터다"라는 단순한 세계관이 SICP 전체를 관통하는 사고방식이야.

- 연산자를 두 피연산자 사이에 배치하는 관례를 **중위 표기법(infix notation)** 이라고 부름
- 복잡한 표혀닉 문장이 주어져도 해석기는 항상 동일한 기본 주기로 작동
- 사용자가 입력한 문장을 읽고, 평가하고, 출력
- 이러한 주기를 반복하는 것을 *REPL(read-evaluate-print loop)* 라고 부름
- 자바스크립트 해석기는 특별한 명령이 없어도 항상 주어진 표현식의 평가 결과를 출력

### 1.1.2 이름 붙이기와 환경

- **계산적 객체(computational object)** 에 이름을 붙여 이름으로 그 객체를 지칭하는 수단들은 프로그래밍 언어의 필수 기능임
- **상수(constant)**의 이름은 해당 객체의 값을 칭하는 용도로 사용됨
- 복합적인 연산의 결과를 간단한 이름으로 지칭할 수 있다는 점에서, 상수 선언은 가장 단순한 추상화 수단
- 일반적으로 계산적 객체는 내부 구조가 복잡할 수 있음
- 복잡한 구조의 세부사항을 기억해두고 사용할 때마다 그 구조를 거듭 명시하는 것은 불편함
- 복잡한 프로그램은 점차 더 복잡한 계산적 객체들을 구축해 나가는 식으로 만들어짐
- 해석기를 이용하면 이름-객체 연관 관계를 일련의 상호작용을 통해 점진적으로 만들어 나갈 수 있음
- 이름으로 값을 조회하기 위해서는 이름-객체 쌍을 저장하고 관리하는 메모리 공간이 필요함
- 이러한 메모리 공간을 **환경(environment)**이라고 부름

### 1.1.3 연산자 조합의 평가

- 이 장의 목표 중 하나는 절차적 사고(procedural thinking)에 관한 놈점들을 잘 구분하는 것
- 현산자 조합을 평가할 때 해석기는 다음과 같은 절차를 따름
	- 조합의 피연산자 표현식들을 평가
	- 연산자가 나타내는 함수를 인수(피연산자들의 값)들에 적용
- 단계 1에 따르면 조합의 평가 과정을 완료하기 위해 먼저 조합의 각 피연산자를 평가해야함
- 규칙의 한 단계에서 규칙 자신을 수행해야 함을 뜻함. 즉 이 평가 규칙은 재귀적임
- 다음 예를 보자
	- `(2 + 4 * 6) * (3 + 12);`
	- 이 복합 연산자 조합을 평가 하려면 서로 다른 네 가지 조합에 평가 규칙을 적용해야함

![[ASTEvaluation.gif]]

- 트리의 조합 과정은 말단 노드에서 출발해 결합에 따라 점차 위쪽 노드들로 올려보내는 과정에 해당
- 이러한 값들을 위로 올려보내는 형태의 평가 규칙을 트리 누산 이라고 부름
- 단계 1을 재귀적으로 거듭 적용하다 보면 조합이 아니라 원시 표현식을 평가해야 하는 지점에 도달함
- 원시 표현식에는 아래와 같은 규칙들이 적용됨
	- 수치의 값은 해당 숫자들이 나타내는 그 값
	- 이름의 값은 현재 환경에서 그 이름에 연관된 객체
- 주목할 점은 표현식 안의 이름이 뜻하는 바를 환경이 결정한다는 점
- `x + 1` 같은 표현식의 값을 이야기 하려면 `x` 라는 이름의 의미를 제공하는 환경에 대한 정보가 필요함
- 평가가 일어나는 문맥을 제공하는 환경이라는 일반적인 개념은 프로그램의 실행을 이해할 때 중요한 역할을 함
- 평가 규칙이 선언에는 적용되지 않음
- `const x = 3;` 을 평가할 때 해석기가 두 인수에 상등 연산자 `=`를 적용하지는 않음
- 선언은 이름에 값을 연관시키는 것만을 목적으로 하는 프로그램 구성요소
- `const` 같은 키워드는 이름으로 사용할 수 없음
- 문장 안에서 하나의 키워드 또는 키워드 조합을 만나면 그 문장을 특별한 방식으로 처리함
- 키워드를 포함한 문장을 **구문형(syntactic form)** 이라고 부르며, 각각의 구문형마다 고유한 평가 규칙이 있음

> 구문형(syntatic form)
> "구문적 형태" 즉, "이 키워드 다음에는 어떤 이름이 나올 수 있고, 그 이름 다음에는 이런 기호가 와야하고,..." 같은 규칙을 의미


### 1.1.4 복합 함수
- 앞의 내용을 정리하면 아래와 같음
	- 수치와 산술 연산은 원시 데이터와 원시 함수에 해당
	- 조합의 중첩은 연산들을 조합하는 수단을 제공
	- 이름과 값을 연관시키는 상수 선언은 제한적이나마 추상화의 수단을 제공
- 복합 연산에 이름을 붙여 그 연산을 하나의 단위로 지칭하게 하는 함수 선언은 상수 선언보다 훨씬 강력한 추상화 기법
- '제곱' 이라는 개념을 일상 언어로 표현한다면 "To square something, take it times iteself" 라고 표현할 수 있음
- 이를 함수로 표현하면 아래와 같음

```ts
function square(x) {
  return x * x;
}
```

- 함수 선언과 일상의 언어 표현을 대응 시키면 아래와 같음

![[Drawing 2026-02-23 08.55.13.excalidraw]]

- 이는 `square` 라는 이름이 붙은 하나의 복합 함수
- 곱할 대상에 `x` 라는 지역 이름을 부여해 뭔가에 자기 자신을 곱하는 연산을 나타냄
- 지역 이름은 일상 언어의 대명사 같은 역할을 함
- 해석기는 함수 선언을 해석해 이 복합 함수에 `square` 라는 이름을 연관시킴
- `square` 라는 함수를 선언했으니 함수 적용 표현식에서 사용 가능
- `square(21); // 441`
- 함수 적용을 평가할 때 해석기는 연산자 조합의 평가 절차와 비슷한 절차를 따름
	1. 적용의 부분식들, 즉 함수 표현식과 인수 표현식들을 각각 평가
	2. 함수, 즉 함수 표현식의 값을 인수 표현식 값들에 적용
- `square` 함수를 다른 함수를 정의하는 구축 요소로 사용할 수 있음
	- `square(x) + square(y)`

### 1.1.5 함수 적용의 치환 모형

- 아래 같은 함수들이 있다고 생각해보자

```ts
function f(x) {
  return sum_of_squares(x + 1, x * 2);
}

function sum_of_squares(x, y) {
  return squares(x) + squares(y);
}

function squares(x) {
  return x * x;
}
```

- `f(5)` 처럼 함수를 적용했다면 아래의 과정이 발생함
	- `sum_of_squares(5 + 1, 5 * 2)`
	- `sum_of_squares(6, 10)`
	- `square(6) + square(10)`
	- `36 + 100`
	- `136`
- 이러한 과정을 함수 적용의 치환 모형 이라고 함
- 함수 적용의 '의미'를 결정하는 모형임

#### 인수 우선 평가 대 정상 우선 평가

- 여기까지 이해한 바에 따르면, 해석기는 함수와 인수 표현식들을 먼저 평가하고 그 결과로 얻은 함수를 인수들에 적용
- 그런데 이게 평가를 수행하는 유일한 방법은 아니며, 인수의 값이 실제로 필요해질 때까지 인수 표현식의 평가를 미루는 평가 모형도 가능함
- 이러한 평가 모형에서는 연산자와 원시 함수들만 관여하는 표현식을 평가할 때가 되면 그때 인수 표현식들을 평가함

```js
f(5)
```

- 위 함수는 아래와 같이 전개(expansion)됨

![[ExpansionTreeSVG.gif]]

- 그리고 아래와 같이 축약(reduction)됨

![[ReductionTreeSVG.gif]]

```js
x * x
```

- 위 표현식의 축약 과정에서 `x`가 각각 `5 + 1` 과 `5 * 2`로 치환되었기 때문임
- 이처럼 "먼저 완전히 전개한 후 축약" 하는 평가 방법을 **정상 순서 평가(normal-order-evaluation; 또는 표준 순서 평가)** 라고 부름
- 앞서 본 "먼저 인수들을 먼저 평가한 후 적용" 하는 평가 방법을 **인수 우선 평가** 또는 **적용적 순서 평가(applicative-order evaluation)** 이라고 부름
- 치환 모형으로 평가할 수 있으며 적법한 값들을 산출하는 함수 적용의 경우 정상 순서 평가와 인수 우선 평가가 같은 값을 산출함을 증명하는 것이 가능
- 자바스크립트는 인수 우선 평가 방식을 사용함. 같은 표현식이 여러번 평가되는 비효율성을 피하기 위해서 이기도 하지만, 치환 모형을 벗어난 함수들에 대해서는 정상 순서 평가가 훨씬 복잡하기 때문임

### 1.1.6 조건부 표현식과 술어

- 현재까지 배운 것만으로 선언할 수 있는 함수들은 그 표현력이 제한적임
- 어떤 조건을 판정해서 그 결과에 따라 서로 다른 연산을 수행 하는 방법을 아직 모름
- 예를들어 아래 같은 절댓값을 구하려면 음수인지 아닌지에 따라 다른 연산을 수행해야 함

$$
|x| = \begin{cases} 
x & \text{만일 } x \ge 0 \\
-x & \text{그렇지 않으면}
\end{cases}
$$

- 이러한 연산 구조를 **사례 분석(case analysis; 또는 경우 분석)** 이라고 하며, **조건부 표현식(conditional expression)** 을 이용해 표현할 수 있음

```js
function abs(x) {
	return x >= 0 ? x : -x;
}
```

- 조건부 표현식의 일반적인 형태는 다음과 같음

```text
술어 ? 귀결-표현식 : 대안-표현식
```

- 조건부 표현식은 하나의 **술어(predicate)** 로 시작함 
- 술어는 값이 참 아니면 거짓인 표현식임
- 술어 다음에는 물음표와 **귀결 표현식(consequent expression)** 이 오고 그 다음 콜론(:)과 **대한 표현식(alternative expression)** 으로 끝남
- 술어가 참이라면 귀결 표현식을 평가해 조건부 표현식 전체의 값으로 돌려줌
- 거짓이라면 대안 표현식을 평가해 돌려줌
- 참 또는 거짓을 돌려주는 연산자와 함수도 **술어**라 부름
- 절댓값 계산 시 인수가 0인 경우를 따로 처리하기로 한다면

$$
|x| = \begin{cases}
	x & \text{만일} x > 0 \text{이면} \\
	0 & \text{만일} x=0 \text{이면} \\
	-x & \text{그렇지 않으면}
\end{cases}
$$
- 이 경우 대안 표현식들이 다른 조건부 표현식 안에 있는 형태로 중첩된 표현식으로 표현할 수 있음

```js
function abs(x) {
	return x > 0
		? x
		: x === 0
		? 0
		: -x;
}
```

- 조건부 표현식은 오른쪽 결합임

$$
\mathrm{if}\; p_1 \;\mathrm{then}\; e_1 \;\mathrm{else}\;
\Bigl(\mathrm{if}\; p_2 \;\mathrm{then}\; e_2 \;\mathrm{else}\;
\bigl(\cdots\;
(\mathrm{if}\; p_n \;\mathrm{then}\; e_n \;\mathrm{else}\; e_{\mathrm{final}})\;
\cdots\bigr)\Bigr)
$$

- p1이 거짓이면 p2가, p2가 거짓이면 p3가 그렇게 pn 까지 평가되며 이 또한 거짓이라면 최종 대안 표현식의 값이 반환
- 수들에 적용되는 `>=, >, <, <=, ===, !==` 같은 원시 술어들 외에도 사용할 수 있는 논리 조합 연산들이 있음
	- `표현식1 && 표현식2`: **논리곱(logical conjunction)**에 해당함. `표현식1 ? 표현식2: false`의 문법적 설탕
	- `표현식1 || 표현식2`: **논리 합(logical disjunction)**에 해당함. `표현식1 ? true : 표현식2`의 문법적 설탕
	- `!표현식`: **논리부정(logical negation)**에 해당함.
- `&&`와 `||`는 연산자가 아니라 구문형임. 이들의 우변에 오는 표현식이 항상 평가되지는 않음
- 반면에 `!`는 연산자이며, $1.1.3의 평가 규칙을 따름
- `!`는 인수 하나만 받는 **단항(unary)** 연산자이며 연산자 `!`를 인수 앞에 둠
- 이런 방식의 연산자를 **전위 연산자(prefix operator)** 라고 부름
- `abs` 함수의 표현식 `-x`에 쓰인 수치 부정 연산자 `-`도 전위 연산자

```js
x > 5 && x < 10
```

- 구문형 `&&`는 우선순위가 비교 연산자 `>`, `<` 보다 낮음
- 조건부 표현식 구문형 `... ? ... : ...`의 우선순위는 지금까지 배운 모든 연산자보다 낮음

```js
function greater_or_equal(x, y) {
	return !(x < y);
}
```

- 첫 인수가 둘째 인수보다 크거나 같은지 판정하는 조건부 표현식
- 단항 연산자는 이항 연산자보다 우선순위가 높기 때문에 괄호가 반드시 필요함

### 1.1.7 예제: 뉴턴 방법으로 제곱근 구하기

- 앞서 소개한 함수들은 통상적인 함수와 아주 비슷함
- 하지만 수학 함수와 컴퓨터 함수에는 중요한 차이점이 있음
- 컴퓨터의 함수는 **효과적(effective)** 이어야 함

> [!note]
> 여기서 '효과적'이란 예상한 대로의 효과나 결과를 산출한다는 뜻

- 예를들어 제곱근을 구하는 문제를 살펴보면:

$$
\sqrt{x} = y \ge 0 \text{ 이고 } y^2 = x \text{ 라는 조건을 충족하는 } y
$$

- 이 정의는 완벽하게 적법한 수학 함수를 서술함
- 하지만 이 정의가 컴퓨터 함수를 서술하지는 않음
- 이 정의는 주어진 수의 제곱근을 실제로 구하는 방법에 관해서는 아무것도 말해주지 않음

```js
function sqrt(x) {
	return y >= 0 && square(y) === x라는 조건을 충족하는 y
}
```

- 수학 함수와 컴퓨터 함수의 이러한 차이점은 사물의 **성질(property; 속성)**을 서술하는 것과 뭔가를 하는 **방법**을 서술하는 것의 차이를 반영함
- 이를 **선언적 지식(declative knowledge)**과 **명령적 지식(imperative knowledge)**의 구분이라고 말하기도 함
- 수학에서는 주로 선언적 서술(이것은 무엇인가?)**에 관심을 두지만 컴퓨터 과학에서는 주로 명력적 저술(어떻게 하는가?)에 관심을 둠
- 제곱근을 계산할 때 가장 흔히 쓰이는 방법은 뉴터 방법을 이용해 제곱근의 근삿값을 거듭 개선해 나가는 것
	- 먼저 `x`의 제곱근이 될 만한 `y`의 값을 추측하고, `y`와 `x/y`의 평균으로 더 나은 추측값을 구하는 과정을 반복


$$
\begin{aligned}  
&\textbf{2의 제곱근을 구하는 과정} \\[6pt]  
&y_{n+1} = \frac{y_n + \frac{2}{y_n}}{2} \\[10pt]  
&y_0 = 1 \\[6pt]  
&y_1 = \frac{1 + \frac{2}{1}}{2} = 1.5 \\[6pt]  
&y_2 = \frac{1.5 + \frac{2}{1.5}}{2} = 1.4167 \\[6pt]  
&y_3 = \frac{1.4167 + \frac{2}{1.4167}}{2} \approx 1.4142157 \\[6pt]  
&y_4 \approx 1.414213562 \\[10pt]  
&\sqrt{2} \approx 1.41421356237\ldots  
\end{aligned}
$$

- 이러한 과정을 자바스크립트 함수로 **정식화(formulation)**해볼 수 있음
- 피제곱근수(radicand; 제곱근을 구하고자 하는 수)에 해당하는 값 하나와 추측값에 해당하는 값 하나로 출발해서, 추측값이 기준에 충족한다면 과정을 끝내고, 그렇지 않으면 개선 과정을 반복함

```js
function sqrt(x) {
	return sqrt_iter(1, x);
}

function sqrt_iter(guess, x) {
	return is_good_enough(guess, x)
		? guess
		: sqrt_iter(improve(guess, x), x);
}

function improve(guess, x) {
  return average(guess, x / guess);
}

function average(x, y) {
  return (x + y) / 2;
}

function is_good_enough(guess, x) {
	return abs(square(guess) - x) < 0.001;
}
```

- [[연습문제 1.6]]
- [[연습문제 1.7]]

