# 📌 핵심 한 줄 요약

> 컴퓨터는 모든 실수를 정확히 저장하지 못한다.  
> 그래서 어떤 순간부터는 “더 정밀하게” 계산하는 게 불가능해진다.

---

# 🧠 1️⃣ 왜 그런 일이 생기나?

컴퓨터는 숫자를 **무한 정밀도**로 저장하지 못한다.

자바스크립트는 숫자를  
👉 **IEEE 754 64-bit 부동소수점(double precision)** 으로 저장한다.

이건 대략:

- 약 **15~16자리 십진수 정밀도**
- 그 이상은 잘려 나감

---

# 🔍 2️⃣ 큰 수에서 무슨 일이 생기나?

예를 들어 보자:

```js
1000000000000000  // 10^15
```

이 숫자는 이미 정밀도의 거의 끝자락이다.

이 상태에서 아주 작은 변화를 더해보면:

```js
1000000000000000 + 0.001
```

이 값은 실제로는 바뀌지 않는다.

왜냐하면:

> 10^15 규모에서 0.001은 너무 작아서  
> 표현 가능한 비트 단위 변화보다 작기 때문.

즉,

```
1000000000000000
1000000000000000.001
```

이 둘을 컴퓨터는 **같은 숫자**로 본다.

---

# 🔄 3️⃣ 뉴턴 방법에서 무슨 일이 벌어지나?

뉴턴 반복은 점점 조금씩 값을 수정한다:

```
guess → 조금 더 정확한 guess → 또 조금 더 정확한 guess
```

그런데 어느 순간:

```
새로운 guess === 이전 guess
```

이 되어버린다.

왜?

- 계산은 계속 하지만
    
- 저장 가능한 정밀도 한계에 도달했기 때문
    

즉,

> 더 정확한 값이 나와도  
> 저장할 수 없어서 값이 더 이상 변하지 않는다.

---

# 📉 4️⃣ 그래서 왜 문제가 되나?

기존 종료 조건은:

```js
abs(square(guess) - x) < 0.001
```

인데,

- guess가 더 이상 변하지 않음
- 오차는 여전히 0.001보다 큼
- 그런데 더 개선할 방법도 없음

👉 그래서 무한 반복 가능성 발생

---

# 🧊 직관적 비유

생각해봐:

- 1km 자로 나노미터를 재려고 하는 것과 같다.
    
- 도구의 해상도가 부족하다.
    

또는:

> 돋보기로 세균을 보려는 것과 같다.  
> 더 확대해도 안 보이는 건 해상도 한계 때문.

---

# 📌 수학 vs 컴퓨터

수학에서는:

$$
\sqrt{x}  
$$

는 정확히 존재한다.

하지만 컴퓨터에서는:

$$
\sqrt{x} \approx \text{근삿값}  
$$

만 가능하다.

그리고 그 근삿값도  
**표현 가능한 비트 한계 안에서만** 존재한다.

---

# 🎯 그래서 1.7의 핵심은

- 수학은 연속적이다.
- 컴퓨터는 이산적이다.
- 알고리즘은 하드웨어 현실을 고려해야 한다.

---