## Exercise 1.7 — 수치 계산의 현실

현재 종료 조건은 다음과 같다:

```js
function is_good_enough(guess, x) {
  return abs(square(guess) - x) < 0.001;
}
```

이 방식은 **절대 오차(absolute error)** 기준을 사용한다.

### 문제점

#### 1. **매우 작은 수**에서 부정확하다.  
예:
   ```js
   sqrt(0.0000001)
   ```
- 절대 오차가 0.001보다 작으면 종료되지만,  
- 실제 제곱근과는 큰 차이가 날 수 있다.

#### 2. 매우 큰 수에서 정밀도 문제가 발생한다.  
예:
   ```js
   sqrt(1000000000000000)
   ```
- 부동소수점 정밀도 한계 때문에  
- 오차가 0.001 이하로 줄어들지 않을 수도 있다.

### 원인

절대 오차 기준은 **수의 크기에 따라 의미가 달라진다.**  
즉, 스케일(scale)에 독립적이지 않다.

---

## 개선 방법 — 상대 오차(relative error) 사용

개선된 종료 조건:

```js
function is_good_enough(guess, x) {
  return abs(guess - improve(guess, x)) < 1e-7;
}
```

또는

```js
function is_good_enough(guess, x) {
  return abs(square(guess) - x) / x < 1e-7;
}
```

### 핵심 차이

| 방식 | 특징 |
|------|------|
| 절대 오차 | 큰 수 / 작은 수에서 깨짐 |
| 상대 오차 | 수의 크기와 무관하게 안정적 |

---

## 이 문제의 진짜 메시지

- 수학적 정의는 완벽하지만,
- 컴퓨터 계산은 항상 **근사(approximation)** 이다.
- 알고리즘은 **수치적 안정성(numerical stability)** 을 고려해야 한다.
- 프로그래밍은 단순한 수식 구현이 아니라, 현실적인 계산 모델 위에서 동작한다.