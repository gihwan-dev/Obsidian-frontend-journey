## 블록 클린아웃
- 블록 클린아웃은 트랙잭션에 의해 설정된 로우 Lock을 해제하고 블록 헤더에 커밋 정보를 기록하는 오퍼레이션
- [[오라클에서 로우 단위 Lock은 레코드의 속성으로 관리]]되며, 이는 로우 헤더로부터 블록 헤더에 있는 ITL 엔트리를 가리키는 포인터다
- 사용자가 트랜잭션을 커밋하면 블록 클린아웃까지 완료해야 완전한 커밋
- 대량의 갱신 작업에서는 커밋 정보를 트랜잭션에 기록하고 빠르게 커밋을 끝냄. 이후 해당 블록에 처음 액세스 되는 시점에 클린아웃
- 항상 이 방식으로 동작하지 않으면 Delayed 블록 클린아웃과 커밋 클린아웃 두 가지 메커니즘을 사용
- **Delayed 블록 클린아웃**
	- 트랜잭션이 갱신한 블록 개수가 총 버버 캐시 블록 개수의 1/10을 초과할 때 사용
		1. ITL 슬롯에 커밋 정보 저장
		2. 레코드에 기록된 Lock Byte 해제
		3. Online Redo에 Logging
	- Active 상태의 블록, 즉 다른 트랜잭션이 발생시킨 변경사항에 대한 커밋 정보가 아직 ITL에 기록되지 않았다면 읽기 전에 먼저 블록 클린아웃을 시도
	- ITL 슬롯의 트랜잭션 ID를 이용해 Undo 세그먼트 헤더에 있는 트랜잭션 테이블 슬롯을 찾아가 트랜잭션 현재 상태 확인 -> 커밋된 트랜잭션 이라면 ITL 슬롯에 반영 이후 로우 Lock 정보를 해제해 블록을 클린아웃 -> 블록 클린아웃을 위한 갱신 내용도 Redo에 로깅 및 블록 SCN 변경
- **커밋 클린아웃(= Fast 블록 클린아웃)**
	- 블록 클린아웃도 쓰기 작업이므로 Current 블록에 작업을 수행
	- RAC, OPS 환경에서는 Exclusive 모드로 Current 블록을 요청. RAC에서는 Dirty 상태의 버퍼 블록을 디스크 쓰기 작업 없이 인스턴스끼리 주고받는 것이 가능
	- 과거 OPS 환경에서는 일단 Dirty 블록을 디스크에 기록하면 그것을 디스크에서 읽어가는 방식을 사용. 이처럼 디스크를 거쳐 인스턴스간에 블록을 주고받는 과정을 '핑(ping)'이라고 함
	- OPS 환경에서 과도한 ping이 발생하는 문제를 해결하기 위해 커밋 클린아웃 방식이 도입됨
	- 트랜잭션이 갱신한 블록 개수가 [[버퍼 캐시 블록]] 개수의 1/10을 초과하지 않을 때는 커밋 시점에 곧바로 블록 클린아웃을 수행
	- 이 경우에도 커밋 시점에는 '불완전한 형태의 클린아웃'을 수행하며 해당 블록을 '갱신하는' 다음 트랜잭션에 의해 완전한 클린아웃이 이루어짐

## Snapshot too old(ORA-01555)
- 발생 원인을 요약하면 두 가지로 정리할 수 있음
	1. 데이터를 읽어 내려가다 쿼리 SCN 이후에 변경된 블록을 만나 과거 시점으로 롤백한 "Read Consistent" 이미지를 얻으려고 하는데, [[Undo 블록 재사용]]으로 인해 필요한 Undo 정보를 얻을 수 없는 경우. 코드에 문제가 없다면 **Undo 세그먼트가 너무 작다**는 신호
	2. 커밋된 [[트랜잭션 테이블 슬롯 재사용]]으로 커밋 정보를 확인할 수 없는 경우로, **Undo 세그먼드 개수가 적다**는 신호
- Snapshot too old 에러 발생 가능성을 줄이기 위한 애플리케이션 측면에서의 솔루션은 아래와 같다:
	1. 불필요하게 커밋을 자주 수행하지 않는다.
	2. fetch acroll commit 형태의 프로그램 작성을 피해 [[ANSI 표준]]을 따른다.
	3. 트랜잭션이 몰리는 시간대에 오래 걸리는 쿼리가 같이 수행되지 않도록 시간을 조정한다.
	4. 큰 테이블을 일정 범위로 나누어 읽고 단계적으로 실행할 수 있도록 코딩한다.
	5. 오랜 시간에 걸쳐 같은 블록을 여러 번 방문하는 Nested Loop 형태의 조인문 또는 인덱스를 경유한 테이블 액세스를 수반하는 프로그램이 있는지 체크하고, 이를 회피할 수 있는 방법을 찾는다.
	6. 소트 부하를 감수하더라도 order by 등을 강제로 삽입해 소트연산이 발생하도록 한다. 많은 데이터를 오랜 시간에 걸쳐 Fetch 하는 동안 Undo 정보를 지속적으로 참조하기 때문에 문제가 발생하는 것이므로, 서버 내에서 빠르게 데이터를 읽어 Temp 세그먼트에 저장하는 데에만 성공하면 이후 같은 블록을 재방문해도 에러 발생 걱정은 없다.
	7.  delayed 블록 클린아웃으로 인해 Snapshot too old가 발생하는 것으로 의심되면 대량 업데이트 후에 곧바로 해당 테이블에 대해 Full Scan 하도록 쿼리를 날리는 것도 하나의 해결방법이 될 수 있다.
