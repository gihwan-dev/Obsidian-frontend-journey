렌더기를 생성해 트리에 추가할 때 위치와 크기는 없다. 이러한 값을 계산하는 것을 레이아웃 또는 리플로라고 한다.

HTML은 "흐름" 기반 레이아웃 모델을 사용한다. 대부분의 경우 단일 경로로 도형을 계산할 수 있다. '흐름'에서 나중에 나오는 요소는 일반적으로 먼저 나오는 요소의 도형에 영향을 미치지 않으므로 레이아웃은 왼족에서 오른쪽, 위에서 아래로 진행될 수 있다. 예외로 테이블에는 두 개 이상의 패스가 필요할 수 있다.

레이아웃은 재귀 프로세스다. `html` 요소에 해당하는 루트 렌더러에서 시작된다. 레이아웃은 일부 또는 전체를 재귀적으로 거치면서 필요한 각 렌더러의 기하학적 정보를 계산한다.

루트 렌더러의 위치는 0,0이고 크기는 뷰포트다.

모든 렌더러에는 '레이아웃' 또는 '리플로우' 메서드가 있으며, 각 렌더러는 레이아웃이 필요한 하위 요소의 레이아웃 메서드를 호출한다.

#레이아웃 
## 더티 비트 시스템

모든 사소한 변경에 대해 전체 레이아웃을 실행하지 않기 위해 "더티 비트" 시스템을 사용한다. 변경되거나 추가된 렌더러는 자체와 하위 요소를 "더티"로 표시하여 레이아웃이 필요하다고 한다.

"dirty" 이외에 "children are dirty" 라는 플래그가 있다. 이는 렌더러 자체는 문제가 없지만 레이아웃이 필요한 하위 요소가 하나 이상 있음을 의미한다.

## Global 및 Incremental 레이아웃

### Global Layout
- 문서 전체의 레이아웃을 처음부터 다시 계산
- 모든 요소의 크기와 위치를 재계산

초기 페이지 로드, 창 크기 변경, 폰트 크기 변경 같은 상황에 전역 레이아웃이 트리거 될 수 있다.

### Incremental Layout
- 더러운 렌더러만 다시 계산
- 레이아웃 과정에서 추가 레이아웃이 필요할 수 있음

렌더러가 더티인 경우 Incremental Layout이 (비동기식으로) 트리거된다. 추가 콘텐츠가 DOM 트리에 추가되며 새 런더러가 렌더링 트리에 추가되는 경우가 있다.

## 비동기 및 동기 레이아웃

Incremental Layout은 비동기식으로 실행된다. 파이어폭스는 "Reflow 명령어"를 큐에 추가하고 스케줄러가 일괄 실행을 트리거 하도록 한다. 웹킷에는 타이머를 통해 Incremental Layout을 실행한다. 타이머를 통해 레이아웃이 실행되면 루트부터 트리를 순회하며 더티 렌더러를 발견하고 처리한다.

`offsetHeight`와 같이 스타일 정보를 요청하는 스크립트는 동기식 Incremental Layout을 트리거할 수 있다.

> [!Note] 동기식 Incremental Layout을 트리거 하는데 배치 처리가 가능한 이유
> 
> 브라우저는 동일한 프레임 내의 레이아웃 관련 읽기 작업을 감지한다.
> 
> ```js
> // 예시 1: 읽기만 있는 경우
> const h1 = div1.offsetHeight;  // 레이아웃 계산
> const h2 = div2.offsetHeight;  // 캐시된 값 사용
> const h3 = div3.offsetHeight;  // 캐시된 값 사용
> 
> // 예시 2: 읽기와 쓰기가 섞인 경우
> const h1 = div1.offsetHeight;  // 레이아웃 계산
> div1.style.height = '100px';   // 스타일 변경 (레이아웃 무효화)
> const h2 = div2.offsetHeight;  // 새로운 레이아웃 계산 필요
> ```
> 1. 읽기 작업이 발생하면 현재 레이아웃이 유효한지 확인
> 2. 레이아웃이 무효화되었다면(dirty) 새로 계산
> 3. 쓰기 작업이 발생하면 레이아웃을 무효화
> 4. 이후의 읽기 작업에서 새로운 레이아웃 계산이 필요

글로벌 레이아웃은 일반적으로 동기식으로 트리거 된다.

스크롤 위치와 같은 일부 속성이 변경되어 초기 레이아웃 후 콜백으로 레이아웃이 트리거 되는 경우도 있다.

## 최적화

레이아웃이 'transform' 또는 'position'으로 트리거되면 재계산되지 않는다.
**예:**
```html
<!-- 예시 1: transform 사용 -->
<div id="box" style="transform: translate(100px, 100px);">
    내용
</div>

<!-- 예시 2: position: fixed 요소의 이동 -->
<div style="position: fixed; top: 0; left: 0;">
    헤더
</div>

이유:
- transform은 레이아웃 계산 없이 GPU에서 처리
- fixed 위치 요소는 일반 문서 흐름에서 분리됨
```

하위 트리만 수정되고 레이아웃이 루트에서 시작되지 않는 경우도 있다. 이는 변경사항이 로컬이고 주변에 영향을 미치지 않는 경우 발생할 수 있다 (예: 텍스트 필드에 삽입된 텍스트).
**예:**
```html
<!-- 예시 1: 텍스트 입력 -->
<div style="width: 300px;">
    <p style="width: 100%;">고정된 너비의 문단</p>
    <input type="text" style="width: 200px;">
    <p style="width: 100%;">다른 고정된 너비의 문단</p>
</div>

<!-- 예시 2: overflow: auto인 컨테이너 내부 변경 -->
<div style="height: 200px; overflow: auto;">
    <p>내용이 추가되는 영역</p>
</div>

이유:
- 입력 필드의 텍스트 변경은 필드 내부로 제한됨
- overflow 컨테이너는 내부 변경이 외부로 영향을 주지 않음
```

## 레이아웃 프로세스

일반적으로 레이아웃은 다음과 같은 패턴을 가진다.

1. 상위 렌더러가 자체 너비를 결정한다.
2. 부모가 자녀를 보고 다음을 실행한다.
	1. 하위 렌더러를 배치한다 (x 및 y 설정).
	2. 필요한 경우 하위 레이아웃을 호출한다 (더러운 상태 이거나 전역 레이아웃 프로세스 중이거나 등등 다양한 이유). 이때 자식의 높이가 계산된다.
3. 상위 요소는 하위 요소의 누적 높이와 여백 및 패딩의 높이를 사용해 자체 높이를 설정한다. 이는 상위 렌더기의 상위 요소에 의해 사용된다.
4. 더티 비트를 false로 설정한다.

## 너비 계산

렌더러의 너비는 컨테이너 블록의 너비, 렌더러의 스타일 '너비' 속성, 여백, 테두리를 사용하여 계산된다.

다음의 div의 너비를 계산해보자.

```html
<div style="width: 30%" />
```

웹킷에서는 다음과 같이 계산된다.
- 컨테이너 너비는 컨테이너의 `availableWidth`와 `0` 중 최대값이다. `availableWidth`는 `contentWidth`이고 다음과 같이 계산된다.
	- `clientWidth() - paddingLeft() - paddingRight()`
	- `clientWidth` 및 `clientHeight`는 테두리와 스크롤바를 제외한 객체 내부를 나타낸다.
- 요소 너비는 `width` 스타일 속성이다. 컨테이너 너비의 비율을 계산해 절대값으로 계산된다.
- 테두리와 패딩이 추가된다.

현재까지는 "선호하는 너비"의 계산 이였다. 이제 최소 너비와 최대 너비가 계산된다. 만약 선호하는 너비가 최대 너비보다 크다면 최대 너비가 사용된다. 반대로 선호하는 너비가 최소 너비보다 작다면 최소 너비가 적용된다. 이 값은 캐시되어 레이아웃 재계산이 필요할 때 재사용된다.

## 텍스트 레이아웃 줄바꿈

레이아웃 중간에 있는 렌더러가 중단해야 한다고 결정하는 경우가 있다. 이 경우 레이아웃이 중지되고 렌더러의 상위 요소에 중단해야 한다고 전파한다. 상위 요소는 추가 렌더기를 만들고 레이아웃을 호출한다.

아래 예시를 보자:
```html
<div style="width: 200px">
    이것은 매우 긴 텍스트 콘텐츠입니다. 
    컨테이너의 너비를 넘어가면 자동으로 
    다음 줄로 나뉘어져야 합니다.
</div>
```

1. 렌더러가 텍스트를 배치한다.
2. 컨테이너 너비를 초과할 것 같다면
3. 적절한 위치에서 줄을 나눈다.
4. 새로운 라인 박스를 생성해 나머지 콘텐츠를 처리한다.
