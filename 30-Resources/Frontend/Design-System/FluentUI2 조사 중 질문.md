# 1. 코드와 피그마가 동기적이지 않음
## 질문
```
디자인 시스템을 공부하고 있거든? Fluent2 디자인 시스템을 조사하는 중인데, 아래와 같은 특징을 발견했어.

--- 
디자인 시스템에서 피그마와, 코드 3개의 일치율이 100%에 가까울수록 이상적이라고 한다. Fluent2 디자인 시스템에서는 다르다. 피그마에서는 state를 통해 토글 상태가 정의되지만, 코드에서는 ToggleButton을 이용하며 상태 또한 checked를 통해 관리된다. 
---

왜 그런걸까? 피그마에서도 그냥 state를 사용하지 않고 토글 버튼을 별도로 만드는게 좋을거 같은데. 왜 이렇게 해둔걸까? 분리하는게 개발하는 입장에서 좋지 않나?
```

## 답변
Fluent 2 디자인 시스템에서 피그마와 코드 간의 이러한 차이점에 대한 궁금증이 있으시군요. 이런 불일치가 발생하는 데는 몇 가지 가능한 이유가 있습니다.

디자인 도구(피그마)와 실제 구현(코드) 사이에 차이가 있는 주요 이유는:

1. **도구의 특성 차이**: 피그마는 시각적 디자인 도구로, 상태 관리를 위한 방식이 코드 구현과 다릅니다. 피그마에서는 시각적으로 쉽게 이해할 수 있는 방식(state 변수)으로 상태를 표현하는 반면, 코드에서는 기술적 요구사항에 맞는 구현(ToggleButton 컴포넌트와 checked 속성)을 사용합니다.
    
2. **관심사 분리**: 디자이너와 개발자는 서로 다른 관점에서 작업합니다. 디자이너는 시각적 일관성과 사용자 경험에 초점을 맞추고, 개발자는 코드 재사용성, 접근성, 성능 최적화에 중점을 둡니다.
    
3. **구현 현실성**: 가끔은 디자인 도구에서 완벽하게 표현할 수 없는 기술적 제약이 있습니다. 특히 토글 버튼 같은 상호작용 요소는 실제 동작 방식을 피그마에서 완벽히 구현하기 어려울 수 있습니다.
    

Microsoft의 Fluent 2 디자인 시스템의 경우, 이런 불일치는 의도적인 결정일 가능성이 높습니다:

- **제품군 통합**: Microsoft는 다양한 플랫폼과 제품을 가지고 있어, 특정 구현 디테일보다 일관된 시각적 언어를 중요시할 수 있습니다.
- **레거시 시스템 호환성**: 기존 코드베이스와의 호환성을 위해 코드 측면에서 특정 패턴을 유지해야 할 수도 있습니다.
- **접근성 고려**: ToggleButton 컴포넌트는 접근성 표준을 충족하기 위한 많은 기능을 내장하고 있어, 단순한 state 변수보다 더 복잡한 구현이 필요할 수 있습니다.

디자인-코드 간 100% 일치가 이상적이라는 의견은 맞지만, 실무에서는 종종 타협이 필요합니다. Fluent 2의 경우 이러한 차이가 있더라도 디자이너와 개발자가 명확한 문서와 가이드라인을 통해 소통한다면, 최종 제품의 일관성을 유지할 수 있습니다.

디자이너 관점에서 ToggleButton을 별도 컴포넌트로 분리하지 않은 이유는 다음과 같은 요인들이 있을 수 있습니다:

1. **단순성과 유연성 유지**:
    - 피그마에서는 복잡한 상태 관리보다 디자인 요소의 시각적 표현에 집중합니다. state를 통한 관리는 디자이너에게 더 직관적이고 접근하기 쉬운 방식일 수 있습니다.
    - 별도 컴포넌트로 만들면 추가적인 복잡성이 생기고, 디자인 시스템의 일부 유연성이 제한될 수 있습니다.

2. **디자인 시스템의 일관성**:    
    - Fluent 2 디자인 시스템에서는 다른 인터랙션 요소들도 유사한 방식으로 관리되고 있을 수 있습니다. 토글만 다르게 처리하면 디자인 시스템 내에서 일관성이 떨어질 수 있습니다.
    - 피그마에서 모든 상태 변화를 단일한 방식(state 변수)으로 관리하면 디자이너들이 시스템을 더 쉽게 배우고 사용할 수 있습니다.

3. **디자인 워크플로우 최적화**:    
    - 디자이너들은 종종 여러 상태(기본, 호버, 활성화 등)를 빠르게 전환하며 작업합니다. 단순한 state 변수 사용이 이런 워크플로우에 더 적합할 수 있습니다.
    - 복잡한 컴포넌트 구조는 디자인 반복 과정을 느리게 만들 수 있습니다.

4. **디자인 도구의 제약**:    
    - 피그마의 기술적 제약으로 인해 코드에서 사용하는 것과 같은 방식으로 컴포넌트를 구현하기 어려울 수 있습니다.
    - 피그마는 실제 코드처럼 작동하지 않기 때문에, 복잡한 상태 관리나 컴포넌트 계층구조를 정확히 모방하기 어렵습니다.

5. **역사적/조직적 이유**:    
    - Fluent 디자인 시스템이 발전해오면서 기존 디자인 관행이 유지되었을 수 있습니다.
    - 큰 조직에서는 디자인팀과 개발팀 간의 워크플로우가 이미 확립되어 있어, 변경이 쉽지 않을 수 있습니다.

6. **의도적 추상화**:    
    - 디자이너가 구현 세부사항보다 사용자 경험과 시각적 일관성에 집중할 수 있도록 의도적으로 추상화 레벨을 다르게 유지했을 수 있습니다.
    - 피그마는 디자인 탐색 도구이므로, 코드 구현 방식과 정확히 일치할 필요가 없다고 판단했을 수 있습니다.

물론 이는 추론에 기반한 가능한 이유들이며, Microsoft 디자인팀의 실제 결정 이유는 다를 수 있습니다. 디자인 시스템은 계속 진화하므로, 미래 버전에서는 이런 불일치가 해소될 가능성도 있습니다.
