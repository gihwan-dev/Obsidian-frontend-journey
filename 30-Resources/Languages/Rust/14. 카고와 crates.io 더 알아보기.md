카고는 지금 다뤘던 일들보다 더 많은 일을 할 수 있다. 아래 목록의 기능을 수행하는 몇 가지 고급 기능들을 알아보자.

- 릴리스 프로필을 통한 빌드 커스터마이징하기
- `creates.io`에 라이브러리 배포하기
- 대규모 작업을 위한 작업 공간 구성하기
- `creates.io`로부터 바이너리 설치하기
- 커스텀 명령어로 카고 확장하기

## 릴리스 프로필을 통한 빌드 커스터마이징하기

**릴리스 프로필** 이란 설정값을 가지고 있는 미리 정의된, 커스터마이징 가능한 프로필인데, 이 설정값으로 컴파일을 위한 다양한 옵션을 제어할 수 있다.

카고는 두 개의 주요 프로필을 가지고 있다.

- `dev`: `cargo build`를 실행할 때 쓰인다.
- `release`: `cargo build --release` 를 실행할 때 쓰인다.

`Cargo.toml` 파일에 `[profile.*]` 섹션을 명시적으로 추가하지 않을 경우 적용되는 각 프로필의 기본 설정이 있다. 여기에 섹션을 추가하면 기본 설정을 덮어쓸 수 있다.

```toml
[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
```

`opt-level` 설정은 러스트가 코드에 적용할 최적화 수치이며, 0에서 3 사이의 값을 가진다. 최적화 수치를 적용할수록 컴파일 시간이 늘어나기때문에, 개발 중 코드를 자주 컴파일하는 상황이라면 코드의 실행 속도가 조금 느려지더라도 컴파일이 빨리 되도록 덜 최적화하길 원할 것이다. 따라서 `dev`의 `opt-level` 기본값은 0으로 되어 있다.

## crates.io에 크레이트 배포하기

지금까지는 프로젝트의 디펜던시로 `creates.io`의 패키지를 이용해왔지만, 자신의 패키지를 배포해 다른 사람들과 공유할 수 있다.

### 유용한 문서와 주석 만들기

패키지에 대한 상세한 문서화는 다른 사용자들이 패키지를 어떻게, 언제 사용해야 하는 알게 해준다. 러스트에는 **문서화 주석(documentation comment)** 라고 불리는 문서화를 위한 특별한 종류의 주석이 있다. 이 주석의 `HTML`을 생성해준다.

```rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_create::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
///
pub fn add_one(x: i32) -> i32 {
	x + 1
}
```

`cargo doc`을 실행하면 이 문서화 주석으로부터 `HTML`이 생성된다. 생성된 문서는 `target/doc` 디렉터리에 삽입된다.

`cargo doc --open`을 실행하면 문서에 대해 `HTML`을 생성하고 그 결과를 웹브라우저에 띄워준다.

#### 자주 사용되는 절

`Examples` 라는 제목을 가진 절을 만들었다. 이외에 크레이트 저자가 문서에서 자주 사용하는 절은 다음과 같다.

- **Panics**: 문서화된 함수가 패닉을 일으킬 수 있는 시나리오다. 함수를 호출하는 쪽에서 자신의 프로그램이 패닉을 일으키는 것을 원치 않는다면 이러한 상황에서 함수를 호출하지 않음을 확실히 해야 한다.
- **Errors**: 해당 함수가 `Result`를 반환하는 경우에는 발생할 수 있는 에러의 종류와 해당 에러들이 발생하는 조건을 설명해 준다면 사용하는 사람들의 에러 처리 방법에 도움이 된다.
- **Safety**: 함수가 호출하기에 `unsafe`한 경우라면, 이 함수가 안전하지 않은 이유와 호출자가 이 함수를 호출할 때 지켜야 할 불변성에 대해 설명하는 절이 있어야 한다.

#### 테스트로서의 문서화 주석

문서화 주석에 추가된 예시 코드는 `cargo test` 실행시 함께 실행된다. 예시를 포함한 문서보다 좋은 문서는 없다.

#### 주석이 포함된 아이템

문서화 주석 `//!`은 주석 뒤에 오는 아이템을 문서화하는 것이 아닌 주석을 담고 있는 아이템을 문서화한다. 일반적으로 크레이트 루트 파일 혹은 모듈에 사용해 크레이트 혹은 모듈 전체에 대한 문서를 작성하는데 쓴다.

### pub use로 변리하게 공개 API 내보내기

`pub use`를 이용해 내부 아이템을 **다시 내보내서(re-export)** 해서 기존의 비공개 구조와 다른 공개 구조를 만들 수 있다.

공개 API로부터 내부 구조를 제거하기 위해 `pub use` 구문으로 불러와 최상위 단계에서 다시 내보내야 한다.


### creates.io 계정 설정하기

어떤 크레이트를 배포하기에 앞서 `creates.io`에서 계정을 만들고 API 토큰을 얻을 필요가 있다. 깃허브로 로그인해서 토큰을 얻은 후, `cargo login <토큰>`으로 로그인 하면 된다.

### 새 크레이트에 메타데이터 추가하기

배포하기 전, `Cargo.toml`파일의 `[package]` 섹션 안에 메타데이터 몇 가지를 추가할 필요가 있다.

1. `name`: 크레이트의 이름이다. 이름은 고유해야 하며, 선착순이다.
2. `description`: 크레이트에 대한 설명이다.
3. `license`: **라이선스 식별자 값**이 필요하다. ex) "MIT"

### crates.io에 배포하기

배포는 **영구적이다**. 버전은 덮어씌워질 수 없고, 코드는 삭제될 수 없다. `cargo publish`를 통해 배포할 수 있다.

### 이미 존재하는 크레이트의 새 버전 배포하기

`version` 값을 바꿔서 `cargo publish`을 실행하면 된다.

### cargo yank로 crates.io에서 버전 사용하지 않게 하기

코드 삭제는 안되지만, 향후의 프로젝트들이 이를 새로운 디펜던시로 추가하는 것을 방지할 수 있다.

배포한 크레이트의 디렉터리에서 다음 명령어를 실행한다.

```bash
cargo yank --vers 1.0.1
```

이제 `1.0.1` 버전은 사용할 수 없게 된다.

## 카고 작업 공간

라이브러리 크레이트가 점점 거대해지면 패키지를 여러개의 라이브러리 크레이트로 분리하고 싶을 수 있다. 카고는 **작업 공간**이라는 기능을 제공해 여러 관련 패키지를 관리하는데 도움을 준다.

### 작업 공간 생성하기

**작업 공간(workspace)** 는 동일한 `Cargo.lock`와 출력 디렉터리를 공유하는 패키지들의 집합이다. 작업 공간을 이용해 프로젝트를 만들어 보자. `add`라는 폴더를 만들고 `Cargo.toml` 파일을 만든 후 다음을 입력한다.

```toml
[workspace]

members = [
	"adder",
]
```

다음엔 `add` 디렉터리 내에서 `cargo new`를 실행해 `adder` 바이너리 크레이트를 생성한다.

```bash
cargo new adder
```

이 시점에서 디렉터리 구조는 다음과 같다.
```text
Cargo.lock
Cargo.toml
	adder
		Cargo.toml
		src
			main.rs
	target
```

`adder` 디렉터리 내에서 `cargo build`를 실행하더라도 컴파일 결과는 `add/target`에 위치하게 될거다.

### 작업 공간에 두 번째 피키지 생성하기

이제 `add_one`이라는 새 라이브러리 크레이트를 생성하자.

```bash
cargo new add_one --lib
```

이제 다음과 같은 디렉터리 구조를 가질거다.

```
Cargo.lock
Cargo.toml
	adder
		Cargo.toml
		src
			main.rs
	add_one
		Cargo.toml
		src
			lib.rs
	target
```

`adder` 패키지에서 `add_one`의 패키지를 사용하려면 어떻게 해야 할까?

`adder/Cargo.toml`에 `add_one`의 경로 디펜던시를 추가해야 한다.

```toml
[dependencies]
add_one = { path = "../add_one" }
```

카고는 작업 공간 내의 크레이트들이 서로 의존할 것이라 가정하지 않기 때문에 디펜던시 관계에 대해 명시할 필요가 있다.

이제 사용해보자.

`adder/src/main.rs`에서 다음과 같이 작성한다.

```rust
use add_one;

fn main() {
	add_one::<함수>();
}
```

이제 최상위 `add` 디렉터리에서 `cargo build`를 실행해 작업 공간을 빌드해보자.

```bash
cargo build
```

이제 바이너리 크레이트를 실행해보자.

`cargo run -p <바이너리 패키지 이름>`

#### 작업 공간에서 외부 패키지 의존하기

작업 공간에는 각 크레이트 디렉터리마다 `Cargo.lock`이 생기지 않고, 최상위 하나의 `Cargo.lock`이 생간다. 모든 크레이트에서 같은 디펜던시에 의존하게 하기 위해서다. `rand` 패키지를 사용해보자.

`add_one/Cargo.toml`파일에 다음을 추가한다.

```toml
[dependencies]
rand = "0.8.5"
```

이제 `add` 디렉터리에서 `cargo build`를 실행하자.

`adder`에서 `rand`를 사용하려면 `adder/Cargo.toml`에 의존성을 같은 버전으로 추가해주면 된다.

#### 작업 공간에 테스트 추가하기

`add_one:add_one` 함수의 테스트를 `add_one` 크레이트 내에 추가해보자.

```rust
pub fn add_one(x: i32) -> i32 {
	x + 1
}

#[cfg(test)]
mod tests {
	use supder::*;

	#[test]
	fn it_works() {
		assert_eq!(3, add_one(2));
	}
}
```

이후 최상위 `add` 디렉터리에서 `cargo test`를 실행해봐라. 모든 크레이트에 대한 테스트를 실행할거다.

```bash
cargo test -p add_one
```

을 통해 특정 패키지에 대한 테스트만 실행할 수 있다.

배포도 `-p` 태그를 사용해서 특정 패키지만 배포할 수 있다.

## cargo install로 crates.io에 있는 바이너리 설치하기

`cargo install` 명령어는 로컬 환경에 바이너리 크레이트를 설치하고 사용할 수 있도록 해준다. 바이너리 타깃을 가진 패키지만 설치할 수 있다. **바이너리 타깃이란 `src/main.rs`** 파일 혹은 따로 바이너리로 지정된 파일을 가진 크레이트가 생성해낸 실행 가능한 프로그램을 말한다.

`cargo install`을 이용해 설치된 모든 바이너리는 설치 루트의 `bin` 디렉터리에 저장된다.

## 커스텀 명령어로 카고 확장하기

`$PATH`에 있는 어떤 바이너리의 이름이 `cargo-something` 이라면 `cargo something` 이라는 명령어로 마치 카고의 보조 명령어인 것처럼 실행할 수 있다.
