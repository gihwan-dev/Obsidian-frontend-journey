> [원문](https://kentcdodds.com/blog/colocation)

우리 모두는 유지보수하기 쉬운 코드베이스를 원하기 때문에, 코드베이스(또는 코드베이스의 우리 영역)를 유지보수 가능하고 이해하기 쉽게 만들려는 최선의 의도로 시작합니다. 시간이 지나면서 코드베이스가 커질수록 의존성(JS, CSS, 이미지 등)을 관리하는 것이 점점 더 어려워질 수 있습니다. 프로젝트가 성장함에 따라 코드베이스의 상당 부분이 "부족 지식"(당신이나 소수의 사람만이 알고 있는 지식)이 되어가고, 이러한 종류의 지식은 "기술 부채"로 이어집니다(이 용어가 정확하든 아니든). 

저는 코드베이스를 작성자인 저뿐만 아니라, 팀원들, 미래의 유지보수 담당자들, 그리고 6개월 후의 제가 관리할 수 있도록 유지하는 것을 선호합니다. 이것이 우리의 코드베이스에서 추구해야 할 훌륭한 이상이라는 점에 우리 모두가 동의할 수 있을 것입니다. 이를 달성하기 위해 우리가 사용할 수 있는 다양한 도구와 기술들이 있습니다.
## 코드 주석에 대해서
코드 주석에 대해 이야기해 봅시다. 코드에 주석을 달아야 하는지(당연히 달아야 합니다)와 주석의 내용이 무엇이어야 하는지(예상치 못한 것을 왜 하는지 설명하여 나중에 오는 사람들이 예상치 못하거나 이상한 코드에 대한 결정을 이해할 수 있게 해야 합니다)에 대해서는 논의하고 싶지 않습니다. 대신 이러한 코드 주석들이 어디에 위치해야 하는지에 초점을 맞추고 싶습니다.

우리는 일반적으로 이러한 주석들을 설명하고자 하는 코드와 최대한 가깝게 배치하여 "공동 위치"시킵니다. 잠시 이것을 다르게 한다면 어떨지 생각해봅시다. 만약 이러한 주석들을 완전히 별도의 파일에 배치한다면 어떨까요? 거대한 `DOCUMENTATION.md` 파일이나 심지어 `src/` 디렉토리와 매핑되는 `docs/` 디렉토리를 만든다고 생각해보세요. 재미있게 들리나요?  네, 저도 그렇게 생각하지 않습니다. 주석을 설명하는 코드와 함께 배치하지 않으면 우리는 몇 가지 심각한 문제들을 마주하게 될 것입니다.

- **유지보수성**: 주석들이 (이미 그런 것보다) 더 빨리 동기화가 깨지거나 outdated될 것입니다. 우리는 해당하는 `docs/` 파일을 업데이트하지 않은 채로 `src/` 파일을 이동하거나 삭제하게 될 것입니다.
- **적용성:** `src/`의 코드를 보는 사람들이 `docs/`의 중요한 주석을 놓치거나, 자신이 수정 중인 `src/` 파일에 대한 `docs/` 파일이 이미 존재한다는 것을 알지 못해 자신의 코드에 주석을 달지 않을 수 있습니다.
- **사용 용이성:** 이러한 설정에서는 한 위치에서 다른 위치로의 문맥 전환도 어려운 과제가 될 것입니다. 여러 위치의 파일들을 다뤄야 하는 것은 컴포넌트 유지보수에 필요한 모든 것을 확보하기 어렵게 만들 수 있습니다.

물론 이런 종류의 코드 주석 스타일에 대한 규칙을 만들 수는 있겠지만, 왜 그래야 할까요? 주석을 설명하고자 하는 코드와 함께 배치하는 것이 더 단순하지 않을까요?

## 그래서 요점은?
아마도 여러분은 이렇게 생각하고 계실 겁니다: "그래, 당연하지. 이것이 바로 아무도 `docs/` 방식을 사용하지 않고 모두가 주석을 코드와 함께 배치하는 이유잖아. 뻔한 얘기네. 요점이 뭐야?" 제가 말씀드리고 싶은 점은 공동 배치(co-location)의 이점이 모든 곳에 있다는 것입니다.

## 30-Resources/Frontend/HTML/View
HTML을 예로 들어보겠습니다. 주석을 공동 배치하는 모든 이점들이 우리의 템플릿에도 그대로 적용됩니다. React와 같은 현대적인 프레임워크가 나오기 전에는, 뷰 로직과 뷰 템플릿을 완전히 다른 디렉토리에 두었습니다. 이는 위에서 설명한 것과 같은 문제들에 취약합니다.

요즘은 React와 Vue와 같은 프레임워크에서 이러한 것들을 같은 파일에 두는 것이 훨씬 더 일반적입니다. Angular의 경우 같은 파일에 있지 않더라도, 템플릿 파일이 최소한 연관된 JS 파일 바로 옆에 위치합니다.

## CSS
이 개념이 잘 적용되는 또 다른 예는 CSS입니다. CSS-in-JS의 장점에 대해 논쟁하지는 않겠습니다(정말 환상적이죠), 하지만 그 이점들은 정말 대단합니다.

## Tests
파일 공동 배치라는 이 개념은 유닛 테스트에도 아주 잘 적용됩니다. `src/` 디렉토리와 이를 반영하려 시도하는 유닛 테스트들로 가득 찬 `test/` 디렉토리가 있는 프로젝트를 얼마나 흔하게 볼 수 있나요? 위에서 설명한 모든 함정들이 여기에도 적용됩니다.

저는 유닛 테스트를 정확히 같은 파일에 넣는 것까지는 하지 않겠지만, 그것이 흥미로운 아이디어라는 점도 완전히 배제하지는 않습니다(구현은 독자의 연습 과제로 남겨두겠습니다). 더 유지보수하기 쉬운 코드베이스를 만들기 위해, 우리는 테스트 파일들을 테스트 대상이 되는 파일이나 파일 그룹과 함께 배치해야 합니다. 이렇게 하면 새로운 사람들(또는 6개월 후의 제가)이 코드를 볼 때, 해당 모듈이 테스트되었다는 것을 즉시 알 수 있고 그 테스트들을 모듈을 이해하기 위한 참조로 사용할 수 있습니다. 그들이 변경사항을 만들 때, 이는 그들의 변경사항을 반영하기 위해 테스트를 업데이트(추가/제거/수정)해야 한다는 것을 상기시켜 줍니다.

## State
애플리케이션/컴포넌트 상태도 같은 이점을 경험합니다. 상태가 이를 사용하는 UI와 더 분리되고 간접적일수록, 유지보수하기가 더 어려워집니다. 상태를 지역화하는 것은 유지보수성 외에도 더 많은 이점이 있는데, 애플리케이션의 성능도 향상시킵니다.

애플리케이션 컴포넌트 트리의 한 구석에서 일어나는 상태 변경은 트리의 최상단에서 일어나는 상태 변경보다 훨씬 적은 수의 컴포넌트만 리렌더링하게 됩니다. 여러분의 상태를 지역화하세요.

## "Reusable" utility files
이는 "유틸리티" 파일과 함수에도 적용됩니다. 컴포넌트를 작성하다가 별도의 함수로 추출할 수 있는 좋은 코드를 발견했다고 상상해보세요. 여러분은 그것을 추출하고 이렇게 생각합니다: "음... 많은 사람들이 이걸 사용할 수 있겠는데." 그래서 여러분은 그것을 앱의 `utils/` 디렉토리로 옮기고 다른 일을 하러 갑니다.

나중에 여러분의 컴포넌트는 삭제되지만, 작성한 유틸리티는 눈에 보이지 않고 잊혀진 채로 남아있게 됩니다(테스트와 함께). 왜냐하면 그것을 삭제한 사람이 더 널리 사용되고 있다고 가정했기 때문입니다. 수년에 걸쳐, 엔지니어들은 더 이상 필요하지 않다는 것을 깨닫지도 못한 채 그 함수와 테스트가 계속 제대로 작동하도록 열심히 노력합니다. 낭비된 노력과 인지적 부담입니다.

만약 그 함수를 사용하는 파일에 직접 두었다면, 상황은 완전히 달라졌을 것입니다. 복잡한 유틸리티 함수의 단위 테스트를 하지 말라는 것이 아닙니다(제발 하세요), 하지만 그것들을 필요한 곳 가까이에 두면 문제를 피하는 데 도움이 됩니다.

> [!danger] 그리고 제발 부탁드리니, 이 ESLINT 규칙과 이와 비슷한 모든 규칙들을 삭제해 주세요.

## The principle
**공동 배치의 개념은 다음과 같은 기본 원칙으로 요약될 수 있습니다:**

> [!note] 코드를 관련된 곳과 최대한 가깝게 배치하세요

"함께 변경되는 것들은 합리적으로 가능한 한 가깝게 위치해야 한다"라고 말할 수도 있습니다. (Dan Abramov가 한번 저에게 이와 비슷한 말을 했습니다). 

## Open Source made easy(-er)
앞서 논의한 문제들을 피하는 것 외에도, 프로젝트를 이런 방식으로 구조화하는 데는 다른 이점들이 있습니다. 컴포넌트를 오픈 소스 프로젝트로 전환하는 것은 대개 폴더를 다른 프로젝트에 복사/붙여넣기 하고 npm에 배포하는 것만큼 간단합니다. 그런 다음 프로젝트에 설치하고 `require/import` 구문을 업데이트하기만 하면 끝입니다.

## Exceptions
물론 시스템 전체 또는 일부를 아우르는 문서와 요소들이 어떻게 통합되는지에 대한 좋은 논거가 있습니다. 그리고 컴포넌트들을 아우르는 통합 테스트나 엔드투엔드 테스트는 어디에 둘까요? 이것들이 예외라고 생각할 수 있지만, 실제로는 위에서 언급한 원칙을 잘 따를 수 있습니다.

만약 제가 사용자 인증과 관련된 앱의 일부분이 있고 그 흐름을 문서화하고 싶다면, 사용자 인증과 관련된 모든 모듈이 있는 폴더에 README.md 파일을 둘 수 있습니다. 만약 그 흐름에 대한 통합 테스트를 작성해야 한다면, 그 테스트들을 위한 파일을 같은 폴더에 둘 수 있습니다. 엔드투엔드 테스트의 경우, 일반적으로 프로젝트의 루트에 두는 것이 더 합리적입니다.

이들은 프로젝트 자체를 넘어 시스템의 다른 부분까지 아우르기 때문에, 별도의 디렉토리에 두는 것이 제게는 합리적으로 보입니다. 이들은 실제로 src/ 파일들과 매핑되지 않습니다. 사실, E2E 테스트는 src/가 어떻게 구성되어 있는지 전혀 신경 쓰지 않습니다. src/ 디렉토리의 파일들을 리팩토링하고 이동하는 것이 E2E 테스트를 변경해야 할 필요성을 만들지 않아야 합니다.

## Conclusion
우리의 목표는 가능한 한 유지보수가 쉬운 소프트웨어를 만드는 것입니다. 주석을 공동 배치함으로써 얻는 유지보수성, 적용성, 사용 용이성의 이점들을 다른 것들의 공동 배치를 통해서도 얻을 수 있습니다. 만약 한 번도 시도해보지 않았다면, 한번 시도해보시기를 추천합니다.

추신. 만약 "관심사의 분리" 원칙을 위반하는 것이 걱정된다면, Pete Hunt의 이 강연을 보고 그 의미를 다시 평가해보시기를 추천합니다 😀.

추신의 추신. 이는 이미지와 실제로 다른 모든 리소스에도 훌륭하게 적용된다는 점도 언급해야겠습니다. 그리고 webpack과 같은 도구를 사용하면, 이러한 리소스들을 공동 배치하는 것도 엄청나게 쉽습니다. 솔직히 말해서, 이것이 제 의견으로는 webpack의 핵심 가치 제안 중 하나입니다.
