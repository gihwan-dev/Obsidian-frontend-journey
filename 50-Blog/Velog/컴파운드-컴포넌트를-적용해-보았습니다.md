---
type: blog-post
source: velog
author: "koreanthuglife"
title: "컴파운드 컴포넌트를 적용해 보았습니다!"
slug: "컴파운드-컴포넌트를-적용해-보았습니다"
velogId: "abd1c17e-1d34-4eb7-9d4e-abba786f4c22"
velogUrl: "https://velog.io/@koreanthuglife/컴파운드-컴포넌트를-적용해-보았습니다"
published: "2024-04-22T05:43:03.958Z"
updated: "2026-02-07T16:23:22.997Z"
tags:
  - "React"
  - "next.js"
  - "리액트"
description: "Props 체이닝으로 고민하고 계시다면 꼭 읽어 주세요!"
importedAt: "2026-02-18T07:28:49.893Z"
---

# 컴파운드 컴포넌트란?
예시 코드부터 보면서 확인해 보겠습니다.
```jsx
import React, { useState, createContext, useContext } from 'react';

// Context 생성
const ToggleContext = createContext();

function Toggle({ children }) {
    const [on, setOn] = useState(false);
    const toggle = () => setOn(!on);

    return (
        <ToggleContext.Provider value={{ on, toggle }}>
            {children}
        </ToggleContext.Provider>
    );
}

function ToggleButton() {
    const { on, toggle } = useContext(ToggleContext);
    return (
        <button onClick={toggle}>
            {on ? 'ON' : 'OFF'}
        </button>
    );
}

function ToggleStatus() {
    const { on } = useContext(ToggleContext);
    return <div>The button is {on ? 'ON' : 'OFF'}</div>;
}

Toggle.Button = ToggleButton;
Toggle.Status = ToggleStatus;

// 메인 컴포넌트에서 사용
function App() {
    return (
        <Toggle>
            <Toggle.Button />
            <Toggle.Status />
        </Toggle>
    );
}
```
`컴파운드 컴포넌트 패턴`은 React에서 상태와 관련 로직을 공유하면서 자식 컴포넌트들에게 유연성을 제공하는 방법입니다. 이 패턴을 사용하면 각 자식 컴포넌트가 부모 컴포넌트의 상태를 직접적으로 액세스하고 조작할 수 있습니다. `컴파운드 컴포넌트 패턴`은 부모-자식 컴포넌트 간의 **명시적이고 타이트한 연결**을 통해, **각 컴포넌트가 독립적으로 기능**할 수 있게 해 주면서도 여전히 **공통 상태를 공유**할 수 있게 합니다.

하나의 큰 컴포넌트를 이루는 아토믹한 컴포넌트들과 그 컴포넌트가 공유하는 상태를 `ContextAPI`를 사용해 결합하는 구조 입니다.

# 적용과 효과
## 적용 배경
아토믹 디자인을 적용하며 최소한의 단위까지 컴포넌트를 분해해 컴포넌트를 설계하고 구성하곤 했습니다. 그런데 이러한 패턴을 적용하다 보니 props 체이닝이 빈번하게 일어나고 상태를 어떻게 관리할지 고민하는데 들어가는 리소스가 늘어나기 시작했습니다.

최근 진행중인 교육 프로그램의 멘토님에게 이를 어떻게 해결하는지에 대해 여쭤봤고, 컴파운드 패턴에 대해서 듣게 되었습니다.

## 적용
https://github.com/gihwan-dev/gihwan-dev-porfolio/pull/49/files#diff-c8d142ddb00d0208a0c3a51a6eede06db05e6d4b6dbb1469afb4a799be1c2f0f
위 링크에서 자세한 코드를 찾아보실 수 있습니다.
### 적용 이전 상태
아래 이미지는 제가 개발하고 있는 웹 사이트의 캐러셀 컴포넌트 입니다.
![](https://velog.velcdn.com/images/koreanthuglife/post/ff566a1d-1c1a-4385-8b06-411064f35e3e/image.png)
각 사각형은 하나의 컴포넌트를 의미하며 파란색 글은 빨간색 선으로 연결된 컴포넌트에 주입되는 props 입니다.

보시면 아시겠지만 (물론 제가 코드를 잘 못짜는 것도 한 몫....) 깊이가 깊은 Props 체이닝이 일어납니다.

### 적용 이후 상태
![](https://velog.velcdn.com/images/koreanthuglife/post/ee619640-5b1e-4e36-827f-c7f07fee94c2/image.png)
보시는 것처럼 깊이가 유사해 보일 순 있으나 루트 페이지에서 문서의 리스트를 받아오기 때문에 그럴 뿐입니다. 직접적으로 DB에 접근해 문서의 리스트를 받아오므로 이전의 방식보다 효율적일 뿐 만 아니라 모든 상태가 Context를 통해 공유되기 때문에 상태 의존의 그래프가 더욱 명확합니다.

# 결론
평소 이런 상태 관리에 대한 고민을 많이 했었고 검색을 통해 다음과 같은 해결책을 찾았습니다.
- 서버 컴포넌트를 이용해 필요한 데이터를 그때 그때 받아온다.
	=> 리액트 서버 컴포넌트는 서버에서 실행되므로 데이터베이스에 직접 접근해 데이터를 받아올 수 있습니다.
- GraphQL + Relay를 이용한다.
=> 필요한 만큼의 데이터를 요청해서 응답받아 해결하는 방법 입니다.

그러나 GraphQL의 학습 비용 보단 컴파운드 컴포넌트를 학습하는 비용이 더 저렴할거라 생각했고 공부해서 적용해 보았습니다.

컴파운드 컴포넌트의 각 컴포넌트는 저버사이드로 만들 수 없으며 이를 이용하는 컴포넌트도 클라이언트 컴포넌트여야 합니다. 왜 그런지에 대한 이유는 다음 링크에서 확인할 수 있습니다.
https://github.com/vercel/next.js/issues/44030#issuecomment-1542597082

컴파운드 컴포넌트 패턴이 최고다! 라는 의미는 아니며 이런 방법이 있고 이런 장점이 있더라... 하는 정도로 읽어주시면 감사하겠습니다!
