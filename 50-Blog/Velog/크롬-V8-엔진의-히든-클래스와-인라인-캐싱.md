---
type: blog-post
source: velog
author: "koreanthuglife"
title: "프로토타입, 히든 클래스와 인라인 캐싱"
slug: "크롬-V8-엔진의-히든-클래스와-인라인-캐싱"
velogId: "d9295587-2cd4-44e9-a9e4-cbfa686ef30d"
velogUrl: "https://velog.io/@koreanthuglife/크롬-V8-엔진의-히든-클래스와-인라인-캐싱"
published: "2024-03-15T09:29:46.569Z"
updated: "2026-02-07T16:24:17.771Z"
tags:
  - "JavaScript"
description: "V8 엔진에서는 히든 클래스와 인라인 캐싱을 사용해서 인스턴스 생성과 프로퍼티 할당, 변경, 제거 작업을 최적화 한다.히든 클래스에 대해서 간단하게 알아보자.인스턴스 생성시에 모든 인스턴스는 히든 클래스를 가진다. 히든 클래스는 객체의 프로퍼티에 대한 메모리 오프셋을 "
importedAt: "2026-02-18T07:28:49.893Z"
---

## `_super` 메서드 구현기

JavaScript Deep Dive 도서를 3번정도 회독했다. 그 중에 프로토타입은 따로 정리도 해볼 정도로 읽었고 어느정도 안다고 생각했다. 내 오만이었다. 이번에 과제해결을 위해 공부하며 알아간게 많다고 생각한다. 알게된 지식 중 일부를 정리 해본다.

프로토타입의 동작 방식에 대해서 어느정도 이해하고 있었다. 다만 생소한 메서드들이 있었다.

### `Object.create(prototype, propertiesObject)`:

- 인자로 받은 객체를 새로 생성된 객체의 프로토타입으로 사용하여, 새로운 객체를 반환한다.

![](https://velog.velcdn.com/images/koreanthuglife/post/25a73b91-5fa5-472a-bb06-a4dff1d909bf/image.png)

프로토타입 기반의 생성자 함수에서 상속을 구현할 때 프로토타입을 위임하기 위해서 사용되는 메서드이다.

### `Function.prototype.call(this)`

- `this` 와 그 이외의 인자를 입력받아 전달받은 `this` 와 다른 매개변수들로 함수를 실행시킨다.

프로토타입 기반의 생성자 함수에서 상속된 메서드의 함수 몸체 안에서 부모 메서드를 실행 시키려 할 때 사용한 함수이다.

```jsx
function Worker(health) {
  this._health = health ?? 10;
}

function JuniorEngineer(health, intelligence) {
  this._super(health);
  this._intelligence = intelligence ?? 1;
  if (this._intelligence > 10) {
    this._isBornGenius = true;
  }
}
//- 생성자 함수는 수정하지 마세요

// 여기에 코드를 작성하세요
// TO-DO
Worker.prototype.work = function () {
  this._health--;
};

Worker.prototype.getHealth = function () {
  return this._health;
};

JuniorEngineer.prototype = Object.create(Worker.prototype, {});

JuniorEngineer.prototype._super = function (health) {
-----------------------------------------
  return Worker.call(this, health);
-----------------------------------------
};

JuniorEngineer.prototype.getIntelligence = function () {
  return this._intelligence;
};

JuniorEngineer.prototype.work = function () {
  Worker.prototype.work.call(this);
  // this.__proto__.__proto__.work.call(this);
  this._intelligence++;
};

JuniorEngineer.prototype.isBornGenius = function () {
  return this._isBornGenius ?? false;
};

```

기본적으로 `Function.prototype.call()` 은 `this` 와 그 외의 매개변수들을 넘겨받아 해당 함수를 실행시킨다. 이때 그럼 생성자 함수에 `this` 를 넘겨주면 어떤 일이 일어나게 되는걸까?

`Worker.call(this, health)` 는 `JuniorEngineer` 인스턴스가 생성될 때 생성자 함수에서 실행된다. 이때 실행될 때 `Worker.call(this, health)` 의 `this` 는 `JunioEngineer` 의 인스턴스의 `this` 이다.

따라서 생성되는 `JuniorEngineer` 인스턴스의 `this` 를 가지고 `Worker` 생성자 함수의 몸체가 실행된다. 그렇게 되면 생성된 `JuniorEngineer` 인스턴스에 `Worker` 의 `this._health = health` 가 실행되고 인스턴스는 `_health` 프로퍼티를 프로퍼티로 가지는 즉 프로퍼티의 상속이 일어날 수 있게 되는거다.

![](https://velog.velcdn.com/images/koreanthuglife/post/723036d1-6a4c-4bbb-9cab-1b615b0d3ef7/image.png)


## 히든 클래스와 인라인 캐싱
V8 엔진에서는 히든 클래스와 인라인 캐싱을 사용해서 인스턴스 생성과 프로퍼티 할당, 변경, 제거 작업을 최적화 한다.

히든 클래스에 대해서 간단하게 알아보자.

인스턴스 생성시에 모든 인스턴스는 히든 클래스를 가진다. 히든 클래스는 객체의 프로퍼티에 대한 메모리 오프셋을 가진다. 

좀 더 간단하게 말하면 히든 클래스는 객체의 구조를 기억하게 된다고 생각하면 된다.
![](https://velog.velcdn.com/images/koreanthuglife/post/fc064adf-0b66-4714-b258-36e8620dbbac/image.png)
각 인스턴스들의 프로퍼티들을 생성할 때 동일한 프로퍼티들을 가진다면 프로퍼티들을 상대적으로 동일한 메모리 공간에 생성된다. 

같은 구조를 공유하고 있다면 즉, 해당 구조를 기억하고 있다면 프로퍼티를 할당하거나 변경할 때 메모리에 직접 접근할 수 있도록 해서 최적화를 수행하는 것이다.

그렇다면 메모리에 직접적으로 접근하는게 왜 중요할까?

`EcmaScript` 에 정의된 추상연산 `get` 과 `set` 호출 시 일어나는 일들에 대해서 자세히 보자.

### **Get(O, P) 호출 시 일어나는 일들 <O = 객체, P = 프로퍼티>**
![](https://velog.velcdn.com/images/koreanthuglife/post/f706bf11-222b-4fc4-baf8-81c12cab4714/image.png)

1. **Assert: Type(O) is Object.**
이 단계에서, 연산은 인자 **`O`**가 실제로 객체(Object) 타입인지 확인한다. 이는 보안 체크의 일종으로, 오직 객체에서만 프로퍼티를 조회할 수 있음을 의미한다. 만약 **`O`**가 객체가 아니라면, 연산은 계속 진행되지 않는다.

2. **Assert: IsPropertyKey(P) is true.**
다음으로, 연산은 인자 **`P`**가 유효한 프로퍼티 키(Property Key)인지 확인한다. 프로퍼티 키는 문자열(String) 또는 심볼(Symbol) 타입이 될 수 있다. 이 단계는 **`P`**가 실제로 객체의 프로퍼티로 사용될 수 있는지를 검증한다. 만약 **`P`**가 유효한 프로퍼티 키가 아니라면, 이후 단계로 진행되지 않는다.

3. **Return O.[[Get]](P, O).**
마지막으로, **`O`** 객체의 내부 **`[[Get]]`** 메서드가 호출되어 프로퍼티 **`P`**의 값을 조회한다. 이 내부 메서드는 객체의 프로토타입 체인을 검색하여 해당 프로퍼티가 존재하는지 확인하고, 있다면 그 값을 반환한다. 만약 프로퍼티가 객체에 직접 존재하지 않는 경우, 객체의 프로토타입 체인을 따라가면서 해당 프로퍼티를 찾는다. 프로퍼티가 발견되면 그 값이 반환되고, 그렇지 않으면 **`undefined`**가 반환된다.

### Set(O, P, V, Throw) 호출 시 일어나는 일들 <V = 값,  Throw = boolean flag>

1. **Assert: Type(O) is Object.**
이 단계는 인자 **`O`**가 객체 타입이어야 함을 확인한다. 이는 연산이 객체에만 적용되어야 함을 보장하는 안전 장치입니다. **`O`**가 객체가 아니라면, 사양에 따라 다음 단계로 진행되지 않는다.
2. **Assert: IsPropertyKey(P) is true.**
여기서는 인자 **`P`**가 유효한 프로퍼티 키인지 확인한다. 프로퍼티 키는 문자열이나 심볼일 수 있다. 유효하지 않은 키는 연산을 진행하지 않는다.
3. **Assert: Type(Throw) is Boolean.`Throw`** 인자는 불리언 값이어야 함을 확인한다. 이 값이 참이면, 연산이 실패할 경우 **`TypeError`** 예외를 던진다.
4. **Let success be O.[[Set]](P, V, O).**
이 단계에서는 객체 **`O`**의 내부 **`[[Set]]`** 메서드를 호출하여 프로퍼티 **`P`**에 값 **`V`**를 설정하려고 시도한다. **`success`** 변수는 이 연산의 성공 여부를 나타낸다.
5. **ReturnIfAbrupt(success).**
만약 **`[[Set]]`** 연산이 예외를 발생시켰다면, 이 예외를 즉시 반환한다. 이는 `ECMAScript`에서 사용되는 관용적 표현으로, 연산 중간에 발생한 예외를 처리한다.
6. **If success is false and Throw is true, throw a TypeError exception.**
만약 **`[[Set]]`** 메서드가 실패(**`success`**가 **`false`**)하고 **`Throw`** 플래그가 **`true`**라면, **`TypeError`** 예외를 발생시킨다. 이는 개발자가 읽기 전용 프로퍼티를 변경하려고 시도했거나, 객체가 확장할 수 없는 상태에서 새로운 프로퍼티를 추가하려고 시도하는 경우 발생할 수 있다.
7. **Return success.**
마지막으로, **`success`** 변수의 값을 반환한다. 이는 프로퍼티 설정 연산이 성공적으로 완료되었는지 여부를 나타낸다.

이 동작을 토대로 예시를 들어보자.

```jsx
function Example(x, y) {
	this.x = x;
	this.y = y;
}
const e1 = new Example(1, 2);
```

여기서 `e1.z` 에 접근을 시도했다고 생각해보자. 그러면 다음의 일들이 일어난다.

1. `e1`이 객체인지 확인한다.
2. `z` 가 유요한 프로퍼티 인지 확인한다.
3. `e1`이 `z` 라는 프로퍼티를 가지는지 확인한다. 존재하지 않으므로 프로토타입에서 찾는다.
4. 프로토타입이 `null` 일 때 까지 계속해서 찾다가 끝내 `undefined`를 반환한다.

여기서 확인할 수 있다시피 이는 비효율적이다.

### Hidden Class

말했다싶이 히든 클래스는 어떤 객체의 구조에 대한 정보를 저장하고 있다. 이 히든 클래스는 객체의 프로퍼티에 접근할 때 저장된 구조를 활용해서 메모리에 집적적인 접근이 가능하게 한다. 그렇다면 이러한 일들이 어떻게 이루어 질 수 있는지에 대해서 좀 더 자세히 알아보자.

히든 클래스의 주요한 구조는 다음과 같다.

- **DescriptorArray**: 모든 프로퍼티와 그에대한 정보 리스트를 담고 있다.
- **TransitionArray**: 히든 클래스의 전환 정보를 담고 있는 배열이다.

아직은 이해할 필요가 없다. 다음 예시를 보면서 이해해보자.

객체가 생성되면 모든 객체들은 히든 클래스를 가지게 된다. 객체에 프로퍼티가 추가, 삭제 되면 새로운 히든 클래스가 생성되고 변경이 발생한 객체의 히든 클래스 레퍼런스가 변경된다.

즉, 다음을 가정해 보자.

```jsx
function Example(a, b, c) {
	this.a = a;
	this.b = b;
	this.c = c;
}

const e1 = new Example(1, 2, 3);
const e2 = new Example(1, 2, 3);
```

최초에 `e1` 을 호출하고 어떤 프로퍼티도 할당하지 않았을 때 히든클래스 `H1` 이 생성되고 `e1` 은 `H1` 히든 클래스를 구조로 가지게 된다.
![](https://velog.velcdn.com/images/koreanthuglife/post/109f6fc8-4cf7-4aeb-a135-60dee2769721/image.png)

이제 `e1` 에 프로퍼티 `a` 를 할당해보자.
![](https://velog.velcdn.com/images/koreanthuglife/post/6d1bde78-8ac1-4740-9798-1dafd1eb0e5c/image.png)
다음은 `b`
![](https://velog.velcdn.com/images/koreanthuglife/post/6a546b2b-a549-43fd-b973-f2b888927193/image.png)
`c` 의 동작은 생략한다. 예상 가능할거라 생각한다. 그럼 `e2` 를 생성하게 되면 어떻게 될까?
![](https://velog.velcdn.com/images/koreanthuglife/post/410313eb-80e1-4c5d-a16c-4bea76a32718/image.png)
이런 식으로 구조가 같다면 기존의 생성된 히든 클래스를 공유하게 된다. 이렇게 어떤 객체에 대한 히든 클래스 구조를 계속해서 추적해나가면서 저장한다. 
그리고 객체의 프로퍼티, 메서드 등에 접근할 때 히든클래스에 저장된 구조를 활용해 메모리에 직접적으로 접근해서 연산을 수행하게 된다.

### 활용하기

그럼 이런 동작을 사용해서 최적화 할 수 있는 방법은 어떤게 있을까?

1. 프로퍼티 초기화를 항상 순서대로 진행하는 것. 그렇게 하면 동일한 프로퍼티 리스트를 가지는 히든 클래스를 여러번 만들 지 않을 수 있다.
2. delete 연산을 최소화 하는것.
3. 가능한 모든 프로퍼티를 생성 시점에 할당하고 초기화 하는것 
---

## 참고 자료

[JavaScript Engines Hidden Classes (and Why You Should Keep Them in Mind) | victor felder](https://draft.li/blog/2016/12/22/javascript-engines-hidden-classes/)

[ECMAScript 2015 Language Specification – ECMA-262 6th Edition](https://262.ecma-international.org/6.0/#sec-get-o-p)

[Maps (Hidden Classes) in V8 · V8](https://v8.dev/docs/hidden-classes)

[V8의 히든 클래스 이야기](https://engineering.linecorp.com/ko/blog/v8-hidden-class)
