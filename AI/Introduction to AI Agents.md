> 원문: https://medium.com/@aleixlopez/introduction-to-ai-agents-62a790d0bc22

인공지능(AI)은 우리의 삶과 일하는 방식을 계속해서 변화시키고 있다. 최근 몇 년간 ChatGPT와 같은 대형 언어 모델(LLM)은 인간과 유사한 텍스트를 이해하고 생성하는 능력으로 전 세계의 주목을 받았다. 이들은 언어의 달인으로, 대화를 나누고, 복잡한 질문에 답하며, 심지어 코드를 작성할 수도 있다. 하지만 이들의 뛰어난 언어 능력 이면에는 근본적인 한계가 있다. 바로 진정한 자율성이 없고, 학습된 데이터에만 의존한다는 점다. 여기서 ‘에이전트’라는 개념이 등장다. 에이전트는 LLM의 능력을 확장하여, 다양한 도구를 사용해 관찰하고, 추론하며, 자율적으로 행동할 수 있게 해주는 프로그램이다.

이 글에서는 AI 에이전트의 세계, 그 구조, 핵심 구성 요소, 실제 적용 방법을 다룬다.

LLM의 기본에 대해 간단히 복습하고 싶다면, 이 글을 참고해 봐라.

https://medium.com/@aleixlopez/foundational-large-language-models-945c4e66e62c?source=post_page-----62a790d0bc22---------------------------------------

## 에이전트란 무엇일까?
가장 기본적으로, 생성형 AI 에이전트는 세상을 관찰하고 자신이 사용할 수 있는 도구를 활용해 목표를 달성하려는 애플리케이션이다. 이러한 에이전트는 자율적으로 동작할 수 있으며, 특히 명확한 목표가 주어졌을 때 인간의 개입 없이도 작동할 수 있다.

LLM(대형 언어 모델)은 반응적이며 사용자의 지속적인 프롬프트가 필요하지만, AI 에이전트는 능동적으로 행동한다. LLM은 질문-답변 루프 내에서 입력을 기다렸다가 응답하는 방식으로 작동한다. 뛰어난 능력에도 불구하고, LLM은 명확한 지시 없이는 스스로 행동할 수 없는 수동적인 존재로 남아 있다.

이 점에서 AI 에이전트는 LLM과 차별화된다. LLM이 단순히 응답하는 데 그친다면, AI 에이전트는 이해를 넘어 실제로 행동에 나다. 이들은 스스로 결정을 내릴 뿐만 아니라, 자율적으로 작업을 수행할 수 있다. 예를 들어, LLM이 여행 일정을 함께 고민해줄 수 있다면, AI 에이전트는 한 걸음 더 나아가 항공권을 예약하고, 호텔 가격을 비교하며, 교통편까지 예약하는 일을 별도의 명령 없이도 처리할 수 있다.

## 에이전트 핵심 개념
에이전트의 인지 아키텍처는 세 가지 핵심 구성 요소로 이루어져 있다:
- **모델(Model)**: 에이전트의 중심 의사결정자 역할을 하는 언어 모델(LM)이다. 아무 언어 모델이나 사용할 수 있는 것이 아니라, ReAct, Chain-of-Thought, Tree-of-Thoughts와 같은 명령 기반 추론 및 논리 프레임워크를 따를 수 있어야 한다. 최적의 결과를 위해서는, 선택된 모델이 원하는 애플리케이션에 잘 맞아야 하며, 에이전트가 사용할 도구와 관련된 데이터 형식이나 구조, 맥락에 익숙하도록 훈련되어 있는 것이 이상적이다.
- **도구(Tools)**: 모델의 내부 능력과 외부 세계를 연결해주는 역할을 한다. 도구를 통해 에이전트는 외부 데이터나 서비스와 상호작용할 수 있어, 수행할 수 있는 작업의 범위가 넓어진다. 도구는 확장(Extensions), 함수(Functions), 데이터 저장소(Data Stores) 등 다양한 형태를 가질 수 있다. 예를 들어, 데이터베이스 업데이트, 날씨 정보 가져오기, 이메일 보내기 등이 있다.
- **오케스트레이션 레이어(Orchestration Layer)**: 에이전트가 정보를 처리하고, 추론하며, 다음 행동을 결정하는 방식을 관리하는 계층다. 이 과정은 에이전트가 목표에 도달하거나 멈출 때까지 반복적으로 이루어진다. 이 레이어의 복잡성은 단순한 계산부터 연쇄 논리, 머신러닝 알고리즘까지 다양할 수 있다. 또한, 추론과 계획을 안내하는 프롬프트 엔지니어링과 관련 프레임워크도 포함된다.

![[Pasted image 20250804084640.png]]

## 인지 아키텍쳐: 에이전트 운영 방식
인지 아키텍처는 에이전트의 두뇌 역할을 다. 이 구조는 에이전트가 단순히 정보를 처리하는 것뿐만 아니라, 추론하고, 의사결정을 내리며, 특정 목표에 도달할 때까지 반복적으로 행동을 개선할 수 있게 해준다.

아키텍처의 작동 방식은 다음과 같다:

- **순환적 과정(Cyclical Process)**: 에이전트는 정보를 지속적으로 받아들이고, 내부적으로 추론하며, 그 결과를 바탕으로 다음 행동을 결정하는 순환적인 방식으로 작동한다. 이 과정은 에이전트가 목표를 달성하거나 정해진 종료 지점에 도달할 때까지 계속된다.
- **오케스트레이션 레이어가 핵심 (Orchestration Layer as the Core)**: 모든 인지 아키텍처의 중심에는 오케스트레이션 레이어가 있다. 이 레이어는 에이전트의 메모리, 현재 상태, 추론 과정, 전체 계획을 관리한다.
- **추론 프레임워크 (Reasoning Frameworks)**: 오케스트레이션 레이어는 프롬프트 엔지니어링과 특정 프레임워크를 사용해 추론과 계획을 안내한다. 이러한 프레임워크는 에이전트가 환경과 더 효과적으로 상호작용하고, 작업을 완수하는 데 도움을 준다.

이 글을 작성할 당시 가장 인기 있는 추론 프레임워크는 다음과 같다:

- **Reason & Act (ReAct)**
- **Chain-of-Thought (CoT)**
- **Tree-of-thoughts (ToT)**

에이전트는 위의 어떤 추론 기법도 활용할 수 있다. 기본적으로, 이러한 프레임워크는 언어 모델이 단계별로 사고하도록 유도하여, 주어진 정보를 신중히 고려하고 그에 따라 가장 적절한 행동을 하도록 만든다.

추론 프레임워크(프롬프트 기술)에 대해서 궁금하다면 아래 글을 참고해라:
https://medium.com/@aleixlopez/introduction-to-prompt-engineering-16fb3cbfb031?source=post_page-----62a790d0bc22---------------------------------------

![[Pasted image 20250804085042.png]]

## Tools: 에이전트와 외부 세계 사이의 연결 고리
앞서 살펴본 것처럼, 언어 모델은 정보 처리에는 뛰어나지만 실제 세계와 상호작용할 수 없다는 근본적인 한계가 있다. 도구는 이 중요한 격차를 메워주며, 에이전트가 외부 데이터와 서비스와 상호작용할 수 있게 하여, 모델만으로는 할 수 없는 더 다양한 행동을 가능하게 한다.

에이전트가 사용할 수 있는 주요 도구 유형은 세 가지다: **확장(Extensions), 함수(Functions), 데이터 저장소(Data Stores)**.

### Extensions: 표준화된 API 상호작용
확장(Extensions)은 API와 에이전트 사이의 표준화된 다리 역할을 하여, API의 구현 방식과 상관없이 에이전트가 API를 실행할 수 있게 해준다. 확장은 에이전트가 다양한 API와 쉽게 상호작용할 수 있도록 해주는 미리 만들어진 연결 도구라고 생각하면 된다.

확장이 작동하는 방식:

- 예시를 통해 에이전트에게 API 엔드포인트를 어떻게 사용하는지 가르친다.
- API 엔드포인트를 성공적으로 호출하기 위해 어떤 인자나 파라미터가 필요한지 에이전트에게 알려준다.
- 에이전트는 배운 내용을 바탕으로, 사용자의 요청을 해결하는 데 어떤 확장이 적합한지 결정한다.

![[Pasted image 20250804085335.png]]

### Functions: 클라이언트 사이드 제어
**함수(Functions)는 특정 작업을 수행하도록 설계된 독립적인 코드 모듈**로, 필요에 따라 재사용할 수 있다. 이는 소프트웨어 개발자가 함수를 사용하는 방식과 유사하다. 에이전트의 맥락에서, 모델은 각 함수의 명세에 따라 언제 어떤 함수를 사용할지, 어떤 인자가 필요한지 결정한다. **함수와 확장의 주요 차이점은, 함수는 클라이언트 측에서 실행되고, 확장은 에이전트 측에서 실행된다는 점**이다.

함수가 작동하는 방식:

- AI 에이전트가 사용자의 요청을 처리하고, 특정 함수를 호출해야 한다고 판단한다.
- 모델이 호출할 함수의 이름과 필요한 인자를 생성한다. 예를 들어, 사용자가 “뉴욕의 날씨가 어때?”라고 묻는다면, 에이전트는 다음과 같이 출력할 수 있다:  
    Function: get_weather. Arguments: {“location”: “New York”}
- AI 에이전트는 직접 API를 호출하거나 함수를 실행하지 않는다. 대신, 주변 시스템에 해당 작업(함수와 인자)을 “추천”만 한다.
- 실제로 함수를 호출하거나 API를 실행하는 것은 에이전트가 동작하는 환경(클라이언트 측 애플리케이션)의 역할이다.

함수를 사용하는 이유:

- **단순성**: 에이전트는 인증 토큰 처리, 오류 응답, 네트워킹 등 API 호출의 기술적인 부분을 이해할 필요가 없다.
- **보안**: API 호출을 클라이언트 측에서 처리하면, 민감한 API 키 노출이나 보안 연결 관리 실패 위험이 줄어든다.
- **성능**: 실시간 API 호출을 하지 않으므로, AI 모델은 추론과 의사결정에 집중하고, 실제 외부와의 상호작용은 클라이언트가 담당한다.

![[Pasted image 20250804085648.png]]

### Data Stores: 동적 정보에 대한 접근
데이터 저장소(Data stores)는 언어 모델이 정적인 지식만 가진다는 한계를 극복하기 위해, 더 동적이고 최신 정보를 제공하여 모델의 응답이 항상 관련성을 유지하도록 돕는다. **데이터 저장소는 에이전트가 접근할 수 있는 외부의 업데이트 가능한 정보원**이라고 생각하면 된다.

데이터 저장소의 작동 방식:

- 개발자가 원본 데이터(스프레드시트, PDF 등)를 에이전트에 제공한다.
- 이 데이터는 벡터 임베딩(embedding)으로 변환된다.
- 임베딩은 벡터 데이터베이스에 저장된다.
- 사용자의 쿼리가 동일한 임베딩 모델에 전달되어 쿼리 임베딩이 생성된다.
- 쿼리 임베딩은 매칭 알고리즘을 통해 벡터 데이터베이스의 내용과 비교된다.
- 일치하는 내용이 검색되어 에이전트에 전달된다.
- 에이전트는 사용자 쿼리와 검색된 내용을 바탕으로 응답이나 행동을 결정한다.

![[Pasted image 20250804085826.png]]

## 모델 성능 향상을 위한 목표 학습 접근 방식
목표 지향 학습(targeted learning) 접근법은 AI 에이전트가 다양한 상황에서 어떤 도구나 자원을 사용할지 더 나은 결정을 내릴 수 있도록 훈련하거나 안내하는 데 중점을 둡니다. 이를 위한 여러 가지 방법이 있습니다:

- **인컨텍스트 학습(In-context learning)**: 모델이 추론 시점에 프롬프트, 도구, 몇 가지 예시(few-shot examples)를 활용해 즉석에서 학습한다. 도구를 언제, 어떻게 사용하는지에 대한 예시가 포함된 정교한 프롬프트를 제공함으로써, 모델이 상황을 이해하고 다음 행동을 결정할 수 있다.
- **검색 기반 인컨텍스트 학습(Retrieval-based in-context learning)**: 이 방법은 외부 메모리나 데이터베이스에서 관련 정보, 예시, 도구를 동적으로 검색해 인컨텍스트 학습을 강화한다. 검색된 내용은 추론 시 프롬프트에 포함된다.
- **파인튜닝 기반 학습(Fine-tuning based learning)**: 도구 사용, 의사결정 과정, 추론 단계 등이 라벨링된 특정 데이터셋으로 모델을 추가 학습시키는 방법이다. 이를 통해 모델의 가중치가 업데이트되어, 지식이 모델 자체에 내재화된다. 인컨텍스트 학습이 프롬프트에 의존하는 것과 달리, 파인튜닝은 모델에 영구적인 변화를 만든다.