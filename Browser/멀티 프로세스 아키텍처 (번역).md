[원글](https://www.chromium.org/developers/design-documents/multi-process-architecture/)

이 문서에서는 크로미움의 고수준 아키텍처에 대해 설명한다.

## 문제

완벽하게 안정적이고 멈추지 않는 렌더링 엔진을 만드는 것은 사실상 불가능하다. 마찬가지로, 완벽하게 보안이 보장된 렌더링 엔진을 만드는 것도 거의 불가능한 일이다.

2006년경의 웹 브라우저는 과거의 단일 사용자용 협동 멀티태스킹 운영체제와 비슷한 상황이었다. 이런 운영체제에서는 하나의 프로그램이 오작동하면 전체 시스템이 멈추는 것처럼, 웹 브라우저에서도 문제가 있는 웹 페이지 하나가 브라우저 전체에 영향을 미칠 수 있었다. 렌더링 엔진이나 플러그인에 작은 버그 하나만 있어도 브라우저 전체와 실행 중인 모든 탭이 한꺼번에 종료되는 일이 발생했다.

현대의 운영체제는 각각의 프로그램을 독립된 프로세스로 분리하고 서로 격리시켜서 더 안정적으로 동작한다. 한 프로그램에서 문제가 생겨도 다른 프로그램이나 운영체제 자체에는 영향을 주지 않고, 사용자들 간에도 서로의 데이터에 접근하는 것이 제한되어 있다. 크로미움은 바로 이러한 안정적인 설계 방식을 목표로 하고 있다.

## 아키텍처 요약

크로미움은 여러 개의 프로세스를 사용해 렌더링 엔진이나 다른 구성 요소에서 발생할 수 있는 버그나 오류로부터 전체 프로그램을 보호한다. 마치 아파트의 각 세대가 독립적으로 분리되어 있어 한 집의 문제가 다른 집에 영향을 주지 않는 것과 비슷하다. 각각의 렌더링 엔진 프로세스는 다른 프로세스나 시스템의 다른 부분에 접근하는 것이 제한되어 있다. 이러한 방식은 운영체제가 메모리 보호와 접근 제어를 통해 얻은 이점을 웹 브라우징에도 적용한 것이라고 볼 수 있다.

크로미움에서는 사용자 인터페이스를 실행하고 렌더러와 기타 프로세스를 관리하는 메인 프로세스를 **브라우저 프로세스** 또는 줄여서 **브라우저**라고 부른다. **브라우저**는 마치 건물의 관리사무소 같은 역할을 한다. 한편, 웹 콘텐츠를 처리하는 프로세스들은 **렌더러 프로세스** 또는 **렌더러** 라고 부르는데, 각각의 웹 페이지를 담당하는 독립된 작업자라고 생각하면 된다. 이 렌더러들은 HTML을 해석하고 화면에 배치하는 작업을 위해 오픈소스 레이아웃 엔진인 Blink를 사용한다.

![[Pasted image 20241203100528.png]]

## 렌더러 프로세스 관리하기

각각의 렌더러 프로세스는 `RenderProcess`라는 전역 객체를 가지고 있다. 부모 브라우저 프로세스와 통신을 관리하고 전체적인 상태를 유지하는 역할을 한다.

브라우저 쪽에서는 각 렌더러 프로세스마다 이에 대응하는 `RenderProcessHost`를 두고 있는데, 이는 렌더러를 위한 브라우저 상태와 통신을 관리한다.

- **RenderProcess**: 지점과 본사 사이 통신을 담당하는 매니저
- **RenderProcessHost**: 본사에서 각 지점을 점담하는 관리자

브라우저와 렌더러들은 Mojo라는 새로운 시스템이나 크로미움의 기존 IPC 시스템을 사용해서 서로 소통한다.

## 프레임과 문서 관리하기
웹 페이지에서 메인 페이지 안에 여러개의 작은 창(iframe)이 있는 것을 본 적 있을거다. 크로미움에서는 이런 각각의 프렘이나 문서를 체계적으로 관리해야 한다. 이게 바로 `RenderFrame`과 `RenderFrameHost`의 역할이다.

각각의 렌더러 프로세스는 하나 이상의 `RenderFrame` 객체를 가지고 있다. 이는 마치 한 교실에 여러 개의 학습 공간이 있는 것과 비슷한데, 각 공간에는 콘텐츠를 담고 있는 문서들이 있다. 브라우저 프로세스에서는 이에 대응하는 `RenderFrameHost`가 있어서 각 문서와 관련된 상태를 관리한다. 이는 마치 각 학습 공간을 담당하는 교사가 있는 것과 같다.

각 `RenderFrame`에는 고유한 라우팅 ID가 부여된다. 이는 같은 렌더러 안에서 여러 문서나 프레임을 구별하는데 사용된다. 이 ID는 한 렌더러 안에서만 고유하고 브라우저 전체에서는 중복될 수 있다. 특정 프레임을 정확히 식별하려면 `RenderProcessHost`와 라우팅 ID를 함께 사용해야 한다.

브라우저가 렌더러의 특정 문서와 통신할 때는 이 `RenderFrameHost` 객체들을 통해 이루어진다. 이 객체들은 Mojo나 기존 IPC 시스템을 통해 메시지를 주고받는 방법을 알고 있다.

이처럼 크로미움은 복잡한 웹 페이지의 구조를 체계적으로 관리하여, 각 부분이 서로 독립적으로 잘 작동하면서도 필요할 때 효율적으로 소통할 수 있도록 설계되어 있다.

## 컴포넌트와 인터페이스

- **렌더 프로세스 에서**:
	- `RenderProcess`는 브라우저 프로세스에 있는`RenderProcessHost`와 통신하기 위한 IPC, Mojo 설정을 한다. 렌더 프로세스 마다 하나의 `RenderProcess` 객체를 가진다.
	- `RenderFrame` 객체는 브라우저 프로세스에 있는 `RenderFrameHost`, Blink와 통신한다 (Mojo를 통해). 서브 프레임 또는 탭에 있는 문서 중 하나를 대표한다.
- **브라우저 프로세스에서**:
	- `Browser` 객체는 최 상위 브라우저 창을 대표한다.
	- `RenderProcessHost` 객체는 브라우저 프로세스에서 하나의 `렌더러 <-> 브라우저`의 IPC 연결을 대표한다. 브라우저 프로세스는 각 렌더러 프로세스마다 하나의 `RenderProcessHost`를 가진다.
	- `RenderFrameHost`객체는 `RenderFrame`과의 통신을 캡슐화 한다.
	- `RenderWidgetHost`는 입력을 다루고 `RenderWidget`의 페인팅을 다룬다.

더 자세한 정보는 [[How Chromium displays web pages]]에서 다룬다.

## 렌더러 프로세스 공유하기

일반적으로 각 윈도우, 탭 마다 새로운 프로세스를 생성한다. 브라우저는 새로운 프로세스를 생성하고, 하나의 `RenderFrame` 객체를 생성하도록 지시한다. 페이지 내부에 `iframe`가 여러개 있다면 더 생성될 수 있다.

## 문제 있는 렌더러 발견하기

각 브라우저 프로세스와 연결된 Mojo 또는 IPC 연결은 `process handles`를 지켜본다. 이 핸들이 렌더러 프로세스가 crash 되었다는 신호를 보내면 영향 받은 탭 또는 프레임이 crash에 대해 알림 받는다. 크롬은 "sad tab" 또는 "sad frame" 이미지를 보여줘 유저에게 렌더러가 crash 되었음을 알린다. 페이지는 리로드 버튼 클릭 또는 새로운 네비게이션을 통해 새로 불러와질 수 있다. 이 방식을 통해 새로 불러오게 되면, 크롬은 렌더러 프로세스가 없어지고 새로 만들어 져야 한다는걸 알린다.

## 렌더러 샌드박싱 하기

렌더러들은 분리된 프로세스에서 돌아가고 있음으로, 샌드박싱을 통해 시스템 자원으로의 접근을 제한할 수 있다. 예를 들어, 렌더러가 네트워크에 대한 접근을 크로미움의 네트워크 서비스를 통해서만 할 수 있도록 제한할 수 있다. 마찬가지로 파일에 대한 접근 또는 유저의 디스플레이나 입력에 대해 제하할 수 있다.

## 메모리 절약하기

렌더러들은 각각 독립된 프로세스로 실행되기 때문에, 숨겨진 탭들을 낮은 우선순위로 처리하는 것이 가능해졌다. 윈도우에서는 최소화된 프로그램들의 메모리를 자동으로 "사용 가능한 메모리" 풀로 이동시킨다.

컴퓨터의 메모리가 부족할 때, 윈도우는 사용자가 현재 보고 있는 프로그램의 메모리보다 이런 숨겨진 메모리를 먼저 하드디스크로 옮긴다. 이렇게 하면 사용자가 실제로 사용중인 프로그램들이 더 빠르게 반응할 수 있다. 크로미움은 이 원리를 숨겨진 탭들에도 적용한다.

렌더러 프로세스가 화면에 보이는 탭을 가지고 있지 않을 때, 우리는 그 프로세스의 "작업 세트" 크기를 점진적으로 줄인다. 점진적으로 하는 이유는, 갑자기 메모리를 줄이면 사용자가 최근에 봤던 탭으로 돌아갈 때 성능이 떨어지기 때문이다.

이런 방식의 장점은:
1. 최근에 본 탭은 비교적 빨리 다시 열 수 있다.
2. 오래 보지 않은 탭은 메모리에서 하드디스크로 이동될 가능성이 높다.
3. 컴퓨터에 충분한 메모리가 있다면 이 과정은 전혀 눈에 띄지 않는다.

단일 프로세스 브라우저와 비교했을 때 큰 장점이 있다. 단일 프로세스 브라우저는 모든 탭의 데이터가 메모리에 무작위로 섞여 있어서 사용 중인 데이터와 사용하지 않는 데이터를 깔끔하게 구분하기 어렵다. 결과적으로 메모리와 성능 모두를 낭비하게 된다.
