브라우저 관점에서 입력이란 모든 사용자의 제스처를 의미한다.

제스처 이벤트는 `브라우저 프로세스`가 가장 먼저 인식한다. `브라우저 프로세스`는 어디에서 발생했는지만 알고 있다. 내부의 콘텐츠 처리는 `렌더러 프로세스`가 한다. 그렇기에 `브라우저 프로세스`는 이벤트 유형(touchstart, onclick 등)과 이벤트가 발생한 좌표를 `렌더러 프로세스`로 보낸다. `렌더러 프로세스`는 이벤트 대상을 찾고 해당 대상과 연결된 이벤트 리스너를 실행해 이벤트를 적절히 처리한다.

![[Pasted image 20241128160520.png]]

## 컴포지터는 입력을 받는다

웹 페이지에 이벤트 리스너가 연결되어 있지 않으면 [[컴포지터 스레드는 메인 스레드와 상관없이 새로운 합성 프레임을 만들 수 있다]]. 하지만 연결되어 있다면? 이벤트를 처리해야 하는지 컴포지터 스레드가 어떻게 알 수 있을까?

## 고속 스크롤 불가 영역의 이해

JS 실행은 메인 스레드의 작업이다. 웹 페이지가 합성될 때 스레드는 핸들러가 연결된 영역을 '고속 스크롤 불가 영역'이라고 표시한다. 웹 페이지의 이 영역에서 이벤트가 발생했을 때 컴포지터 스레드가 입력 이벤트를 메인스레드로 보내야 하는지를 이 정보로 확인할 수 있다. 입력 이벤트가 고속 스크롤 불가 영역 밖에서 발생했다면 컴포지터 스레드는 메인 스레드를 기다리지 않고 새 프레임을 합성한다.

## 이벤트 핸들러를 작성할 때 주의한다

웹 개발에서 흔히 이벤트 위임을 처리하기도 한다. 

```js
document.body.addEventListener('touchstart', event => {
	if (event.target === area) {
		event.preventDefault();
	}
});
```

이는 브라우저 관점에서 보면 웹 페이지의 모든 영역이 고속 스크롤 불가 영역으로 표시된다. 앱에서 신경쓰지 않는 부분에 입력이 들어와도 컴포지터 스레드는 입력 이벤트가 들어올 때마다 메인 스레드와 통신해야하고 메인 스레드가 일을 끝내기를 기다려야 한다.

![[Pasted image 20241128161615.png]]

이 문제를 방지하기 위해 `passive: true` 옵션을 전달할 수 있다. 이 옵션은, 여전히 메인 스레드에서 이벤트를 받지만 컴포지터가 메인 스레드의 처리를 기다리지 않고 새 프레임을 만들어도 된다는 힌트를 주는 옵션이다.

```js
document.body.addEventListener('touchstart', event => {  
    if (event.target === area) {
        event.preventDefault()
    }
 }, {passive: true});
```

## 이벤트를 취소할 수 있는지 확인한다.

어떤 박스 영역에서 스크롤 방향을 가로로만 제한하고 싶은 경우를 생각해보자. `passive: true`를 사용해서 스크롤을 부드럽게 할 수 있다. 하지만 스크롤 방향을 제한하기 위해 `preventDefault()` 메서드를 호출하기 전에 이미 수직 스크롤이 시작되었을 수 잇다. `event.cacelabe()` 메서드를 사용하면 수직 스크롤 시작 여부를 확인할 수 있다.

또는 `touch-action`과 같은 CSS 규칙을 사용해 이벤트 핸들러를 아예 안 쓸 수도 있다.

## 이벤트 대상 찾기

컴포지터 스레드가 입력 이벤트를 메인 스레드로 보낼 때 가장 먼저 하는 일은 이벤트 대상을 찾는 히트 테스트다. 이벤트가 발생한 좌표에 무엇이 있는지 확인하기 위해 히트 테스트는 [[페인팅]] 기록의 데이터를 사용한다.

## 메인 스레드로 이벤트를 전송하는 것을 최소화하기

`touchmove` 이벤트 처럼 연속적인 이벤트가 초당 120회씩 메인 스레드로 보내지면 화면이 갱신되는 정도보다 훨씬 많이 히트 테스트를 하거나 JS를 실행할 수 있다.

크롬은 이런 이벤트들을 `requestAnimationFrame()` 메서드 실행 직전까지 전송하지 않고 기다린다.

## 한 프레임 안에서 합쳐진 이벤트를 얻으려면 `getCoalescedEvents()` 메서드를 사용한다

대부분의 웹 앱에서는 이벤트를 합쳐서 처리해도 잘 처리할 수 있다. 하지만 드로잉 앱 같은 것에서 `touchmove` 이벤트의 좌표를 기반으로 경로를 만들어야 할 때에는 사이사이에 경로가 누락돼서 선을 매끄럽게 그리지 못할 수 있다.

![[Pasted image 20241128163513.png]]

```js
window.addEventListener('pointermove', event => {  
    const events = event.getCoalescedEvents();
    for (let event of events) {
        const x = event.pageX;
        const y = event.pageY;
        // draw a line using x and y coordinates.
    }
});
```

