

## 서론: 아키텍처 나침반의 유효성 검증

제시된 `컴포넌트 -> 커스텀 훅 -> 서비스` 모델은 단순히 유효한 접근 방식을 넘어, 모던하고 유지보수 가능한 리액트 애플리케이션을 구축하기 위한 훌륭한 기반입니다. 이 모델은 리액트 생태계에서 발전해 온 관심사 분리(Separation of Concerns)라는 핵심 원칙과 완벽하게 일치합니다. 이는 애플리케이션의 복잡성을 관리하고 코드의 가독성과 테스트 용이성을 높이는 데 있어 매우 효과적인 정신 모델(mental model)입니다.

이 모델을 하나의 '아키텍처 나침반'으로 간주할 수 있습니다. 이 나침반은 올바른 방향을 가리키고 있으며, 본 보고서는 그 주변 지형에 대한 상세한 지도 역할을 할 것입니다. 이 지도는 사용자가 제안한 모델의 각 계층을 해부하고, 더 높은 수준의 과제(고급 상태 관리), 데이터 흐름의 강(data flows), 그리고 앞으로 마주할 새로운 대륙(미래 패러다임)을 탐험하며 아키텍처에 대한 이해를 심화시키는 것을 목표로 합니다.

본 보고서는 다음과 같은 구조로 전개됩니다:

1. 제안된 세 가지 계층(컴포넌트, 서비스, 커스텀 훅)에 대한 심층적인 해부학적 분석
    
2. 고급 상태 관리 및 프로젝트 구조화 패턴을 통해 이 아키텍처를 한 단계 격상시키는 방법 탐구
    
3. 견고한 테스트 전략으로 아키텍처를 강화하고, 리액트의 미래에 대비하는 방법 제시
    

이 여정을 통해, 현재의 아키텍처적 직관을 확신으로 바꾸고, 어떤 규모의 애플리케이션에도 대응할 수 있는 정교하고 확장 가능한 설계 원칙을 확립하게 될 것입니다.

---

## 섹션 1: 모던 컴포넌트 모델의 해부

이 섹션에서는 제안된 세 가지 계층을 분해하여 각 계층의 엄격한 정의, 역사적 맥락, 그리고 모범 사례를 제공합니다. 각 계층의 명확한 경계를 설정하는 것은 전체 아키텍처의 견고성을 결정하는 첫걸음입니다.

### 1.1 컴포넌트 계층: 픽셀에서 시스템으로

컴포넌트의 일차적 역할은 사용자의 정의와 같이 UI를 렌더링하는 것입니다.1 주어진 상태(state)에 대해 UI가

_어떻게 보여야 하는지_를 기술해야 하며, 그 상태가 _어떻게 관리되거나 가져오는지_에 대해서는 책임지지 않는 것이 이상적입니다. 이는 컴포넌트를 선언적이고 재사용 가능하게 만드는 핵심 원칙입니다.

#### 역사적 맥락: 컨테이너/프레젠테이셔널 패턴의 진화

초기 리액트 애플리케이션에서는 댄 아브라모프(Dan Abramov)에 의해 대중화된 "컨테이너/프레젠테이셔널(Container/Presentational)" 또는 "스마트/덤(Smart/Dumb)" 패턴이 널리 사용되었습니다.3 이 패턴의 핵심 아이디어는 "어떻게 작동하는가"에 관심 있는 컴포넌트(컨테이너)와 "어떻게 보이는가"에 관심 있는 컴포넌트(프레젠테이셔널)를 분리하는 것이었습니다. 프레젠테이셔널 컴포넌트는 오직

`props`를 통해 데이터와 콜백을 받아 UI를 렌더링하는 데 집중했고, 컨테이너 컴포넌트는 상태 관리, 데이터 페칭, 비즈니스 로직을 처리하여 프레젠테이셔널 컴포넌트에 필요한 `props`를 전달했습니다.5

이 원칙, 즉 로직과 뷰를 분리하는 원칙은 오늘날에도 여전히 매우 중요합니다. 하지만 별개의 컨테이너 컴포넌트를 통한 _구현 방식_은 리액트 훅(Hooks)의 등장으로 인해 대부분 대체되었습니다.3 훅을 사용하면 클래스 컴포넌트나 별도의 컨테이너 컴포넌트 계층 없이도 함수형 컴포넌트 내에서 상태와 로직을 캡슐화할 수 있게 되었습니다. 댄 아브라모프 자신도 이 패턴이 너무 독단적으로 적용되는 것을 후회하며, 훅이 동일한 관심사 분리를 더 인체공학적인(ergonomic) 방식으로 달성할 수 있게 해준다고 언급했습니다.5

이러한 진화의 관점에서 볼 때, 제시된 `컴포넌트 -> 훅 -> 서비스` 모델은 컨테이너/프레젠테이셔널 패턴의 현대적 계승자로 볼 수 있습니다.

- **컴포넌트 계층**은 과거의 **프레젠테이셔널 컴포넌트**와 유사합니다. 데이터와 콜백을 받아 렌더링에 집중합니다.
    
- **커스텀 훅 계층**은 과거의 **컨테이너 컴포넌트**의 현대적 등가물입니다. 상태 관리와 비즈니스 로직을 캡슐화하여 UI 컴포넌트에 필요한 데이터와 함수를 제공합니다.
    
- **서비스 계층**은 한 걸음 더 나아가, 과거 컨테이너 컴포넌트에 혼재될 수 있었던 순수한 비-리액트 비즈니스 로직을 추출하여 더욱 명확한 분리를 이룹니다.
    

결론적으로, 사용자의 아키텍처적 직관은 리액트 커뮤니티가 수년간의 경험을 통해 발전시켜 온 검증된 패턴의 자연스러운 진화 형태를 따르고 있으며, 이는 해당 접근법의 타당성을 강력하게 뒷받침합니다.

#### UI 계층 구조화: 아토믹 디자인

UI 컴포넌트들을 체계적으로 구성하고 확장 가능한 디자인 시스템을 구축하기 위한 강력한 방법론으로 브래드 프로스트(Brad Frost)가 제안한 **아토믹 디자인(Atomic Design)**이 있습니다.9 이 방법론은 UI를 화학적 계층 구조에 비유하여 다음과 같이 분류합니다.

- **Atoms (원자):** 더 이상 분해할 수 없는 가장 기본적인 빌딩 블록입니다. (예: Button, Input, Label).9
    
- **Molecules (분자):** 기능적인 단위를 형성하기 위해 여러 원자가 결합된 그룹입니다. (예: Input 원자와 Button 원자를 결합한 검색 폼).10
    
- **Organisms (유기체):** 인터페이스의 독립적인 섹션을 구성하는 더 복잡한 컴포넌트 그룹입니다. (예: 로고, 네비게이션 링크, 검색 분자를 결합한 사이트 헤더).11
    
- **Templates (템플릿) & Pages (페이지):** 컴포넌트들을 배치하는 레이아웃 구조와 실제 콘텐츠가 채워진 구체적인 인스턴스입니다.13
    

이 방법론은 리액트의 컴포넌트 기반 특성과 자연스럽게 조화를 이루며, 재사용성을 극대화하고 디자이너와 개발자 간의 공통 언어를 제공합니다.13

아토믹 디자인을 적용할 때 흔히 발생하는 질문은 '상태와 로직은 어느 계층에 위치해야 하는가?'입니다. 이에 대한 명확한 지침이 존재합니다. 일반적으로 **원자(Atoms)와 분자(Molecules)는 상태가 없는(stateless) 순수한 프레젠테이셔널 컴포넌트**로 유지되어야 합니다. 이들은 모든 데이터와 콜백을 `props`를 통해 전달받으며, 만약 상태를 갖는다면 이는 호버(hover) 상태와 같은 순수한 UI 상태에 국한되어야 합니다.10 반면,

**유기체(Organisms)는 복잡한 상태 관리와 비즈니스 로직이 도입되기 시작하는 첫 번째 계층**입니다. 이 계층의 컴포넌트들은 종종 커스텀 훅을 사용하여 상태를 관리하고 비즈니스 로직과 상호작용합니다.10

이는 명확한 아키텍처 원칙을 제시합니다. 즉, 아토믹 계층 구조를 따라 단순한 컴포넌트에서 복잡한 컴포넌트로 이동함에 따라, 컴포넌트의 역할은 순수하게 표현적인 것에서 커스텀 훅이 제공하는 상태 기반 로직의 소비자로 전환됩니다. 이로써 제안된 `컴포넌트-훅-서비스` 모델이 체계적인 컴포넌트 설계 방법론과 완벽하게 통합됩니다.

### 1.2 서비스 계층: 순수 로직의 영역

서비스 계층은 사용자의 정의대로 순수하고 프레임워크에 구애받지 않는 자바스크립트/타입스크립트 함수들의 집합입니다.16 이 계층은 리액트, 상태, 훅에 대해 전혀 알지 못해야 합니다. 이곳이 바로 애플리케이션의 "비즈니스 도메인"입니다.

#### 주요 특징 및 이점

- **순수성 및 테스트 용이성:** 서비스 계층의 함수들은 결정론적(deterministic)이며 부수 효과(side effects)가 없는 순수 함수로 구성되는 것이 이상적입니다. 이는 리액트 런타임 환경 없이도 Jest와 같은 도구를 사용하여 단위 테스트를 매우 쉽게 작성할 수 있게 해줍니다.19 이를 통해 비즈니스 로직을 격리하여 견고하게 검증할 수 있습니다.
    
- **재사용성:** 서비스 로직은 리액트 컴포넌트 외부(예: 웹 워커)를 포함한 애플리케이션의 모든 곳에서 사용될 수 있으며, 다른 프로젝트나 심지어 다른 프레임워크로도 이식 가능합니다.21
    
- **관심사 분리:** 이 계층은 _애플리케이션이 무엇을 하는가_(비즈니스 규칙, 데이터 변환, 계산)와 _UI가 그것에 어떻게 반응하는가_(상태 업데이트, 리렌더링)를 명확하게 분리합니다.16
    

#### 서비스 로직의 예시

- 복잡한 데이터 변환 (예: API 응답을 뷰 모델(view model)로 매핑)
    
- 유효성 검사 로직 (예: 폼 제출이 비즈니스 기준을 충족하는지 확인)
    
- 비즈니스 계산 (예: 할인 및 세금을 포함한 총 가격 계산)
    
- API 상호작용 모듈 (예: `axios`나 `fetch` 호출을 캡슐화하고 헤더, 기본 URL 등을 처리하는 `apiService`) 16
    

### 1.3 커스텀 훅: 반응성의 심장

커스텀 훅은 다른 훅을 호출할 수 있는 `use`로 시작하는 자바스크립트 함수입니다.25 이것이 바로 상태가 없고 순수한 서비스의 세계와 상태 기반의 반응적인 컴포넌트 세계를 연결하는 중요한 다리입니다.

#### 훅의 규칙

훅은 일반 함수와 다르다는 점을 강조해야 합니다. 훅은 리액트의 마법을 가능하게 하는 두 가지 중요한 규칙의 지배를 받습니다.28

1. **최상위 레벨에서만 훅을 호출해야 합니다:** 반복문, 조건문, 또는 중첩된 함수 내에서 훅을 호출해서는 안 됩니다. 이 규칙을 통해 훅은 매 렌더링마다 동일한 순서로 호출되며, 리액트는 이를 통해 여러 훅 호출 사이에서 상태를 올바르게 보존할 수 있습니다.28
    
2. **리액트 함수 내에서만 훅을 호출해야 합니다:** 리액트 컴포넌트나 다른 커스텀 훅 내에서만 호출할 수 있습니다.26
    

#### 이 아키텍처에서 훅의 핵심 책임

- **상태 관리:** 로직과 관련된 상태를 보유합니다. (예: 로딩/에러/데이터 상태를 위한 `useState`, 복잡한 상태 전환을 위한 `useReducer`).25
    
- **부수 효과 관리:** 데이터 페칭이나 구독과 같은 부수 효과를 `useEffect`를 사용하여 처리합니다.26
    
- **오케스트레이션:** 로직의 흐름을 조율합니다. 예를 들어, 컴포넌트의 이벤트 핸들러가 훅이 반환한 함수를 호출하면, 이 함수는 로딩 상태를 설정하고, `서비스` 계층의 메서드를 호출한 다음, 결과나 에러로 상태를 업데이트하는 일련의 과정을 지휘합니다.31
    

`use` 접두사 뒤에 숨겨진 깊은 의미를 이해하는 것은 중요합니다. 이 접두사는 단순한 명명 규칙을 넘어 하나의 '계약'입니다.26 첫째, 개발자에게 이 함수가 훅의 규칙을 따른다는 신호를 보냅니다.

`useSomething()`을 보는 순간, 이 함수가 상태를 포함할 수 있으며 규칙에 따라 사용해야 함을 즉시 인지할 수 있습니다. 둘째, 리액트 린터(`eslint-plugin-react-hooks`)와 같은 도구에게 이 규칙을 정적으로 강제하도록 지시하여 버그를 사전에 방지하는 역할을 합니다.26 따라서 이 명명 규칙은 단순히 스타일적인 선택이 아니라, 전체 반응형 시스템의 무결성과 예측 가능성을 유지하는 데 필수적인 기능입니다.

#### 표 1: 아키텍처 계층별 책임 및 핵심 기술

|계층|주요 책임|주요 특징|핵심 기술/API|
|---|---|---|---|
|**컴포넌트 계층**|UI 렌더링, 사용자 상호작용 표현|선언적, `props`를 통해 데이터 수신|JSX, `React.memo`|
|**커스텀 훅 계층**|상태 및 부수 효과 관리, UI와 로직 연결|반응형, 리액트 생명주기에 의존|`useState`, `useEffect`, `useCallback`, `useReducer`|
|**서비스 계층**|순수 비즈니스 로직 캡슐화|프레임워크 비종속적, 높은 테스트 용이성|순수 JS/TS 함수, `axios`/`fetch` 래퍼|

---

## 섹션 2: 아키텍처의 격상: 상태, 데이터, 그리고 확장성

이 섹션은 앞서 정의한 기본 모델을 바탕으로, 모던 애플리케이션에서 흔히 발생하는 복잡한 문제들을 해결하기 위한 전문화된 도구와 패턴을 소개합니다.

### 2.1 서버 상태 마스터하기: `useEffect`를 넘어서

데이터 페칭에 `useEffect`를 사용할 수는 있지만, 이는 저수준의 원시적인(primitive) 기능입니다. 이를 직접 사용하면 상당한 양의 보일러플레이트 코드가 발생하고 다음과 같은 일반적인 함정에 빠지기 쉽습니다.33

- 데이터를 가져오는 모든 컴포넌트에서 로딩, 데이터, 에러 상태를 수동으로 관리해야 합니다.
    
- 내장된 캐싱 기능이 없어 불필요한 네트워크 요청이 반복됩니다.
    
- 창 포커스나 네트워크 재연결 시 자동으로 데이터를 다시 가져오는 기능이 없습니다.
    
- 경쟁 조건(race conditions)을 처리하기 복잡합니다.
    

이러한 문제들을 해결하기 위해 등장한 것이 **React Query (현 TanStack Query)**와 **SWR** 같은 서버 상태 라이브러리입니다. 이들은 일반적인 상태 관리 도구가 아니라, _서버 캐시_ 관리에 특화된 라이브러리입니다.33 위에서 언급된 모든 문제들을 별도의 설정 없이 즉시 해결해 줍니다.38

#### 명확한 모범 사례: 커스텀 훅으로 React Query 감싸기

가장 효과적인 패턴은 `useQuery`를 컴포넌트에서 직접 사용하는 것이 아니라, `useProducts`, `useUser`와 같이 도메인 특화된 커스텀 훅 내부에 캡슐화하는 것입니다.36 이 패턴은 제시된 아키텍처와 완벽하게 부합합니다.

`서비스` 계층이 `api.getProducts`와 같은 페칭 함수를 정의하면, `커스텀 훅`(`useProducts`)이 `useQuery` 내에서 해당 서비스 함수를 호출하여 모든 서버 상태 관련 문제를 처리하는 구조입니다.

JavaScript

```
// services/productService.js
import axios from 'axios';

export const getProducts = async () => {
  const { data } = await axios.get('/api/products');
  return data;
};

// hooks/useProducts.js
import { useQuery } from '@tanstack/react-query';
import { getProducts } from '../services/productService';

export const useProducts = () => {
  // useQuery는 queryKey와 queryFn을 인자로 받습니다.
  // queryKey는 이 쿼리 데이터를 캐싱하고 관리하기 위한 고유 식별자입니다.
  // queryFn은 데이터를 반환하는 프로미스를 반환하는 함수입니다.
  return useQuery({ queryKey: ['products'], queryFn: getProducts });
};

// components/ProductList.jsx
import { useProducts } from '../hooks/useProducts';

function ProductList() {
  // useProducts 훅을 통해 데이터, 로딩 상태, 에러 상태를 간결하게 얻습니다.
  const { data, isLoading, error } = useProducts();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>An error has occurred: {error.message}</div>;

  return (
    <ul>
      {data.map(product => (
        <li key={product.id}>{product.name}</li>
      ))}
    </ul>
  );
}
```

이 접근 방식은 "비즈니스 로직"의 경계에 대한 더 깊은 이해를 요구합니다. 사용자는 현재 "비즈니스 로직"을 `서비스` 계층에 위치시킨다고 정의했습니다. 하지만 React Query는 캐싱, 데이터 유효 시간(stale time), 재요청 간격 등과 관련된 로직을 도입합니다.37 이것은 순수한 비즈니스 규칙(예: 세금 계산 방법)과는 다른 성격의 로직입니다. 이는 애플리케이션의 생명주기 내에서 데이터가

_어떻게 그리고 언제_ 관리되어야 하는지에 관한 "애플리케이션 로직" 또는 "데이터 흐름 로직"으로 더 정확하게 설명될 수 있습니다. 따라서 다음과 같이 경계를 재정의할 수 있습니다.

- **서비스 계층:** 순수한 **도메인 로직**(비즈니스가 무엇을 하는가)을 담습니다.
    
- **커스텀 훅 계층:** **애플리케이션/UI 로직**(UI가 어떻게 동작하고 서버 캐시를 포함한 상태를 어떻게 관리하는가)을 담습니다.
    

이러한 세분화된 구분은 애플리케이션의 복잡성이 증가함에 따라 명확한 경계를 유지하는 데 매우 중요한 역할을 합니다.

#### 표 2: 데이터 페칭 전략 비교

|기능|`useEffect` 기반 커스텀 훅|React Query 기반 커스텀 훅|
|---|---|---|
|**캐싱**|수동 구현 필요|자동, 설정 가능|
|**자동 재검증**|없음 (수동 구현 필요)|창 포커스, 네트워크 재연결 시 자동 실행|
|**에러 처리**|`try-catch` 및 상태 관리 필요|내장된 에러 상태 및 재시도 옵션|
|**로딩 상태 관리**|`useState`로 수동 관리|내장된 `isLoading`, `isFetching` 상태|
|**코드 복잡성**|높음 (보일러플레이트 많음)|낮음 (선언적 API)|

### 2.2 클라이언트 상태 다루기: 솔루션의 스펙트럼

서버 상태와 클라이언트 상태를 명확히 구분하는 것이 중요합니다. 서버 상태는 서버에 존재하는 데이터의 로컬 복사본이며, 클라이언트 상태는 브라우저 내에서만 존재하는 UI 관련 상태입니다 (예: 폼 입력 값, 테마 선택, 모달 열림 여부).33

클라이언트 상태를 관리하기 위한 도구는 그 범위에 따라 다양하며, 적절한 도구를 선택하는 것이 중요합니다.

- **로컬 상태 (`useState`, `useReducer`):** 기본 선택지입니다. 상태가 단일 컴포넌트나 작고 인접한 컴포넌트 그룹에서만 필요할 때 사용합니다.
    
- **공유 상태 (Context API):** "prop drilling" 없이 컴포넌트 트리 깊숙이 상태를 전달하는 데 이상적입니다.45 테마나 사용자 인증 상태와 같이 업데이트 빈도가 낮은 데이터에 가장 적합합니다. 업데이트 시 모든 소비자가 리렌더링되므로, 빈번한 업데이트에는 성능 문제가 발생할 수 있습니다.45
    
- **전역 상태 (Zustand, Redux Toolkit):** 애플리케이션의 여러 분리된 부분에서 빈번하게 업데이트되는 복잡한 전역 상태에 사용됩니다.45
    
    - **Zustand:** 가볍고 현대적인 훅 기반 솔루션으로, 보일러플레이트가 거의 없습니다. Context API로 부족할 때 훌륭한 기본 선택지가 될 수 있습니다.45
        
    - **Redux Toolkit:** 대규모의 복잡한 애플리케이션을 위한 산업 표준입니다. 강력한 개발 도구(시간 여행 디버깅 등)와 엄격하고 예측 가능한 구조를 제공하지만, 더 많은 보일러플레이트와 높은 학습 곡선을 가집니다.46
        

Context API는 단순한 상태 공유 도구를 넘어, 정교한 아키텍처 패턴인 **의존성 주입(Dependency Injection)** 메커니즘으로 활용될 수 있습니다.47 예를 들어, 부모 컴포넌트 내에서 Zustand 스토어의 인스턴스를 생성하고, 이

_인스턴스_를 Context를 통해 자식들에게 제공할 수 있습니다. 이 패턴을 사용하면 동일한 페이지에 상태가 격리된 여러 개의 상태 모듈 인스턴스를 가질 수 있으며, 이는 전역 싱글톤 스토어로는 불가능한 구조입니다.50 이는 Context에 대한 이해를 단순한 상태 공유 도구에서 모듈화되고 재사용 가능한 상태 기반 하위 시스템을 만드는 강력한 아키텍처 패턴으로 격상시킵니다.

#### 표 3: 클라이언트 상태 관리 결정 매트릭스

|도구|최적 사용 사례 (범위)|업데이트 빈도|주요 트레이드오프|
|---|---|---|---|
|**`useState`/`useReducer`**|단일 컴포넌트 (로컬)|모든 빈도|가장 단순하고 직관적임|
|**Context API**|중첩된 트리 (공유)|낮음|성능: 모든 소비자가 리렌더링됨|
|**Zustand**|앱 전반 (전역)|중간 ~ 높음|가볍고 유연하나, 팀 내 패턴 합의 필요|
|**Redux Toolkit**|대규모 앱 (전역)|높음|강력한 도구와 구조, 높은 보일러플레이트|

### 2.3 성장을 위한 구조화: 기능 주도 설계

일반적으로 사용되는 `src/components`, `src/hooks`, `src/services`와 같은 파일 유형별 폴더 구조는 애플리케이션이 성장함에 따라 한계를 드러냅니다. 각 폴더가 비대해지고, 관련된 파일을 찾기 어려워지며, 기능의 경계가 모호해집니다.51

이에 대한 해결책은 **기능 기반(Feature-Based)** 또는 **수직 분할(Vertical Slicing)** 아키텍처입니다. 이는 코드베이스를 파일 유형이 아닌 기능이나 도메인별로 구성하는 방식입니다.51

```
src/
├── features/
│   ├── products/
│   │   ├── components/       (ProductCard, ProductList)
│   │   ├── hooks/            (useProducts, useProductDetails)
│   │   ├── services/         (productService.js)
│   │   └── index.js          (해당 기능의 공개 API)
│   └── cart/
│       ├── components/
│       ├── hooks/
│       ├── services/
│       └── index.js
├── lib/ or shared/           (진정으로 일반적인 컴포넌트, 훅, 유틸리티)
└──...
```

이 구조는 높은 응집도(관련 파일이 함께 위치)와 낮은 결합도(기능이 독립적)를 가지며, 개발자 경험을 향상시키고 코드 소유권을 명확히 합니다.51

이러한 관심사 분리 원칙은 컴포넌트 수준에서 조직 및 배포 수준까지 확장될 수 있습니다. 단일 애플리케이션("모놀리스") 내에서 기능 기반 아키텍처를 적용하는 것을 넘어, 여러 관련 프론트엔드 애플리케이션을 관리하거나 팀이 기능을 완전히 독립적으로 개발하고 배포해야 할 때 **모노레포(Monorepo)**와 **마이크로 프론트엔드(Micro-Frontends)**라는 다음 단계의 아키텍처를 고려할 수 있습니다.54

- **모노레포:** 여러 프로젝트나 패키지를 하나의 저장소에서 중앙 관리하여 의존성 관리와 코드 공유를 단순화합니다. 기능 기반 구조의 `shared` 폴더는 모노레포의 공유 패키지가 될 수 있습니다.
    
- **마이크로 프론트엔드:** 여기서 더 나아가, 각 기능("마이크로 앱")을 독립적으로 개발하고 배포한 후, 하나의 응집된 애플리케이션으로 조합할 수 있게 합니다.
    

이는 컴포넌트 수준에서 적용된 관심사 분리 원칙이 애플리케이션 전체, 나아가 조직 전체의 스케일로 일관되게 적용될 수 있음을 보여주는 중요한 통찰입니다.

---

## 섹션 3: 강화 및 미래 대비

마지막 섹션에서는 아키텍처가 견고하고 테스트 가능하며, 리액트 생태계의 미래 변화에 대비할 수 있도록 하는 전략을 다룹니다.

### 3.1 테스트 가능한 스택: 다층적 검증 전략

잘 설계된 아키텍처는 테스트하기 쉬운 아키텍처입니다. `컴포넌트-훅-서비스` 모델은 각 계층을 격리하여 테스트할 수 있는 명확한 경계를 제공합니다.

- **서비스 테스트:** **Jest**를 사용하여 순수 서비스 함수를 단위 테스트합니다. 이들은 일반 자바스크립트이므로 테스트가 간단합니다. `axios`와 같은 외부 의존성은 모킹(mocking)하여 서비스의 로직 자체를 격리하여 테스트합니다.19
    
- **커스텀 훅 테스트:** **React Testing Library**의 `renderHook` 유틸리티를 사용합니다.56 이를 통해 컴포넌트 없이 훅을 렌더링하고 반환 값을 검증할 수 있습니다. 훅 내에서 상태 변경을 유발하는 이벤트를 시뮬레이션하기 위해
    
    `act` 유틸리티를 사용합니다.56
    
- **컴포넌트 테스트:** **React Testing Library**를 사용하여 사용자 관점에서 컴포넌트를 테스트합니다. 컴포넌트를 렌더링하고, 상호작용(`fireEvent`, `userEvent`)한 후, DOM이 예상된 상태를 반영하는지 검증합니다. 컴포넌트의 내부 훅 구현은 세부 사항일 뿐, 우리는 그 동작을 테스트합니다.59
    
- **통합 및 E2E 테스트:** 전체 흐름(컴포넌트 -> 훅 -> 서비스 -> API)을 테스트하기 위해 **Mock Service Worker (MSW)**를 사용합니다. MSW는 네트워크 레벨에서 실제 네트워크 요청을 가로채 모의 응답을 제공합니다. 이를 통해 실제 백엔드 없이도 전체 스택을 높은 신뢰도로 테스트할 수 있습니다.61
    

이러한 다층적 테스트 전략은 "테스팅 피라미드" 개념과 자연스럽게 연결됩니다. `서비스` 계층은 피라미드의 넓은 기반을 형성하며, 수많은 빠르고 간단한 Jest 단위 테스트로 구성됩니다. `커스텀 훅` 계층은 중간 부분을 차지하며, `renderHook`을 사용한 테스트는 리액트 런타임을 포함하므로 약간 더 복잡합니다. `컴포넌트` 계층 및 MSW를 사용한 통합 테스트는 피라미드의 최상단에 위치하며, 수는 적지만 모든 부분이 함께 올바르게 작동하는지 보장하는 포괄적인 테스트입니다. 이처럼 좋은 관심사 분리는 코드를 깔끔하게 만들 뿐만 아니라, 효과적이고 효율적인 테스트 전략을 자연스럽게 가능하게 합니다.

### 3.2 다음 패러다임: 리액트 서버 컴포넌트 (RSC)

리액트 서버 컴포넌트(RSC)는 리액트 패러다임의 근본적인 변화입니다. 이들은 서버에서만, 사전에 실행되는 새로운 유형의 컴포넌트입니다.62 데이터베이스나 파일 시스템과 같은 서버 측 리소스에 직접 접근할 수 있습니다.

#### 데이터 페칭에 미치는 영향

RSC를 사용하면 `async/await`를 사용하여 컴포넌트 내에서 직접 데이터를 가져올 수 있습니다. 초기 데이터 로드를 위해 `useEffect`, 로딩/에러를 위한 `useState`, 심지어 React Query와 같은 클라이언트 측 페칭 라이브러리도 필요하지 않게 됩니다.62 이는 데이터 흐름을 극적으로 단순화하고, 초기 페이지 로드 시 발생하는 클라이언트-서버 요청 폭포(waterfall) 현상을 제거합니다.63

JavaScript

```
// app/products/[id]/page.js
// 이것은 서버 컴포넌트입니다. 데이터 페칭을 위해 훅이 필요 없습니다.
import { db } from '@/lib/db';

async function ProductPage({ params }) {
  // 데이터베이스에 직접 접근하여 데이터를 가져옵니다.
  const product = await db.products.findUnique({ where: { id: params.id } });

  // 로딩이나 에러 상태를 직접 관리할 필요가 없습니다.
  // React가 프로미스가 해결될 때까지 렌더링을 일시 중단합니다.
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
    </div>
  );
}

export default ProductPage;
```

#### RSC가 기존 모델에 미치는 영향과 미래의 하이브리드 모델

얼핏 보면 RSC가 `컴포넌트-훅-서비스` 모델을 완전히 무효화하는 것처럼 보일 수 있습니다. 그러나 이는 단순한 해석입니다. RSC는 상태나 효과(`useState`, `useEffect`)를 사용할 수 없기 때문에 상호작용이 불가능합니다. 상호작용이 필요한 부분은 `"use client"` 지시어를 사용하여 **클라이언트 컴포넌트(Client Components)**로 만들어야 합니다.62

클라이언트 컴포넌트는 오늘날의 리액트와 정확히 동일하게 작동합니다. 따라서, 사용자가 제안한 `컴포넌트 -> 훅 -> 서비스` 아키텍처는 _상호작용이 가능한 클라이언트 측 경험을 구축하기 위한 핵심 패턴_으로 그 자리를 굳건히 지킵니다.

미래의 아키텍처는 **하이브리드(hybrid)** 모델이 될 것입니다. 초기 데이터 페칭과 정적 렌더링에는 RSC를 사용하고, 버튼 클릭이나 폼 입력과 같은 상호작용이 필요할 때는 클라이언트 컴포넌트를 사용하게 됩니다. 그리고 이 클라이언트 컴포넌트는 클라이언트 측 로직과 상태 변경(mutations)을 처리하기 위해 견고한 `훅 -> 서비스` 패턴을 활용할 것입니다.

결론적으로, 사용자의 모델은 대체되는 것이 아니라, 모던 하이브리드 리액트 애플리케이션의 _클라이언트 측, 상호작용 부분_을 위한 패턴으로 그 역할이 더욱 명확하게 정의되고 있습니다.

---

## 결론: 아키텍처 우수성을 위한 실행 가능한 청사진

본 보고서는 `컴포넌트 -> 훅 -> 서비스`라는 아키텍처 모델이 현대적인 리액트 개발의 강력하고 올바른 기반임을 확인했습니다. 이 모델은 관심사 분리라는 핵심 원칙을 효과적으로 구현하며, 리액트의 역사적 패턴에서 자연스럽게 진화한 형태입니다.

핵심 원칙을 요약하면 다음과 같습니다.

- **견고한 기반:** 제시된 모델은 훌륭한 출발점입니다. 각 계층의 경계를 명확히 하고 그 역할을 충실히 지키는 것이 중요합니다.
    
- **도구의 전문화:** 서버 상태와 클라이언트 상태를 구분하고, 각 목적에 맞는 전문화된 도구(React Query, Zustand 등)를 도입하여 아키텍처를 격상시켜야 합니다.
    
- **확장성을 위한 구조:** 애플리케이션의 성장에 따라 파일 유형이 아닌 기능 중심으로 프로젝트 구조를 재편하여 유지보수성을 확보해야 합니다.
    
- **품질 보증:** 다층적 테스트 전략을 통해 각 계층을 검증하고 전체 시스템의 안정성을 보장해야 합니다.
    
- **미래 지향성:** 리액트 서버 컴포넌트의 등장은 기존 모델을 대체하는 것이 아니라, 상호작용이 필요한 클라이언트 측 아키텍처로서의 역할을 더욱 공고히 합니다.
    

아키텍처는 진화하는 과정이며, 정답은 하나가 아닙니다. 하지만 사려 깊은 접근 방식과 명확한 원칙을 갖는 것이 가장 중요합니다. 다음은 이 보고서에서 논의된 개념들을 통합하여 애플리케이션을 점진적으로 발전시킬 수 있는 실행 경로입니다.

1. **즉각적인 개선:** 기존 계층 간의 경계를 강화하십시오. 서비스 계층의 함수들이 순수성을 유지하도록 하고, 훅의 규칙을 엄격하게 준수하십시오.
    
2. **현대화:** 모든 서버 상태 관리에 React Query(또는 SWR)를 도입하고, 이를 도메인 특화 커스텀 훅으로 캡슐화하십시오. 본문에서 제공된 결정 매트릭스를 기반으로 작업에 적합한 클라이언트 상태 관리 도구를 선택하십시오.
    
3. **확장:** 프로젝트를 기능 기반 구조로 리팩토링하여 장기적인 확장성과 유지보수성을 준비하십시오.
    
4. **미래 탐색:** Next.js와 리액트 서버 컴포넌트를 사용하여 실험적인 프로젝트를 시작해보고, 새롭게 부상하는 하이브리드 패러다임을 직접 경험해보십시오.
    

이러한 고급 개념들을 통합함으로써, 단순히 기능적인 애플리케이션을 넘어 견고하고 확장 가능하며 유지보수가 즐거운 애플리케이션을 구축할 수 있는 역량을 갖추게 될 것입니다.
