> 참고 자료:
> https://evan-moon.github.io/2025/09/07/declarative-programming-misconceptions-and-essence/
> https://gemini.google.com/app/3e820ab72713afef?hl=ko

- 특정한 도구를 사용하거나 문법을 사용하는 것이 선언적인 것이 아님
- 사고방식의 근본적 전환임
- 절차적인 동작을 함수로 추상화하면 선언적이라는 착각을 많이들 가짐

```typescript
function getUserInfo(userId) {
  const connection = connectDB();
  const userRow = connection.query('SELECT * FROM users WHERE id = ?', userId);
  const permissionRows = connection.query('SELECT * FROM permissions WHERE user_id = ?', userId);
  
  const user = {
    id: userRow.id,
    name: userRow.name,
    email: userRow.email,
    permissions: permissionRows.map(row => row.permission_name)
  };
  
  if (user.name) {
    user.displayName = user.name.toUpperCase();
  }
  
  return user;
}
```

- 위 코드는 함수로 추상화 되었지만, DB에서 사용자를 가져오고, 권한을 추가하고, 마지막에 포매팅한다 라는 시간적 순서에 집중하고 있음. 절차적임.

```typescript
const getUserInfo = (userId) => 
  pipe(
    fetchUserFromDB,
    addUserPermissions,
    formatUserData
  )(userId);
  
const getUserInfo = (userId) => 
  formatUserData(
    addUserPermissions(
      fetchUserFromDB(userId)
    )
  );
```

- 위 코드는 시간적 순서에서 벗어나 동작 간의 관계를 기술하고 있음.

- 절차적 코드는 "어떻게 단계별로 실행할 것인가"에 집중하고, 선언적 코드는 "무엇을 원하는 관계인가"에 집중

- `map`을 사용한다고 선언적이지 않음

```typescript
// 배열 메소드를 사용했지만 절차적 사고
function processItems(items) {
  return items
    .map(item => {
      let price = item.basePrice;

      if (item.discount) {
        price = price * (1 - item.discount);
      }

      price = price * 1.1;

      return { ...item, finalPrice: Math.round(price * 100) / 100 };
    })
    .filter(item => item.finalPrice > 0);
}
```

- 위 코드는 절차적임
- 반면 아래 코드는 선언적임

```javascript
// 진정한 선언적 접근
const processItems = (items) =>
  items
    .map(applyDiscount)
    .map(addTax)
    .map(formatPrice)
    .filter(hasValidPrice);

const applyDiscount = (item) => ({
  ...item,
  price: item.basePrice * (1 - (item.discount || 0))
});

const addTax = (item) => ({
  ...item,
  price: item.price * 1.1
});

const formatPrice = (item) => ({
  ...item,
  finalPrice: Math.round(item.price * 100) / 100
});

const hasValidPrice = (item) => item.finalPrice > 0;
```

- 절차적 접근은 레시피와 같음:
	- 물 2컵을 끓인다. 면을 넣고 3분간 끓인다. 스프를 넣고 1분간 더 끓인다. 그릇에 담는다.
- 선언적 접근은 관계를 표현함:
	- 라면 = 삶은 면 + 스프 + 뜨거운 물의 조함
- 절차적 접근은 시간의 흐름에 따른 행동 지침이고, 관계적 선언은 재료들 사이의 본질적 관계를 나타냄

- 선언적 코드는 컴퓨터에게 어떤 일을 할지 주문하는 것이 아니라, 이 문제의 본질은 이런 관계에 있다는 것을 표현함
- 프로그래밍은 계산 과정을 지시하는 것이 아니라 문제 도메인의 수학적 구조를 발견하고 표현하는 행위

- 아래는 절차형의 구체적인 예시
- 순차적 실행 모델임
- 코드의 시간적  순서와 상태 변화에 집중함

```javascript
// 절차적 프로그래밍 - 어떻게(How) 할 것인가에 집중
function calculateTotalPrice(items) {
  let total = 0;
  
  // 단계 1: 각 아이템을 순회
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    
    // 단계 2: 유효성 검사
    if (item.quantity > 0) {
      // 단계 3: 기본 가격 계산
      let itemPrice = item.price * item.quantity;
      
      // 단계 4: 할인 적용
      if (item.discount) {
        itemPrice = itemPrice - (itemPrice * item.discount);
      }
      
      // 단계 5: 총합에 누적
      total = total + itemPrice;
    }
  }
  
  return total;
}
```

- 선언적 사고는 시간을 초월한 논리적 관계에 집중함
- "총 가격 = 유효한 아이템들의 할인된 가격들의 합" 이라는 관계를 선언

```javascript
// 선언적 프로그래밍 - 무엇을(What) 원하는가에 집중
const calculateTotalPrice = (items) =>
  items
    .filter(hasValidQuantity)
    .map(calculateItemPrice)
    .reduce(sum, 0);

const hasValidQuantity = (item) => item.quantity > 0;
const calculateItemPrice = (item) => 
  item.price * item.quantity * (1 - (item.discount || 0));
const sum = (a, b) => a + b;
```

- 각 함수는 특정한 변환 관계를 나타내고, 이들의 합성으로 전체 문제를 해결함
- 절차적 코드는 컴퓨터의 실행 과정을 추상화함. 메모리 할당, 루프 실행, 조건 분기 같은 기계적 연산을 변수와 제어 구조로 포장함
- 선언적 코드는 문제 도메인의 논리적 구조를 추상화함
- 비즈니스 규칙, 데이터 관계, 상태 변환 같은 개념적 관계를 함수와 타입으로 표현함

- 리액트에서 UI를 표현할 때 요소들 사이의 포함 관계와 계층 구조가 중요하지 시간적 순서는 중요하지 않음

- 선언적 코드도 결국 세부 구현 사항은 절차적임
- 선언적이 좋고 절차적이 나쁘다는 얘기가 아님
- 중요한건 적절한 레벨에서 적절한 추상화를 제공하는것
- 비즈니스 로직 레벨에서는 선언적으로 접근하는 것이 좋음
- 도메인의 본질적 관계를 표현하는데 집중해야 하기 때문

