
##  결합도의 관점

아래 코드 예시 참고:

```js
const processUserData = (users) => {
	const format = (date) => date.toISOString();
	
	return users.map((user) => ({
		...user,
		date: formate(user.createdAt); // 함수 본문에서 직업 호출
	}))
}
```

이렇게 되었을 때 `processUserData` 함수가 `format` 함수에 종속되게 된다. 요구사항이 변경되어 날짜 표기 방식을 변경해야 한다면 `processUserData` 함수의 내부 코드를 직접 수정해야 한다.

아래처럼 변경한다면 결합도를 낮출 수 있다:

```js
const processUserData = (users, dateFormatter) => {
	return users.map((user) => ({
		...user,
		date: dateFormatter(user.createdAt); // 함수 본문에서 직업 호출
	}))
}

const toISO = (d) => d.toISOString();
const toKorean = (d) => new Intl.DateTimeFormat("ko-KR").format(d);

processUserData(data, toISO);
processUserData(data, toKorean);
```

- 함수 `processUserData`는 "데이터를 순회하고 변환한다" 에 대한 책임을 담당
- "어떻게 날짜를 변환할 것인가" 라는 "정책"은 외부 함수에 위임
- `processUserData`는 포매팅 로직이 무엇이든 상관없이 재사용 가능한 **일반화된** 함수가 됨
- 이를 "제어의 역전" 이라고 함. A가 B를 통제하는 것이 아닌, A를 호출하는 쪽에서 B를 결정해 A에게 주입하는것

이러한 패턴은 코드의 선언적 성격을 강화함. 명령형 프로그래밍은 "어떻게"에 집중해 루프와 상태 변경을 상세히 기술함. 반면, 고차 함수를 활용한 선언적 프로그래밍은 "무엇을"에 집중함.

배열의 `map`, `filter`, `reduce`가 대표적인 고차 함수임
- **명령형**: `for`루프를 돌며 인덱스 `i`를 관리하고, 빈 배열을 생성해 값을 `push` 한다.
- **선언적(`map`)**: "이 배열의 각 요소를 이 함수로 변환하라"고 선언함. 순회 로직은 `map` 함수 내부에 추상화되어 숨겨짐

반복되고 지루한, 오류가 발생하기 쉬운 제어 흐름은 고차 함수 내부에 숨기고, 변동성이 큰 비즈니스 로직은 인자로 받아 처리해 관심사의 분리를 달성하는것

> [!Note] 선언적 프로그래밍 자료
> 