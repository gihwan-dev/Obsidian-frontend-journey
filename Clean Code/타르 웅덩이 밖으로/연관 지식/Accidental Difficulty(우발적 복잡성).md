> [원문](https://wiki.c2.com/?AccidentalDifficulty)

> From [FredBrooks](https://wiki.c2.com/?FredBrooks)' [NoSilverBullet](https://wiki.c2.com/?NoSilverBullet). Accidental difficulty in programming arises from the tools and processes we use. It's not inherent in the nature of programming itself. Accidental difficulty can be removed by improving tools and processes. Brooks later said that maybe the name "[IncidentalDifficulty](https://wiki.c2.com/?IncidentalDifficulty)" would have caused fewer misunderstandings. See also [EssentialDifficulty](https://wiki.c2.com/?EssentialDifficulty).

FredBrooks'의 [[은탄환은 없다]]에서 유래한 단어이다. 프로그래밍에서 우발적 복잡성은 우리가 사용하는 도구와 프로세스에서 발생한다. 프로그램 그 자체에서 발생하지 않는다. 우발적 복잡성은 프로세스와 도구를 개선함으로써 제거할 수 있다. 다른 복잡도로는 [[Essential Difficulty(내제적 복잡성)]]가 있다.

> In fact, it's probably easier to understand [AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty) as the dual of [EssentialDifficulty](https://wiki.c2.com/?EssentialDifficulty); or all that difficulty which is not essential.

사실, AccidentalDifficulty(우발적 어려움)를 EssentialDifficulty(본질적 어려움)의 이원적 개념으로 이해하는 것이 더 쉬울 것이다; 즉, 본질적이지 않은 모든 어려움을 의미한다.

> Occasionally, people like to point up a tool or process or technology as a source of accidental difficulty. That's not exactly right. The accident is the arbitrary decisions that are required in order to get something done. Essentially, I want to sit. Accidentally, I grab a chair, or a tree stump, or a railroad tie, or a park bench. Accidentally, I have to find something sit-on-able and decide that it's a valid thing to sit on. Accidentally, I have to move my arse to the sitting-place.

가끔 사람들은 도구나 프로세스 또는 기술을 우발적 복잡도(accidental difficulty)의 원인으로 지적하곤 한다. 그러나 이는 정확히 맞는 표현이 아니다. 우발적인 것은 무언가를 완수하기 위해 필요한 임의적 결정들이다. 본질적으로, 나는 앉고 싶다. 우발적으로, 나는 의자나 나무 그루터기, 철도 침목, 또는 공원 벤치를 선택다. 우발적으로, 나는 앉을 수 있는 무언가를 찾고 그것이 앉기에 적합한지 결정해야 한다. 우발적으로, 나는 앉을 장소로 내 엉덩이를 옮겨야 한다.

> There's quite a bit of the accidental in programming, but Brooks asserted that it's less than 90% of the programming effort.

프로그래밍에는 우발적 요소가 상당히 많이 존재하지만, Brooks는 이러한 우발적 요소가 프로그래밍 작업 전체의 90%보다는 적은 비중을 차지한다고 주장했습니다.

> _I believe Brooks insofar as believing that there is no **singular** cause for more than 90% of the programming effort across all domains. I.e. there is no one thing to target with a [SilverBullet](https://wiki.c2.com/?SilverBullet). That doesn't preclude that there are 'singular accidents' causing 90% productivity penalties in specific domains, nor does it preclude that the sum-total of all accidents across domains accounting for 90% or more of programming efforts, on average. Indeed, once we start accounting for competitive [NonFunctionalRequirements](https://wiki.c2.com/?NonFunctionalRequirements) and communications between computational services, I wouldn't be surprised if 95% or more of what we encounter is '[AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty)'._

_나는 Brooks의 주장에 동의하는데, 이는 모든 도메인에 걸쳐 프로그래밍 작업의 90% 이상을 차지하는 **단일한** 원인은 없다는 관점에서입니다. 즉, SilverBullet(은총알)로 해결할 수 있는 단 하나의 문제가 없다는 의미입니다. 하지만 이것이 특정 도메인에서 생산성을 90%까지 저하시키는 '단일 우발적 요소'가 존재할 수 없다는 뜻은 아닙니다. 또한 모든 도메인에 걸쳐 발생하는 우발적 요소들의 총합이 평균적으로 프로그래밍 작업의 90% 이상을 차지할 가능성을 배제하는 것도 아닙니다. 실제로, 경쟁적인 비기능적 요구사항(NonFunctionalRequirements)과 컴퓨팅 서비스 간의 통신 문제까지 고려하면, 우리가 직면하는 어려움의 95% 이상이 '우발적 어려움(AccidentalDifficulty)'일 수도 있다고 해도 놀랍지 않을 것입니다.._

> _One question a programmer might ask is: if I had theoretically perfect tools (languages and IDEs and input devices and [OperatingSystem](https://wiki.c2.com/?OperatingSystem)s and frameworks and libraries) and processes (methodologies, community, education, etc.), then, modulo the application-specific stuff, how many of me would I be worth as a programmer/IT person? Ultimately, the answer to this question depends on the domain and the tools you already work with._