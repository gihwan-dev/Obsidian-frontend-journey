> [원문](https://wiki.c2.com/?AccidentalDifficulty)

> From [FredBrooks](https://wiki.c2.com/?FredBrooks)' [NoSilverBullet](https://wiki.c2.com/?NoSilverBullet). Accidental difficulty in programming arises from the tools and processes we use. It's not inherent in the nature of programming itself. Accidental difficulty can be removed by improving tools and processes. Brooks later said that maybe the name "[IncidentalDifficulty](https://wiki.c2.com/?IncidentalDifficulty)" would have caused fewer misunderstandings. See also [EssentialDifficulty](https://wiki.c2.com/?EssentialDifficulty).

FredBrooks'의 [[은탄환은 없다]]에서 유래한 단어이다. 프로그래밍에서 우발적 복잡성은 우리가 사용하는 도구와 프로세스에서 발생한다. 프로그램 그 자체에서 발생하지 않는다. 우발적 복잡성은 프로세스와 도구를 개선함으로써 제거할 수 있다. 다른 복잡도로는 [[Essential Difficulty(내제적 복잡성)]]가 있다.

> In fact, it's probably easier to understand [AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty) as the dual of [EssentialDifficulty](https://wiki.c2.com/?EssentialDifficulty); or all that difficulty which is not essential.

사실, AccidentalDifficulty(우발적 어려움)를 EssentialDifficulty(본질적 어려움)의 이원적 개념으로 이해하는 것이 더 쉬울 것이다; 즉, 본질적이지 않은 모든 어려움을 의미한다.

> Occasionally, people like to point up a tool or process or technology as a source of accidental difficulty. That's not exactly right. The accident is the arbitrary decisions that are required in order to get something done. Essentially, I want to sit. Accidentally, I grab a chair, or a tree stump, or a railroad tie, or a park bench. Accidentally, I have to find something sit-on-able and decide that it's a valid thing to sit on. Accidentally, I have to move my arse to the sitting-place.

가끔 사람들은 도구나 프로세스 또는 기술을 우발적 복잡도(accidental difficulty)의 원인으로 지적하곤 한다. 그러나 이는 정확히 맞는 표현이 아니다. 우발적인 것은 무언가를 완수하기 위해 필요한 임의적 결정들이다. 본질적으로, 나는 앉고 싶다. 우발적으로, 나는 의자나 나무 그루터기, 철도 침목, 또는 공원 벤치를 선택다. 우발적으로, 나는 앉을 수 있는 무언가를 찾고 그것이 앉기에 적합한지 결정해야 한다. 우발적으로, 나는 앉을 장소로 내 엉덩이를 옮겨야 한다.

> There's quite a bit of the accidental in programming, but Brooks asserted that it's less than 90% of the programming effort.

프로그래밍에는 우발적 요소가 상당히 많이 존재하지만, Brooks는 이러한 우발적 요소가 프로그래밍 작업 전체의 90%보다는 적은 비중을 차지한다고 주장했습니다.

> _I believe Brooks insofar as believing that there is no **singular** cause for more than 90% of the programming effort across all domains. I.e. there is no one thing to target with a [SilverBullet](https://wiki.c2.com/?SilverBullet). That doesn't preclude that there are 'singular accidents' causing 90% productivity penalties in specific domains, nor does it preclude that the sum-total of all accidents across domains accounting for 90% or more of programming efforts, on average. Indeed, once we start accounting for competitive [NonFunctionalRequirements](https://wiki.c2.com/?NonFunctionalRequirements) and communications between computational services, I wouldn't be surprised if 95% or more of what we encounter is '[AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty)'._

_나는 Brooks의 주장에 동의하는데, 이는 모든 도메인에 걸쳐 프로그래밍 작업의 90% 이상을 차지하는 **단일한** 원인은 없다는 관점에서입니다. 즉, SilverBullet(은총알)로 해결할 수 있는 단 하나의 문제가 없다는 의미입니다. 하지만 이것이 특정 도메인에서 생산성을 90%까지 저하시키는 '단일 우발적 요소'가 존재할 수 없다는 뜻은 아닙니다. 또한 모든 도메인에 걸쳐 발생하는 우발적 요소들의 총합이 평균적으로 프로그래밍 작업의 90% 이상을 차지할 가능성을 배제하는 것도 아닙니다. 실제로, 경쟁적인 비기능적 요구사항(NonFunctionalRequirements)과 컴퓨팅 서비스 간의 통신 문제까지 고려하면, 우리가 직면하는 어려움의 95% 이상이 '우발적 어려움(AccidentalDifficulty)'일 수도 있다고 해도 놀랍지 않을 것입니다.._

> _One question a programmer might ask is: if I had theoretically perfect tools (languages and IDEs and input devices and [OperatingSystem](https://wiki.c2.com/?OperatingSystem)s and frameworks and libraries) and processes (methodologies, community, education, etc.), then, modulo the application-specific stuff, how many of me would I be worth as a programmer/IT person? Ultimately, the answer to this question depends on the domain and the tools you already work with._

_프로그래머가 던질 수 있는 한 가지 질문은 다음과 같습니다: 만약 이론적으로 완벽한 도구들(언어, IDE, 입력 장치, 운영체제(OperatingSystem), 프레임워크, 라이브러리)과 프로세스(방법론, 커뮤니티, 교육 등)가 있다면, 애플리케이션 특화 요소를 제외하고, 프로그래머/IT 전문가로서 내 생산성은 현재 대비 몇 배가 될 수 있을까? 궁극적으로 이 질문에 대한 답은 작업하는 도메인과 이미 사용 중인 도구들에 따라 달라집니다._

---

> If one is seeing a lot of [AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty) caused by boiler-plate code or hand-written translations to and from tools and interfaces, something in the system is likely [SimplySimplistic](https://wiki.c2.com/?SimplySimplistic). [SimplySimplistic](https://wiki.c2.com/?SimplySimplistic) models and services and interfaces are too simple, failing to capture the [EssentialDifficulty](https://wiki.c2.com/?EssentialDifficulty), and thus force the [EssentialDifficulty](https://wiki.c2.com/?EssentialDifficulty) to be duplicated by each user, increasing the [AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty) with each duplication. Sometimes you can extract this [AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty) into a library or helper [OnceAndOnlyOnce](https://wiki.c2.com/?OnceAndOnlyOnce). Sometimes you cannot. If you cannot, your language tool may be [SimplySimplistic](https://wiki.c2.com/?SimplySimplistic) itself, subject to the [MissingFeatureSmell](https://wiki.c2.com/?MissingFeatureSmell).

만약 보일러플레이트 코드나 도구 및 인터페이스 간의 수작업 변환으로 인해 많은 우발적 복잡성(AccidentalDifficulty)이 발생한다면, 시스템의 어떤 부분이 지나치게 단순화되어 있을(SimplySimplistic) 가능성이 높다. 지나치게 단순화된 모델, 서비스, 인터페이스는 본질적 어려움(EssentialDifficulty)을 제대로 포착하지 못하기 때문에, 각 사용자가 본질적 어려움을 중복해서 처리해야 하며, 이러한 중복은 매번 우발적 어려움을 증가시킨다. 때로는 이러한 우발적 어려움을 한 번만 처리하는(OnceAndOnlyOnce) 라이브러리나 헬퍼로 추출할 수 있지만, 때로는 그럴 수 없다. 만약 추출할 수 없다면, 언어 도구 자체가 지나치게 단순화되어 있어 기능 부재 냄새(MissingFeatureSmell)가 나는 상태일 수 있습니다.

> In reference to [FutureOfProgrammingLanguages](https://wiki.c2.com/?FutureOfProgrammingLanguages), the best your languages and tools can do is become 'unobtrusive', not requiring you to perform any of this extra labor beyond saying what you need done and elaborating on what it means to do what you said needed done (either declaratively or procedurally). The trick, for productivity and avoiding [AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty), is supporting this and simultaneously supporting the required [NonFunctionalRequirements](https://wiki.c2.com/?NonFunctionalRequirements) and [UserAntiStories](https://wiki.c2.com/?UserAntiStories).

프로그래밍 언어의 미래(FutureOfProgrammingLanguages)와 관련하여, 언어와 도구가 할 수 있는 최선은 '방해가 되지 않는(unobtrusive)' 상태가 되는 것이다. 즉, 개발자가 필요한 작업을 명시하고 그 의미를 (선언적으로든 절차적으로든) 설명하는 것 외에 추가적인 노력을 요구하지 않는 것이다. 생산성을 높이고 우발적 복잡성(AccidentalDifficulty)을 피하기 위한 핵심은, 이러한 직관적인 작업 방식을 지원하면서 동시에 필요한 비기능적 요구사항(NonFunctionalRequirements)과 사용자 반대 사례(UserAntiStories)도 지원하는 것이다.

> So perhaps the way to judge languages in terms of [AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty) is in terms of:
> 
> - Inability to refactor encountered [FunctionalRequirements](https://wiki.c2.com/?FunctionalRequirements) (saying what to do, elaborating how to do it) to be [OnceAndOnlyOnce](https://wiki.c2.com/?OnceAndOnlyOnce) in a sharable solution without leaking implementation details.
> - Inability to do either of the above while still meeting [NonFunctionalRequirements](https://wiki.c2.com/?NonFunctionalRequirements) (performance, security, mobility, communications and multi-lingual access, realtime, time-to-market/use, etc.)

따라서 우발적 어려움(AccidentalDifficulty) 측면에서 프로그래밍 언어를 평가하는 방법은 다음과 같을 수 있다:

- 기능적 요구사항(FunctionalRequirements)을 마주했을 때 (무엇을 할지 명시하고, 그것을 어떻게 할지 상세화하는), 이를 구현 세부사항을 유출하지 않으면서 공유 가능한 솔루션에 단 한 번만(OnceAndOnlyOnce) 작성할 수 없는 한계
- 위 작업을 수행하면서 동시에 비기능적 요구사항(NonFunctionalRequirements)(성능, 보안, 이동성, 통신 및 다국어 접근성, 실시간 처리, 출시/사용 시간 등)을 충족시킬 수 없는 한계

> Since a language's ability to meet these NFRs tends to be measured 'relative' to other languages **and** the desire to meet them tends to be 'competitive' with other products in the same domain, it isn't possible to classify [AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty) on an absolute scale, but only comparatively between (language x domain) pairs. E.g. the [AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty) introduced by [VisualBasic](https://wiki.c2.com/?VisualBasic) for business forms (low rate of change, low object count, high latency acceptable) is considerably less than for producing multiplayer videogames (competitive high rate of change (for more interaction), competitive high object count, latency requirements, graceful degradation requirements, security issues for memory access in competitive play, etc.), even if both desire multi-language support and fast time-to-market/use.

언어가 이러한 비기능적 요구사항(NFR)을 충족시키는 능력은 일반적으로 다른 언어들과 '상대적으로' 측정되며, 이를 충족시키려는 욕구는 같은 도메인 내 다른 제품들과 '경쟁적'이기 때문에, 우발적 어려움(AccidentalDifficulty)을 절대적 척도로 분류하는 것은 불가능하다. 이는 오직 (언어 x 도메인) 쌍 간의 비교로만 가능하다.

예를 들어, 비즈니스 양식(낮은 변경률, 적은 객체 수, 높은 지연 시간 허용)에 VisualBasic을 사용할 때 발생하는 우발적 어려움은 멀티플레이어 비디오 게임(경쟁적으로 높은 변경률, 경쟁적으로 많은 객체 수, 지연 시간 요구사항, 점진적 성능 저하 요구사항, 경쟁적 플레이에서의 메모리 접근 보안 문제 등)을 제작할 때보다 상당히 적다. 이는 두 도메인 모두 다국어 지원과 빠른 출시/사용 시간을 원한다 해도 마찬가지다.

> All [TuringComplete](https://wiki.c2.com/?TuringComplete) languages are equivalent modulo [AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty). Therefore, [AccidentalDifficulty](https://wiki.c2.com/?AccidentalDifficulty), of the two forms above, is the only thing that matters when objectively comparing [GeneralPurposeProgrammingLanguage](https://wiki.c2.com/?GeneralPurposeProgrammingLanguage)s.

모든 튜링 완전(TuringComplete) 언어들은 우발적 어려움(AccidentalDifficulty)을 제외하면 동등하다. 따라서, 위에서 언급한 두 가지 형태의 우발적 어려움만이 범용 프로그래밍 언어들(GeneralPurposeProgrammingLanguages)을 객관적으로 비교할 때 중요한 유일한 요소이다.