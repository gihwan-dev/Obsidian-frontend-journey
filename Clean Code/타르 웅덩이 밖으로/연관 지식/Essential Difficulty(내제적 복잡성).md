> [원문](https://wiki.c2.com/?EssentialComplexity)

본질적 복잡성(Essential Complexity)은 해결하려는 문제 자체에 내재된 피할 수 없는 복잡성을 의미한다. 이는 우발적 복잡성(Accidental Complexity)과 대비되는 개념으로, 어떤 문제를 해결하기 위해 반드시 다루어야 하는 최소한의 복잡성이다.

본질적 복잡성의 주요 원인은 다음과 같다:

- 문제 영역 자체가 복잡함 - 예: 인지과학(Cognitive Sciences)
- 알고리즘이 본질적으로 이해하기 어려움 - 예: 양자 컴퓨팅(Quantum Computing)
- 단순한 시스템이 복잡한 시스템으로 성장하면서 발생하는 창발적 행동(Emergent Behavior)
- 변덕스러운 고객, 관리자, 마케터, 정치인 등의 요구사항을 반영하도록 설계된 알고리즘

앞의 두 가지 원인은 "단순한" 해결책을 찾을 수 없어 "무작정 시도(Brute Force)"하거나 복잡한 해결책으로 문제 영역에 대해 충분히 학습할 때까지는 해결책이 복잡할 수밖에 없다는 개념으로 요약됩니다.

---

인체는 "단순하게 유지된" 시스템의 예로, 모든 생명체가 그러했듯이 매우 단순한 유기체로 시작했다. 그 후, 세대를 거듭하며 단순한 변화가 추가되었다. 지역 환경에 더 잘 적응하게 만든 변화만 유지되었고, 그 결과 인체의 복잡성은 본질적 복잡성(Essential Complexity)이 되어 지역 환경의 우연한 변화에 대한 오랜 역사를 기록하게 되었다.

> _저는 전적으로 동의하지 않습니다. "시스템을 단순하게 유지하는 것"은 시스템이 얼마나 이해하기 쉬운지에 대한 지능적 이해가 필요합니다. 점진적인 작은 변화를 통해 시스템을 구축하는 것은 이를 달성하기에 충분하지 않으며, 사실상 과도하게 복잡한 소프트웨어의 전형적인 예입니다. -- DanielKnapp_

두 입장이 서로 배타적이지 않다는 점에 동의한다. 본질적 복잡성(Essential Complexity)이 처음에는 단순한 디자인에 간단한 수정을 축적하면서 발생한다는 입장과, 지능적 설계가 시스템을 단순하게 유지할 수 있다는 입장은 함께 존재할 수 있다. 또는 최소한 과도하게 복잡해지는 것을 방지할 수 있다.

시스템이 과도하게 복잡해지는 것을 막기 위해 _많은_ 지능적 설계가 _필요하다_는 주장에 반드시 동의하지는 않는다. 오히려 극단적인 입장에 가까운데, 너무 많은 설계가 오히려 과도하게 복잡한 소프트웨어를 _만든다_고 생각한다.

[_적응에 영향을 미치지 않는 변화도 유지되지 않을까? 또한, 해로운 영향이 있더라도 번식하지 않는 개체에만 영향을 미치는 변화는 유지될 수 있다._] 후자의 경우, 심지어 선택_될_ 수도 있다. 드론(비생산적 개체)이 과잉 공급된 집단은 번식 개체의 번식을 돕는 데 더 효과적으로 사용될 수 있는 자원을 낭비하게 된다. 전자 범주의 변화는 명백한 효과 없이 유지(또는 소실)될 수 있지만, 환경이 변화하면 "비효율적인" 변이의 저장소가 더 큰 집단이 새로운 환경에 더 잘 적응하는 개체를 포함할 가능성이 높다(행운은 잡종을 선호한다).

> 이 부분은 생물학적 진화 관점에서 복잡성이 어떻게 발생하고 유지되는지에 대한 설명다. 소프트웨어 개발과 비교하자면 이렇게 이해할 수 있다:
> 
> 1. "적응에 영향을 미치지 않는 변화도 유지된다"는 것은:
>     - 소프트웨어에서 특별한 기능을 하지 않지만 그렇다고 문제를 일으키지도 않는 코드가 그대로 남아있는 경우를 의미한다.
>     - 당장은 필요 없어 보이는 코드나 기능이라도 제거하지 않고 그대로 두는 상황과 비슷하다.
> 2. "해로운 영향이 있더라도 번식하지 않는 개체에만 영향을 미치는 변화는 유지될 수 있다"는 것은:
>     - 핵심 기능에는 영향을 주지 않지만 부수적인 부분에 문제를 일으키는 코드 변경사항이 그대로 유지되는 경우를 말한다.
>     - 중요하지 않은 부분의 버그나 비효율성이 수정되지 않고 계속 존재하는 상황과 유사하다.
> 3. "드론이 과잉 공급된 집단은 자원을 낭비한다"는 것은:
>     - 실제로 필요하지 않은 기능이나 코드가 많으면 시스템 자원(메모리, 처리 시간 등)을 낭비하게 된다는 의미이다.
>     - 이는 불필요한 코드나 기능이 시스템의 효율성을 떨어뜨리는 상황을 설명한다.
> 4. "비효율적인 변이의 저장소가 더 큰 집단이 새로운 환경에 더 잘 적응할 가능성이 높다"는 것은:
>     - 다양한 코드와 기능을 유지하는 소프트웨어가 요구사항이 갑자기 변경되었을 때 더 잘 대응할 수 있다는 의미다.
>     - 당장은 쓸모없어 보이는 코드나 기능이라도 나중에 요구사항이 바뀌면 유용해질 수 있다는 것을 시사한다.
> 
> 즉, 이 내용은 소프트웨어 개발에서 일어나는 복잡성 증가가 자연스러운 현상이며, 때로는 그 복잡성이 미래의 변화에 대응하는 데 도움이 될 수 있다는 관점을 설명하고 있다다. 불필요해 보이는 코드나 기능이 축적되면 복잡도는 올라가지만, 환경(요구사항)이 변할 때 그 다양성이 오히려 적응에 도움이 될 수 있다는 것이다.

---

본질적 복잡성의 한 형태는 생물체에 적용된다 - 이는 기능적 제약에서의 우연한 변화에 대한 다양한 역사를 기록하는 것이다. KentBeck이 말했듯이, 이러한 종류의 복잡성은 가장 단순하고, 가장 공격적으로 리팩토링되며, 가장 성실하게 페어 프로그래밍된 XP(익스트림 프로그래밍) 프로젝트에도 서서히 스며들게 된다. 그리고 결과는 동일할 것이다. 종이 결국 멸종하는 것처럼, 성공적인 XP 프로젝트도 결국에는 복잡해져서 폐기되고 새로운 것에 자리를 내줘야 한다.

> _여기서 XP(익스트림 프로그래밍)는 소프트웨어 개발 방법론 중 하나로, 단순함과 지속적인 개선을 추구합니다. 하지만 이 글은 아무리 단순함을 추구해도 시간이 지나면 복잡성이 불가피하게 증가한다는 점을 설명하고 있습니다._

단순한 시스템은 반드시 복잡한 시스템으로 성장할 수밖에 없다. 왜냐하면 그들은 더 단순한 시스템으로 성장할 수 없기 때문다. 이미 가능한 한 단순한 상태이므로, 그들이 나아갈 수 있는 유일한 방향은 더 많은 복잡성을 향하는 것이다. (StephenJayGould가 _FullHouse_에서 '왼쪽 벽(LeftWall)'이라고 부르는 개념)

> _이 개념은 진화나 시스템 발전에서 '단순함'이 일종의 경계나 벽처럼 작용한다는 의미입니다. 이미 최대한 단순한 상태에서는 더 단순해질 수 없으므로, 변화가 발생하면 필연적으로 복잡성이 증가하는 방향으로만 진행될 수 있다는 것입니다._

복잡한 시스템은 단순하게 만들 수 있다. 이는 진화에서도 프로그래밍에서도 발생다. 하지만 직관적으로, 소프트웨어 시스템에서는 복잡성이 시간이 지나도 유지될 것으로 예상된다. 왜냐하면 복잡성은 기능성과 연관되어 있고, 기능성을 잃는 것(나중에 더 많은 기능을 얻기 위해서라도)은 소프트웨어 시스템 소유자에게 받아들일 수 없기 때문이다. (소프트웨어 세계의 극도로 빠른 변화, 시장 압력 등과 같은 다른 요소들이 소프트웨어의 진화에 영향을 미칠 수 있으며, 그 효과는 더 중요할 수 있다. 저는 성급한 결론을 내리고 싶지 않다.)

_시스템의 단순화는 진화에서 절대 일어나지 않는다. 위에서 언급한 제약 조건의 역사가 XP 프로젝트에서도 유지된다는 점을 고려하면, 복잡성을 줄이는 주요 방법은 프로젝트 끝에서 배운 것을 가지고 처음부터 다시 시작하는 것임이 분명해야 한다. 자연이 그런 일을 절대 하지 않는다는 것은 더욱 분명해야 한다._

자연이 그렇게 하지 않는다고 확신할 수 있을까? 대량 멸종에 대해서는 어떨까... (자연이 적어도 5번 거의 처음부터 다시 시작했다고 말할 수 있지 않을까? http://en.wikipedia.org/wiki/Extinction_event) _자연이 그 사건들로부터 무언가를 "배웠다"고 말하기는 어렵다 - 단지 많은 것을 잊었을 뿐이다._

> _이 논의는 소프트웨어 시스템과 자연 진화의 유사점과 차이점을 다루고 있다. 소프트웨어에서는 기존 기능을 유지하면서 단순화하는 것이 어렵고, 자연 진화에서도 대량 멸종 같은 극단적 사건 이외에는 단순화가 잘 일어나지 않는다는 관점을 보여다. 대량 멸종이 '처음부터 다시 시작'인지 아니면 단지 '많은 것을 잊은 것'인지에 대한 해석의 차이도 드러난다._

**생명은 엔트로피를 소화한다.**

{도움이 되지 않는 기능에 대한 유전자는 사용하지 않아 사라지거나(또는 다른 용도로 대신 사용된다). 예를 들어, 포유류는 공룡 시대 동안 대부분 야행성이었기 때문에 일부 색각 유전자를 잃었다. 영장류는 과일을 분석하기 위해 열등한 대체물을 재발명해야 했다. 그러나 필요가 다시 생길 경우를 대비해 이러한 유전자를 보존하는 것이 "좋다"고 주장할 수도 있다.}

---

이러한 주장에 설득되는지 살펴보자... 냉장고처럼 단순한 것을 생각해보자. 두 개의 상자 주위에 냉각 장치가 있는 것이다. 본질적으로 복잡할 것이 없다. 이제 소비자 구매를 추가해보자. "네, 손님, 4, 15, 18, 25 또는 30 입방 피트 중 어떤 것을 원하시나요? 냉동실은 내부, 위, 아래 또는 옆(왼쪽? 오른쪽?)에 있는 것으로 할까요? 색상은요? 물 디스펜서도 필요하신가요? 얼음은요? 각얼음이나 분쇄얼음? 자동 성에 제거 기능은요? ...기타 등등..."

이제 자동차처럼 그 자체로 상당히 복잡한 것을 생각해보자. 위의 과정을 반복해보자.

3억 명의 개인을 만족시키려는 데서 오는 일종의 복잡성이 있다. 이는 "깔끔한 알고리즘" 접근법으로는 만족시킬 수 없으며, 형편없는 디자이너들이 도입한 것도 아니다. -- AlistairCockburn

Frederick P. Brooks, Jr.(MythicalManMonth의 저자)는 "아인슈타인은 신이 변덕스럽거나 임의적이지 않기 때문에 자연에 대한 단순화된 설명이 있어야 한다고 주장했다. 그러한 신념은 소프트웨어 엔지니어에게 위안이 되지 않는다"라고 했다.

- 아인슈타인 - "Raffiniert ist der Herr Gott, aber boshaft ist er nicht." (신은 교묘하지만, 악의적이지는 않다.) 프린스턴 대학교 파인 홀에 새겨져 있음

```
이것을 정신적으로 '세련된 것은 신이고, 가짜는 아니다'라고 번역했다 :) -- DarrenHobbs
```

_나는 자동차의 구성 요소들이 각각 자체 객체로 단순화될 수 있기를 바란다. 상호 의존적인 시스템(엔진 구획에 휴대용, 자급자족형 에어컨이 있는 자동차를 몇 대나 알고 있는가?)에서 진정으로 고립된 객체를 가질 수 없다는 것을 알고 있지만, 가능한 한 이러한 구별을 유지할 필요가 있다. 냉장고는 자동 성에 제거 장치를 위한 공간을 허용하는 설계가 필요하지만, 냉장 기능을 제공하기 위해 그 기능을 필요로 하지는 않는다._

왜? 사람들은 가끔 고무 부품을 교체하는 것 외에는 냉장고를 업그레이드하지 않는다. 그들은 일반적인 대형 소프트웨어 프로그램 수명의 약 10배 동안 냉장고를 사용한 후 전체를 교체한다. 따라서, 냉장고 설계는 고도로 최적화될 수 있고 또 그래야 한다 - 자동 성에 제거 장치가 포함된 모델은 그것을 위한 공간을 허용해야 하고, 그렇지 않은 모델은 그럴 필요가 없다. 자동차는 아마도 컴퓨터에 더 가깝지만, 훨씬 더 잘 문서화되고 지원된다(그리고 아마도 더 낮은 EssentialComplexity를 보여주며 훨씬 더 문서화하고 지원하기 쉽다). 나는 단지 세상의 모든 것이 소프트웨어와 유사하지 않다는 점을 지적하고 있으며, 프로그램이 실제 주제일 때는 보통 "냉장고/집/비행기"보다는 "프로그램"이라고 읽고 싶다. -- DanielKnapp

---

이 페이지는 불필요하게 복잡하다. EssentialComplexity(본질적 복잡성)는 내가 없이는 살 수 없는 복잡성이다. -- WaldenMathews

본질적으로 KISS(Keep It Simple, Stupid)다. 단순함은 (프랙탈 전체론적) 복잡성이 하는 것과 같다. -- GeraldLindsly

좋아, 포기한다. 대체 어떤 약을 복용하고 있는 거지?

오래된 전통적인 치료법도 인정받지 않나? -- gl ;)

본질적 복잡성을 포함할 수 있을 만큼만 단순하게 만들고, 그 이상도 이하도 아니게, 끝. -- 아인슈타인 개념을 GL화.

본질적 복잡성은 소프트웨어가 어떻게 작동하는지 정당화하는 데 사용하는 논쟁이다.

"본질적 복잡성은 소프트웨어를 어떻게 작업했는지 정당화하는 데 사용하는 논쟁이다" -- IvanStojic

한 가지는 그 복잡성의 수준이 한 개인이 관리할 수 있는 것보다 더 클 때 "본질적 복잡성"을 나타낸다 -- Gigi

추상적으로 "본질적 복잡성"에 대해 생각하는 대신, 본질적 상태와 우연적 상태를 찾아보자. 장기간 유지되는 모든 상태에 대해, 그 상태를 유지하지 않는 프로그램을 원칙적으로 작성할 수 있는지 물어보자. 많은 프로그램이 우연적 상태를 관리하는 데 대부분의 노력을 쏟는다는 것을 알게 될 것이다. -- EdFaulkner