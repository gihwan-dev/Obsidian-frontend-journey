> [원문](https://wiki.c2.com/?EssentialComplexity)

본질적 복잡성(Essential Complexity)은 해결하려는 문제 자체에 내재된 피할 수 없는 복잡성을 의미한다. 이는 우발적 복잡성(Accidental Complexity)과 대비되는 개념으로, 어떤 문제를 해결하기 위해 반드시 다루어야 하는 최소한의 복잡성이다.

본질적 복잡성의 주요 원인은 다음과 같다:

- 문제 영역 자체가 복잡함 - 예: 인지과학(Cognitive Sciences)
- 알고리즘이 본질적으로 이해하기 어려움 - 예: 양자 컴퓨팅(Quantum Computing)
- 단순한 시스템이 복잡한 시스템으로 성장하면서 발생하는 창발적 행동(Emergent Behavior)
- 변덕스러운 고객, 관리자, 마케터, 정치인 등의 요구사항을 반영하도록 설계된 알고리즘

앞의 두 가지 원인은 "단순한" 해결책을 찾을 수 없어 "무작정 시도(Brute Force)"하거나 복잡한 해결책으로 문제 영역에 대해 충분히 학습할 때까지는 해결책이 복잡할 수밖에 없다는 개념으로 요약됩니다.

---

인체는 "단순하게 유지된" 시스템의 예로, 모든 생명체가 그러했듯이 매우 단순한 유기체로 시작했다. 그 후, 세대를 거듭하며 단순한 변화가 추가되었다. 지역 환경에 더 잘 적응하게 만든 변화만 유지되었고, 그 결과 인체의 복잡성은 본질적 복잡성(Essential Complexity)이 되어 지역 환경의 우연한 변화에 대한 오랜 역사를 기록하게 되었다.

> _저는 전적으로 동의하지 않습니다. "시스템을 단순하게 유지하는 것"은 시스템이 얼마나 이해하기 쉬운지에 대한 지능적 이해가 필요합니다. 점진적인 작은 변화를 통해 시스템을 구축하는 것은 이를 달성하기에 충분하지 않으며, 사실상 과도하게 복잡한 소프트웨어의 전형적인 예입니다. -- DanielKnapp_

두 입장이 서로 배타적이지 않다는 점에 동의한다. 본질적 복잡성(Essential Complexity)이 처음에는 단순한 디자인에 간단한 수정을 축적하면서 발생한다는 입장과, 지능적 설계가 시스템을 단순하게 유지할 수 있다는 입장은 함께 존재할 수 있다. 또는 최소한 과도하게 복잡해지는 것을 방지할 수 있다.

시스템이 과도하게 복잡해지는 것을 막기 위해 _많은_ 지능적 설계가 _필요하다_는 주장에 반드시 동의하지는 않는다. 오히려 극단적인 입장에 가까운데, 너무 많은 설계가 오히려 과도하게 복잡한 소프트웨어를 _만든다_고 생각한다.

[_적응에 영향을 미치지 않는 변화도 유지되지 않을까? 또한, 해로운 영향이 있더라도 번식하지 않는 개체에만 영향을 미치는 변화는 유지될 수 있다._] 후자의 경우, 심지어 선택_될_ 수도 있다. 드론(비생산적 개체)이 과잉 공급된 집단은 번식 개체의 번식을 돕는 데 더 효과적으로 사용될 수 있는 자원을 낭비하게 됩니다. 전자 범주의 변화는 명백한 효과 없이 유지(또는 소실)될 수 있지만, 환경이 변화하면 "비효율적인" 변이의 저장소가 더 큰 집단이 새로운 환경에 더 잘 적응하는 개체를 포함할 가능성이 높습니다(행운은 잡종을 선호합니다).

> 이 부분은 생물학적 진화 관점에서 복잡성이 어떻게 발생하고 유지되는지에 대한 설명입니다. 소프트웨어 개발과 비교하자면 이렇게 이해할 수 있습니다:
> 
> 1. "적응에 영향을 미치지 않는 변화도 유지된다"는 것은:
>     
>     - 소프트웨어에서 특별한 기능을 하지 않지만 그렇다고 문제를 일으키지도 않는 코드가 그대로 남아있는 경우를 의미합니다.
>     - 당장은 필요 없어 보이는 코드나 기능이라도 제거하지 않고 그대로 두는 상황과 비슷합니다.
> 2. "해로운 영향이 있더라도 번식하지 않는 개체에만 영향을 미치는 변화는 유지될 수 있다"는 것은:
>     
>     - 핵심 기능에는 영향을 주지 않지만 부수적인 부분에 문제를 일으키는 코드 변경사항이 그대로 유지되는 경우를 말합니다.
>     - 중요하지 않은 부분의 버그나 비효율성이 수정되지 않고 계속 존재하는 상황과 유사합니다.
> 3. "드론이 과잉 공급된 집단은 자원을 낭비한다"는 것은:
>     
>     - 실제로 필요하지 않은 기능이나 코드가 많으면 시스템 자원(메모리, 처리 시간 등)을 낭비하게 된다는 의미입니다.
>     - 이는 불필요한 코드나 기능이 시스템의 효율성을 떨어뜨리는 상황을 설명합니다.
> 4. "비효율적인 변이의 저장소가 더 큰 집단이 새로운 환경에 더 잘 적응할 가능성이 높다"는 것은:
>     
>     - 다양한 코드와 기능을 유지하는 소프트웨어가 요구사항이 갑자기 변경되었을 때 더 잘 대응할 수 있다는 의미입니다.
>     - 당장은 쓸모없어 보이는 코드나 기능이라도 나중에 요구사항이 바뀌면 유용해질 수 있다는 것을 시사합니다.
> 
> 즉, 이 내용은 소프트웨어 개발에서 일어나는 복잡성 증가가 자연스러운 현상이며, 때로는 그 복잡성이 미래의 변화에 대응하는 데 도움이 될 수 있다는 관점을 설명하고 있습니다. 불필요해 보이는 코드나 기능이 축적되면 복잡도는 올라가지만, 환경(요구사항)이 변할 때 그 다양성이 오히려 적응에 도움이 될 수 있다는 것입니다.

