> [원문](https://curtclifton.net/papers/MoseleyMarks06a.pdf)

> **초록**
> 복잡성은 대규모 소프트웨어 시스템을 성공적으로 개발하는 데 있어 가장 큰 어려움이다. Brooks를 따라 우발적 어려움과 본질적 어려움을 구분하지만, 현대 시스템에 남아있는 대부분의 복잡성이 본질적이라는 그의 전제에는 동의하지 않는다. 복잡성의 일반적인 원인을 식별하고 우발적 성격을 가진 복잡성을 제거하기 위해 취할 수 있는 일반적인 접근 방식을 논의한다. 보다 구체적으로 만들기 위해 함수형 프로그래밍과 Codd의 관계형 데이터 모델에 기반한 잠재적 복잡성 최소화 접근법의 개요를 제시한다.

## 1 서론
"소프트웨어 위기"는 1968년에 처음 식별되었으며[NR69, p70], 이후 수십 년 동안 완화되기보다는 오히려 심화되었다. 대규모 소프트웨어 시스템의 개발과 유지보수에서 가장 큰 문제는 복잡성이다 — 대규모 시스템은 이해하기 어렵다. 많은 시스템에서 이러한 복잡성의 주요 원인은 상태(state)를 다루는 방식과 시스템을 분석하고 추론할 때 이것이 더하는 부담이라고 생각한다. 다른 밀접하게 관련된 원인으로는 코드 양과 시스템을 통한 제어 흐름에 대한 명시적 관심이 있다.

상태의 어려움에 접근하는 전통적인 방법에는 상태와 관련 동작을 긴밀하게 결합하는 객체지향 프로그래밍과 순수한 형태에서 상태와 부작용을 완전히 배제하는 함수형 프로그래밍이 있다. 이러한 접근 방식은 전통적인 대규모 시스템에 적용될 때 각각 다양한(그리고 서로 다른) 문제를 겪는다. 두 방식에서 유용한 아이디어를 취할 수 있으며, 관계형 데이터베이스 세계의 일부 아이디어와 결합했을 때 이 접근법이 대규모 소프트웨어 시스템 구축을 단순화하는 데 상당한 잠재력을 제공한다고 주장한다.

이 논문은 두 부분으로 나뉜다. 전반부에서는 복잡성에 초점을 맞춘다. 2장에서는 일반적인 복잡성을 살펴보고 복잡성이 위기의 근본 원인이라는 우리의 주장을 정당화한 다음, 3장에서는 현재 우리가 시스템을 이해하려고 시도하는 방법을 살펴본다. 4장에서는 복잡성의 원인(즉, 이해를 어렵게 만드는 요소들)을 살펴본 후, 5장에서 이러한 복잡성 원인을 관리하기 위한 전통적인 접근 방식을 논의한다. 6장에서는 "우발적"과 "본질적"이라는 용어의 의미를 정의하고, 7장에서는 복잡성의 원인을 해결하기 위한 대안적 방법에 대한 권장 사항을 제시한다 — 문제에 대처하기보다는 문제를 회피하는 데 중점을 둔다.

## 2 복잡성
그의 고전적인 논문 "은탄환은 없다(No Silver Bullet)"에서 Brooks[Bro86]는 소프트웨어 구축을 어렵게 만드는 소프트웨어 시스템의 네 가지 속성을 식별했다: 복잡성(Complexity), 순응성(Conformity), 변경가능성(Changeability), 비가시성(Invisibility). 이 중에서 복잡성만이 유일하게 중요하다고 생각한다 — 다른 속성들은 복잡성의 형태로 분류되거나, 시스템의 복잡성 때문에만 문제가 되는 것으로 볼 수 있다. 복잡성은 오늘날 소프트웨어의 대부분 문제의 근본 원인이다. 신뢰성 부족, 납기 지연, 보안 부족 — 심지어 대규모 시스템에서의 성능 저하도 궁극적으로 관리할 수 없는 복잡성에서 비롯된 것으로 볼 수 있다. 복잡성이 이러한 다른 문제들의 주요 원인으로서 갖는 일차적 지위는 시스템을 이해하는 능력이 이 모든 문제를 피하기 위한 전제 조건이라는 사실에서 비롯되며, 물론 복잡성은 이러한 이해를 파괴한다. 복잡성의 관련성은 널리 인식되고 있다. Dijkstra가 말했듯이[Dij97, EWD1243]:

... 그리고 Economist지는 소프트웨어 복잡성에 관한 전체 기사를 할애했다[Eco04] — 일부 추정에 따르면 소프트웨어 문제로 인해 미국 경제에서 연간 590억 달러의 비용이 발생한다고 언급했다. 우리 시스템에 대해 생각하고 추론할 수 있는 능력(특히 그 시스템에 대한 변경 사항의 영향)은 매우 중요하다. 복잡성의 위험과 이와 관련된 단순성의 중요성은 ACM 튜링 상 강연에서도 인기 있는 주제였다. 1990년 강연에서 Corbato는 다음과 같이 말했다[Cor91]: 

"야심찬 시스템의 일반적인 문제는 복잡성이다.", "...단순성과 우아함의 가치를 강조하는 것이 중요하다. 복잡성은 어려움을 증가시키는 방식을 가지고 있기 때문이다" 

1977년 Backus[Bac78]는 전통적인 언어의 "복잡성과 약점"에 대해 이야기하며 다음과 같이 언급했다: 

"프로그램에 대해 생각하는 데 도움이 되는 강력한 방법론이 절실히 필요하다. ... 기존 언어들은 프로그램에 대해 생각하는 방식에서 불필요한 혼란을 만들어낸다" 

마지막으로, 1980년 튜링 상 연설에서 Hoare[Hoa81]는 다음과 같이 관찰했다: 

"...구매할 수 없는 하나의 품질이 있다 — 그것은 신뢰성이다. 신뢰성의 대가는 극도의 단순성을 추구하는 것이다" 

그리고 소프트웨어 설계를 구성하는 두 가지 방법이 있다고 결론짓는다: 

"한 가지 방법은 명백히 결함이 없을 만큼 간단하게 만드는 것이고, 다른 방법은 명백한 결함이 없을 만큼 복잡하게 만드는 것이다. 첫 번째 방법이 훨씬 더 어렵다." 

이것이 불행한 진실이다:

### 단순성은 어렵다.
... 하지만 이 논문의 목적은 낙관론을 위한 어떤 근거를 제시하는 것이다. 마지막으로 한 가지 지적할 점은 이 논문에서 논의하는 복잡성의 유형은 대규모 시스템을 이해하기 어렵게 만드는 것이라는 점이다. 이것이 우리가 그러한 시스템을 만들고 유지하는 데 막대한 자원을 소비하게 만드는 원인이다. 이러한 유형의 복잡성은 복잡도 이론(complexity theory) — 프로그램을 실행하는 기계가 소비하는 자원을 연구하는 컴퓨터 과학 분야 — 과는 전혀 관련이 없다. 이 둘은 완전히 무관하다 — 몇 줄로 작은 프로그램을 작성하는 것은 간단한 일이며, 이것이 (우리가 말하는 의미에서) 믿을 수 없을 정도로 단순하면서도 (복잡도 이론 의미에서) 최고 복잡도 클래스에 속할 수 있다. 이 시점부터 우리는 첫 번째 종류의 복잡성만을 논의할 것이다. 우리가 일반적으로 시스템을 이해하려고 시도하는 방법을 정확히 논의한 후에, 복잡성의 주요 공통 원인(이해를 어렵게 만드는 것들)이라고 생각하는 것들을 살펴볼 것이다.

## 3 이해를 위한 접근 방식
앞서 복잡성의 위험은 시스템을 이해하려는 우리의 시도에 미치는 영향에서 비롯된다고 주장했다. 이 때문에 시스템을 이해하기 위해 일반적으로 사용되는 메커니즘을 고려하는 것이 도움이 된다. 그러면 나중에 복잡성의 잠재적 원인이 이러한 접근 방식에 미치는 영향을 고려할 수 있다.

시스템(또는 시스템의 구성 요소)을 이해하기 위해 널리 사용되는 두 가지 접근 방식이 있다:

**테스팅** 이것은 시스템을 외부에서 — "블랙박스"로 — 이해하려고 시도하는 것이다. 시스템에 대한 결론은 특정한 상황에서 어떻게 동작하는지에 대한 관찰을 기반으로 도출된다. 테스팅은 사람에 의해서나 기계에 의해서 수행될 수 있다. 전자는 전체 시스템 테스팅에서 더 일반적이고, 후자는 개별 구성 요소 테스팅에서 더 일반적이다.

**비공식적 추론** 이것은 시스템을 내부에서 살펴봄으로써 시스템을 이해하려고 시도하는 것이다. 추가로 이용 가능한 정보를 사용하여 더 정확한 이해를 얻을 수 있다는 희망이다.

이 둘 중에서 비공식적 추론이 훨씬 더 중요하다. 이는 아래에서 보겠지만 테스팅으로 달성할 수 있는 것에는 본질적인 한계가 있기 때문이고, 비공식적 추론은 (개발 과정의 본질적인 부분이기 때문에) 항상 사용되기 때문이다. 또 다른 정당화 근거는 비공식적 추론의 개선은 더 적은 오류가 생성되도록 이끌 것인 반면, 테스팅의 개선이 할 수 있는 모든 것은 더 많은 오류가 탐지되도록 이끄는 것뿐이라는 점이다. Dijkstra가 그의 튜링 상 연설에서 말했듯이[Dij72, EWD340]:

"정말로 신뢰할 수 있는 소프트웨어를 원하는 사람들은 애초에 대부분의 버그를 피할 수 있는 수단을 찾아야 한다는 것을 발견할 것이다."

그리고 ("문제를 이해하는 것"의 중요성과 "우아함은 선택 사항이 아니다"를 강조한) O'Keefe가 말했듯이[O'K90]:

"실수에 대한 우리의 대응은 실수를 피할 수 있는 방법을 찾는 것이어야 하며, 사물의 본성을 탓하는 것이 아니어야 한다."

