> [원문](https://curtclifton.net/papers/MoseleyMarks06a.pdf)

> **초록**
> 복잡성은 대규모 소프트웨어 시스템을 성공적으로 개발하는 데 있어 가장 큰 어려움이다. Brooks를 따라 우발적 어려움과 본질적 어려움을 구분하지만, 현대 시스템에 남아있는 대부분의 복잡성이 본질적이라는 그의 전제에는 동의하지 않는다. 복잡성의 일반적인 원인을 식별하고 우발적 성격을 가진 복잡성을 제거하기 위해 취할 수 있는 일반적인 접근 방식을 논의한다. 보다 구체적으로 만들기 위해 함수형 프로그래밍과 Codd의 관계형 데이터 모델에 기반한 잠재적 복잡성 최소화 접근법의 개요를 제시한다.

## 1 서론
"소프트웨어 위기"는 1968년에 처음 식별되었으며[NR69, p70], 이후 수십 년 동안 완화되기보다는 오히려 심화되었다. 대규모 소프트웨어 시스템의 개발과 유지보수에서 가장 큰 문제는 복잡성이다 — 대규모 시스템은 이해하기 어렵다. 많은 시스템에서 이러한 복잡성의 주요 원인은 상태(state)를 다루는 방식과 시스템을 분석하고 추론할 때 이것이 더하는 부담이라고 생각한다. 다른 밀접하게 관련된 원인으로는 코드 양과 시스템을 통한 제어 흐름에 대한 명시적 관심이 있다.

상태의 어려움에 접근하는 전통적인 방법에는 상태와 관련 동작을 긴밀하게 결합하는 객체지향 프로그래밍과 순수한 형태에서 상태와 부작용을 완전히 배제하는 함수형 프로그래밍이 있다. 이러한 접근 방식은 전통적인 대규모 시스템에 적용될 때 각각 다양한(그리고 서로 다른) 문제를 겪는다. 두 방식에서 유용한 아이디어를 취할 수 있으며, 관계형 데이터베이스 세계의 일부 아이디어와 결합했을 때 이 접근법이 대규모 소프트웨어 시스템 구축을 단순화하는 데 상당한 잠재력을 제공한다고 주장한다.

이 논문은 두 부분으로 나뉜다. 전반부에서는 복잡성에 초점을 맞춘다. 2장에서는 일반적인 복잡성을 살펴보고 복잡성이 위기의 근본 원인이라는 우리의 주장을 정당화한 다음, 3장에서는 현재 우리가 시스템을 이해하려고 시도하는 방법을 살펴본다. 4장에서는 복잡성의 원인(즉, 이해를 어렵게 만드는 요소들)을 살펴본 후, 5장에서 이러한 복잡성 원인을 관리하기 위한 전통적인 접근 방식을 논의한다. 6장에서는 "우발적"과 "본질적"이라는 용어의 의미를 정의하고, 7장에서는 복잡성의 원인을 해결하기 위한 대안적 방법에 대한 권장 사항을 제시한다 — 문제에 대처하기보다는 문제를 회피하는 데 중점을 둔다.

## 2 복잡성
그의 고전적인 논문 "은탄환은 없다(No Silver Bullet)"에서 Brooks[Bro86]는 소프트웨어 구축을 어렵게 만드는 소프트웨어 시스템의 네 가지 속성을 식별했다: 복잡성(Complexity), 순응성(Conformity), 변경가능성(Changeability), 비가시성(Invisibility). 이 중에서 복잡성만이 유일하게 중요하다고 생각한다 — 다른 속성들은 복잡성의 형태로 분류되거나, 시스템의 복잡성 때문에만 문제가 되는 것으로 볼 수 있다. 복잡성은 오늘날 소프트웨어의 대부분 문제의 근본 원인이다. 신뢰성 부족, 납기 지연, 보안 부족 — 심지어 대규모 시스템에서의 성능 저하도 궁극적으로 관리할 수 없는 복잡성에서 비롯된 것으로 볼 수 있다. 복잡성이 이러한 다른 문제들의 주요 원인으로서 갖는 일차적 지위는 시스템을 이해하는 능력이 이 모든 문제를 피하기 위한 전제 조건이라는 사실에서 비롯되며, 물론 복잡성은 이러한 이해를 파괴한다. 복잡성의 관련성은 널리 인식되고 있다. Dijkstra가 말했듯이[Dij97, EWD1243]:

... 그리고 Economist지는 소프트웨어 복잡성에 관한 전체 기사를 할애했다[Eco04] — 일부 추정에 따르면 소프트웨어 문제로 인해 미국 경제에서 연간 590억 달러의 비용이 발생한다고 언급했다. 우리 시스템에 대해 생각하고 추론할 수 있는 능력(특히 그 시스템에 대한 변경 사항의 영향)은 매우 중요하다. 복잡성의 위험과 이와 관련된 단순성의 중요성은 ACM 튜링 상 강연에서도 인기 있는 주제였다. 1990년 강연에서 Corbato는 다음과 같이 말했다[Cor91]: 

"야심찬 시스템의 일반적인 문제는 복잡성이다.", "...단순성과 우아함의 가치를 강조하는 것이 중요하다. 복잡성은 어려움을 증가시키는 방식을 가지고 있기 때문이다" 

1977년 Backus[Bac78]는 전통적인 언어의 "복잡성과 약점"에 대해 이야기하며 다음과 같이 언급했다: 

"프로그램에 대해 생각하는 데 도움이 되는 강력한 방법론이 절실히 필요하다. ... 기존 언어들은 프로그램에 대해 생각하는 방식에서 불필요한 혼란을 만들어낸다" 

마지막으로, 1980년 튜링 상 연설에서 Hoare[Hoa81]는 다음과 같이 관찰했다: 

"...구매할 수 없는 하나의 품질이 있다 — 그것은 신뢰성이다. 신뢰성의 대가는 극도의 단순성을 추구하는 것이다" 

그리고 소프트웨어 설계를 구성하는 두 가지 방법이 있다고 결론짓는다: 

"한 가지 방법은 명백히 결함이 없을 만큼 간단하게 만드는 것이고, 다른 방법은 명백한 결함이 없을 만큼 복잡하게 만드는 것이다. 첫 번째 방법이 훨씬 더 어렵다." 

이것이 불행한 진실이다:

### 단순성은 어렵다.
... 하지만 이 논문의 목적은 낙관론을 위한 어떤 근거를 제시하는 것이다. 마지막으로 한 가지 지적할 점은 이 논문에서 논의하는 복잡성의 유형은 대규모 시스템을 이해하기 어렵게 만드는 것이라는 점이다. 이것이 우리가 그러한 시스템을 만들고 유지하는 데 막대한 자원을 소비하게 만드는 원인이다. 이러한 유형의 복잡성은 복잡도 이론(complexity theory) — 프로그램을 실행하는 기계가 소비하는 자원을 연구하는 컴퓨터 과학 분야 — 과는 전혀 관련이 없다. 이 둘은 완전히 무관하다 — 몇 줄로 작은 프로그램을 작성하는 것은 간단한 일이며, 이것이 (우리가 말하는 의미에서) 믿을 수 없을 정도로 단순하면서도 (복잡도 이론 의미에서) 최고 복잡도 클래스에 속할 수 있다. 이 시점부터 우리는 첫 번째 종류의 복잡성만을 논의할 것이다. 우리가 일반적으로 시스템을 이해하려고 시도하는 방법을 정확히 논의한 후에, 복잡성의 주요 공통 원인(이해를 어렵게 만드는 것들)이라고 생각하는 것들을 살펴볼 것이다.

## 3 이해를 위한 접근 방식
앞서 복잡성의 위험은 시스템을 이해하려는 우리의 시도에 미치는 영향에서 비롯된다고 주장했다. 이 때문에 시스템을 이해하기 위해 일반적으로 사용되는 메커니즘을 고려하는 것이 도움이 된다. 그러면 나중에 복잡성의 잠재적 원인이 이러한 접근 방식에 미치는 영향을 고려할 수 있다.

시스템(또는 시스템의 구성 요소)을 이해하기 위해 널리 사용되는 두 가지 접근 방식이 있다:

**테스팅** 이것은 시스템을 외부에서 — "블랙박스"로 — 이해하려고 시도하는 것이다. 시스템에 대한 결론은 특정한 상황에서 어떻게 동작하는지에 대한 관찰을 기반으로 도출된다. 테스팅은 사람에 의해서나 기계에 의해서 수행될 수 있다. 전자는 전체 시스템 테스팅에서 더 일반적이고, 후자는 개별 구성 요소 테스팅에서 더 일반적이다.

**비공식적 추론** 이것은 시스템을 내부에서 살펴봄으로써 시스템을 이해하려고 시도하는 것이다. 추가로 이용 가능한 정보를 사용하여 더 정확한 이해를 얻을 수 있다는 희망이다.

이 둘 중에서 비공식적 추론이 훨씬 더 중요하다. 이는 아래에서 보겠지만 테스팅으로 달성할 수 있는 것에는 본질적인 한계가 있기 때문이고, 비공식적 추론은 (개발 과정의 본질적인 부분이기 때문에) 항상 사용되기 때문이다. 또 다른 정당화 근거는 비공식적 추론의 개선은 더 적은 오류가 생성되도록 이끌 것인 반면, 테스팅의 개선이 할 수 있는 모든 것은 더 많은 오류가 탐지되도록 이끄는 것뿐이라는 점이다. Dijkstra가 그의 튜링 상 연설에서 말했듯이[Dij72, EWD340]:

"정말로 신뢰할 수 있는 소프트웨어를 원하는 사람들은 애초에 대부분의 버그를 피할 수 있는 수단을 찾아야 한다는 것을 발견할 것이다."

그리고 ("문제를 이해하는 것"의 중요성과 "우아함은 선택 사항이 아니다"를 강조한) O'Keefe가 말했듯이[O'K90]:

"실수에 대한 우리의 대응은 실수를 피할 수 있는 방법을 찾는 것이어야 하며, 사물의 본성을 탓하는 것이 아니어야 한다."

테스팅의 핵심 문제는 특정한 입력 집합을 사용하는 (어떤 종류든) 테스트가 시스템이나 구성 요소에 다른 입력 집합이 주어졌을 때의 동작에 대해서는 전혀 알려주지 않는다는 것이다. 가능한 서로 다른 입력의 엄청난 수는 보통 모든 것을 테스트할 가능성을 배제하므로, 테스팅에서 피할 수 없는 관심사는 항상 — 올바른 테스트를 수행했는가? — 가 될 것이다. 이 질문에 대해 얻을 수 있는 유일한 확실한 답은 부정적인 답 — 시스템이 고장날 때 — 이다. 다시, Dijkstra가 관찰했듯이[Dij71, EWD303]:

"테스팅은 절망적으로 부적절하다....(테스팅은) 버그의 존재를 보여주는 데는 매우 효과적으로 사용될 수 있지만 버그의 부재를 보여주는 데는 결코 사용될 수 없다."

우리는 Dijkstra에 동의한다. 테스팅에 의존하는 것은 위험하다.

이것이 테스팅이 쓸모없다는 말은 아니다. 결론적으로 시스템을 이해하려는 모든 방법에는 한계가 있다(이는 범위가 제한적이고 부정확하여 오류가 발생하기 쉬운 비공식적 추론과 명세의 정확성에 의존하는 공식적 추론을 모두 포함한다). 이러한 한계 때문에 테스팅과 추론을 함께 사용하는 것이 종종 현명할 수 있다.

정확히 이러한 모든 접근 방식의 한계 때문에 단순성이 중요하다. 테스팅과 추론을 고려할 때, 단순성은 둘 중 어느 것보다도 더 중요하다. 테스팅에 대한 투자와 단순성에 대한 투자 사이의 극명한 선택이 주어진다면, 후자가 종종 더 나은 선택일 수 있다. 왜냐하면 그것이 시스템을 이해하려는 모든 미래의 시도 — 어떤 종류든 — 를 촉진할 것이기 때문이다.

## 4 복잡성의 원인
중요하지 않은 시스템이 아닌 경우에는 해결해야 할 문제에 내재된 어떤 복잡성이 있다. 하지만 실제 대규모 시스템에서는 "문제에 내재된" 것으로서의 지위가 의심스러운 복잡성을 정기적으로 마주친다. 이제 복잡성의 이러한 원인들 중 일부를 고려해보자.

### 4.1 상태로 인한 복잡성
소프트웨어 시스템의 지원 데스크에 전화를 걸어 "다시 시도해보세요", "문서를 다시 로드하세요", "프로그램을 재시작하세요", "컴퓨터를 재부팅하세요" 또는 "프로그램을 재설치하세요" 심지어 "운영 체제를 재설치한 다음 프로그램을 재설치하세요"라는 말을 들어본 사람은 누구나 상태(state)¹가 신뢰할 수 있고 이해할 수 있는 소프트웨어를 작성하는 데 야기하는 문제를 직접 경험했다.

이러한 문구들이 많은 사람들에게 친숙하게 들리는 이유는 문제를 해결하는 데 종종 성공적이기 때문에 자주 제안되기 때문이다. 그것들이 문제 해결에 종종 성공적인 이유는 많은 시스템이 상태 처리에서 오류를 가지고 있기 때문이다. 이러한 오류들 중 많은 것이 존재하는 이유는 상태의 존재가 프로그램을 이해하기 어렵게 만들기 때문이다. 상태는 프로그램을 복잡하게 만든다.

상태에 관해서는 Brooks가 다음과 같이 말할 때의 감정에 대체로 동의한다[Bro86]:

"복잡성으로부터 프로그램의 모든 가능한 상태를 열거하는 것은 물론이고 이해하는 것의 어려움이 나오며, 그로부터 신뢰성 부족이 나온다"

— 우리는 이에 동의하지만, 많은 가능한 상태의 존재가 애초에 복잡성을 일으킨다고 생각한다. 그리고:

"컴퓨터는... 매우 많은 수의 상태를 가진다. 이것이 그것들을 구상하고, 기술하고, 테스트하는 것을 어렵게 만든다. 소프트웨어 시스템은 컴퓨터보다 수십 배 더 많은 상태를 가진다."

#### 4.1.1 상태가 테스팅에 미치는 영향
Brooks가 언급한 상태가 테스팅에 미치는 영향의 심각성은 아무리 강조해도 지나치지 않다. 상태는 모든 유형의 테스팅에 영향을 미친다 — 시스템 수준 테스팅(테스터가 방금 언급한 불행한 사용자와 같은 문제에 휘둘리게 되는)부터 구성 요소 수준이나 단위 테스팅까지. 핵심 문제는 특정한 상태에 있는 시스템이나 구성 요소에 대한 (어떤 종류든) 테스트가 그 시스템이나 구성 요소가 다른 상태에 있을 때의 동작에 대해서는 전혀 알려주지 않는다는 것이다.

상태를 가진 시스템을 테스트하는 일반적인 접근 방식(구성 요소나 시스템 수준에서)은 시스템을 어떤 종류의 "깨끗한" 또는 "초기" (대부분 숨겨진) 상태로 시작하여, 테스트 입력을 사용해 원하는 테스트를 수행하고, 그런 다음 시스템이 — 숨겨진 내부 상태와 관계없이 — 해당 입력으로 테스트를 실행할 때마다 같은 방식으로 수행할 것이라는 (버그의 경우 종종 근거가 없는) 가정에 의존하는 것이다. 본질적으로 이 접근 방식은 단순히 상태 문제를 카펫 아래로 쓸어버리는 것이다.

이렇게 하는 이유는 첫째, 이 접근 방식으로 빠져나갈 수 있는 경우가 종종 있기 때문이고, 더 중요하게는 복잡한 내부 숨겨진 상태를 가진 상태 기반 시스템을 테스트할 때 실제로 다른 대안이 없기 때문이다.

물론 어려움은 항상 "빠져나갈 수 있는" 것은 아니라는 점이다 — 만약 어떤 이벤트(입력) 시퀀스가 시스템을 "나쁜 상태로 만들 수 있다면" (구체적으로 테스트가 수행된 상태와 다른 내부 숨겨진 상태) 문제가 생길 수 있고 실제로 생긴다. 이것이 이 섹션 시작 부분에서 논의한 가상의 지원 데스크 발신자에게 일어나고 있는 일이다. 제안된 해결책들은 모두 시스템을 "좋은 내부 상태"로 강제로 되돌리려는 시도들이다.

이 문제(한 상태에서의 테스트가 다른 상태에서의 시스템에 대해서는 전혀 알려주지 않는다는)는 위에서 논의한 테스팅의 근본적인 문제 중 하나와 직접적으로 평행하다 — 즉, 한 입력 집합에 대한 테스팅이 다른 입력 집합에서의 동작에 대해서는 전혀 알려주지 않는다는 것이다.

실제로 상태로 인한 문제는 일반적으로 더 나쁘다 — 특히 시스템의 큰 부분을 테스트할 때 — 단순히 가능한 입력의 수가 매우 클 수 있음에도 불구하고, 시스템이 있을 수 있는 가능한 상태의 수가 종종 더욱 크기 때문이다.

이 두 가지 유사한 문제 — 하나는 테스팅에 본질적이고, 다른 하나는 상태에서 비롯되는 — 가 끔찍하게 결합된다. 각각은 엄청난 양의 불확실성을 도입하며, 조사 대상인 시스템/구성 요소가 상태를 가진 성격이라면 우리가 확신할 수 있는 것은 거의 남지 않는다.

#### 4.1.2 상태가 비공식적 추론에 미치는 영향
시스템을 외부에서 이해하는 데 문제를 일으키는 것 외에도, 상태는 시스템의 예상 동작에 대해 "내부에서" (대부분 비공식적 기반으로) 추론을 시도해야 하는 개발자에게도 방해가 된다. 이러한 비공식적 추론을 수행하는 데 사용되는 정신적 과정은 종종 경우별 정신적 동작 시뮬레이션을 중심으로 한다: "이 변수가 이 상태에 있다면, 이것이 일어날 것이다 — 이는 올바르다 — 그렇지 않으면 저것이 일어날 것이다 — 이것도 올바르다".

상태의 수 — 따라서 고려해야 할 가능한 시나리오의 수 — 가 증가함에 따라, 이 정신적 접근법의 효과는 테스팅과 거의 같은 속도로 무너진다(동일하게 처리될 수 있는 유사한 값들의 집합에 대한 추상화를 통해 약간의 이점을 달성하기는 한다).

(테스팅과 추론 모두에 영향을 미치는) 문제 중 하나는 가능한 상태의 수가 증가하는 지수적 비율이다 — 우리가 추가하는 모든 단일 상태 비트에 대해 가능한 총 상태 수가 두 배가 된다. 또 다른 문제 — 비공식적 추론에 특별한 문제가 되는 — 는 오염(contamination)이다.

시스템이 절차들로 구성되어 있고, 그 중 일부는 상태를 가지고 다른 일부는 그렇지 않다고 생각해보자. 우리는 이미 상태를 가진 부분들을 이해하는 어려움을 논의했지만, 우리가 희망하는 것은 그 자체로 상태를 가지지 않는 절차들이 더 이해하기 쉬울 것이라는 점이다. 아쉽게도, 이는 대부분 그렇지 않다.

문제가 되는 절차(그 자체는 상태가 없는)가 상태를 가진 다른 절차를 — 심지어 간접적으로라도 — 사용한다면, 모든 것이 엉망이 되고, 우리 절차는 오염되며 상태의 맥락에서만 이해할 수 있게 된다. 다른 무엇을 시도한다면 위에서 논의한 모든 전형적인 상태 유래 문제들의 위험을 다시 감수하게 된다.

말했듯이, 상태의 문제는 "낙타의 코를 천막에 들여보내면, 나머지도 따라오는 경향이 있다"는 것이다.

위의 모든 이유로 인해 우리는 현대의 대부분 대규모 시스템에서 복잡성의 가장 큰 남은 원인이 상태라고 믿으며, 상태를 제한하고 관리하기 위해 할 수 있는 것이 많을수록 더 좋다고 생각한다.