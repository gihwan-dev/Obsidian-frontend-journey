## SQL 문장들의 종류

### 데이터 조작어(DML)
- SELECT: 조회하거나 검색하기 위한 명령어로 RETRIEVE 라고도 함
- INSERT
- UPDATE
- DELETE

### 데이터 정의어(DDL)
- CREATE
- ALTER
- DROP
- RENAME

### 데이터 제어어(DCL)
- GRANT
- REVOKE

### 트랜잭션 제어어(TCL)
- COMMIT
- ROLLABACK

### 비절차적 데이터 조작어 vs 절차적 데이터 조작어
#### 절차적 DML
- 어떻게 데이터를 가져올지 명시
- 데이터 접근 방법과 순서를 프로그래머가 직접 지정
- 예: C, COBOL 등에 내장된 저수준 데이터베이스 접근 코드
#### 비절차적 DML
- 무엇을 원하는지만 명시
- 데이터 접근 방법은 DMBS가 자동으로 최적화해서 결정
- 예: SQL(SELECT, INSERT, UPDATE, DELETE)

### 테이블 칼럼에 대한 정의 변경
- **Oracle**: `ALTER TABLE 테이블명 MODIFY (칼럼명1 데이터 유형 [DEFAULT 식] [NOT NULL], 칼럼명2 데이터 유형 ...);`
- **SQL Server**: `ALTER TABLE 테이블명 ALTER 칼럼명1 데이터 유형 [DEFAULT 식] [NOT NULL]`
	- 괄호 X
	- 여러개 칼럼 수정 불가

### Null의 의미
- 공백이나 숫자 0과는 전혀 다른 값이며, 조건에 맞는 데이터가 없을 때의 공집합과도 다름
- NULL은 아직 정의되지 않은 미지의 값 이거나 현재 데이터를 입력하지 못하는 경우를 의미함

### 제약 조건
- PK: UNIQUE + NOT NULL, 테이블 당 하나만 생성 가능
- NOT NULL: NULL 입력 방지
- UNIQUE: 중복되는 값 입력 불가
- FK: 외래키로 테이블 당 여러개 생성 가능

### 테이블 생성의 주의사항
- 테이블명은 객체를 의미할 수 있는 적절한 이름을 사용한다. 가능한 단수형을 권고
- 테이블 명은 다른 테이블의 이름과 중복되지 않아야 한다.
- 한 테이블 내에서는 칼럼명이 중복되게 지정될 수 없다.
- 테이블 이름을 지정하고 각 칼럼들은 괄호 "( )"로 묶어 지정한다.
- 각 칼럼들은 콤마 ","로 구분되고, 테이블 생성문의 끝은 항상 세미콜론 ";" 으로 끝난다.
- 칼럼에 대해서는 다른 테이블까지 고려해 데이터베이스 내에서는 일괁성 있게 사용하는 것이 좋다.
- 칼럼 뒤에 데이터 유형은 꼭 지정되어야 한다.
- 테이블명과 칼럼명은 반드시 문자로 시작해야 하고, 벤더별로 길이에 대한 한계가 있다.
- 사전 정의한 예약어는 쓸 수 없다.
- A-Z, a-z, 0-9, _, $, # 문자만 허용된다.

### 외래키
- 테이블 생성시 설정 가능
- 널 값을 가질 수 있음
- 한 테이블에 하나만 존재해야 함
- 외래키 값은 참조 무결성 제약을 받을 수 있음

### 테이블 불필요한 칼럼 삭제
- ALTER TABLE 테이블명 DROP COLUMN 삭제할 칼럼 

### 테이블 이름 변경
- **RENAME** _OLD_OBJECT_NAME_ **TO** _NEW_OBJECT_NAME_


### 테이블 FK 액션
#### Delete(/Modify) Action
1. Cascade: Master 삭제 시 Child 같이 삭제
2. Set Null: Master 삭제 시 Child 해당 필드 Null
3. Set Default: Master 삭제 시 Child 해당 필드 Default 값으로 설정
4. Restrict: Child 테이블에 PK 값이 없는 경우만 Master 삭제 허용
5. No Action: 참조무결성을 위반하는 삭제/수정 액션을 취하지 않음

#### Insert Action
1. Automatic: Master 테이블에 PK가 없는 경우 Master PK를 생성 후 Child 입력
2. Set Null: Master 테이블에 PK가 없는 경우 Child 외부키를 Null 값으로 처리
3. Set Default: Master 테이블에 PK가 없는 경우 Child 외부키를 지정된 기본값으로 입력
4. Dependent: Master 테이블에 PK가 존재할 때만 Child 입력 허용
5. No Action: 참조 무결성을 위반하는 입력 액션을 취하지 않음

### 테이블에 데이터를 입력하는 두 가지 유형
 1. INSERT INTO 테이블명 (COLUMN_LIST) VALUES (COLUMN_LIST에 넣을 VALUE_LIST);
 2. INSERT INTO 테이블명 VALUES (전체 COLUMN에 넣을 VALUE_LIST);

### 테이블에 입력된 데이터의 수정
- UPDATE 테이블명 SET 수정되어야 할 칼럼명 = 수정되기를 원하는 새로운 값;

### 테이블 삭제
- TRUNCATE TABLE 테이블명
- DROP TABLE 테이블명
- DELETE FROM 테이블명

TRUNCATE, DROP은 로그를 남기지 않음

**차이점**
![[Pasted image 20251110080154.png]]

### 테이블에 입력된 데이터 조회
- `SELECT [All /Distinct] 칼럼명1, 칼럼명2 FROM 테이블명;`
	- ALL: 옵션이므로 별도로 표기하지 않아도 됨. 중복된 데이터가 있어도 모두 표기.
	- DISTINCT: 중복된 데이터가 있는 경우 1건을 처리해서 출력

### 트랜잭션의 특성
- **원자성:** 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다. (all or nothing)
- **일관성:** 트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안 된다.
- **고립성:** 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안 된다.
- **지속성:** 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다.

### 트랜잭션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점
1. **Dirty Read:** 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터를 읽는 것
2. **Non - Repeatable Read:** 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상을 말함
3. **Phantom Read:** 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫번째 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상을 말함

### Oracle vs SQL Server DDL 수행 차이점
- Oracle 에서는 DDL 문장 수행 후 자동으로 COMMIT을 수행
- SQL Server에서는 DDL 문장 수행 후 자동으로 COMMIT하지 않음
- Oracle 에서는 DDL 문장의 수행은 내부적으로 트랜잭션을 종료 시킴
- SQL Server 에서는 CREATE TABLE 문장도 TRANSACTION의 범주에 포함됨.

### 트랜잭션 시작 종료
- BEGIN TRANSACTION(BEGIN TRAN 구문도 가능)으로 트랜잭션을 시작하고  COMMIT TRANSACTION(TRANSACTION은 생략 가능) 또는 ROLLBACK TRANSACTION(TRANSACTION 생략 가능)으로 트랜잭션을 종료한다.
- ROLLBACK 구문을 만나면 최초의 BEGIN TRANSACTION 시점까지 모두 ROLLBACK이 수행된다.

### 저장점(SAVEPOINT)
- 저장점(SAVEPOINT)을 정의하면 롤백(ROLLBACK) 할 때 트랜잭션에 포함된 전체 작업을 롤백하는 것이 아니라 현 시점에서 SAVEPOINT 까지 트랜잭션의 일부만 롤백할 수 있다
- Oracle
	- SAVEPOINT SVPT1;
	- ...
	- ROLLBACK TO SVPT1;
- SQL Server
	- SAVE TRANSACTION SVTR1;
	- ...
	- ROLLBACK TRANSACTION SVTR1;

### WHERE 절
- WHERE 절은 FROM 절 다음에 위치하며, 조건식은 아래 내용으로 구성됨
	- 칼럼명(보통 조건식의 좌측에 위치)
	- 비교 연산자
	- 문자, 숫자, 표현식(보통 조건식의 우측에 위치)
	- 비교 칼럼명(JOIN 사용시)

### 연산자의 우선순위
1. 괄호로 묶은 연산
2. 부정 연산자(NOT)
3. 비교 연산자
4. 논리 연산자(AND, OR 순으로 처리)

### NULL의 연산
- NULL 값과의 연산(`+, -, *, /` 등)은 NULL 값을 리턴
- NULL 값과의 비교연산 (`=, >, >=, <, <=`)은 `FALSE`를 리턴
- 특정 값보다 크다. 작다라고 표현할 수 없음

### 부정 비교 연산자
- `!=`: 같지 않다.
- `^=`: 같지 않다.
- `<>`: 같지 않다.
- `NOT 칼럼명 =` : ~와 같지 않다.
- `NOT 칼럼명 > `: ~ 보다 크지 않다.

### 공백 문자열 처리 방식
- Oracle에서는 공백 문자열을 NULL로 전환함. 그래서 공백 문자열 데이터를 조회하려면 NULL 조건으로 조회해야함.
- SQL Server에서는 공백 문자열이 그대로 들어감. 그래서 조회할 때 칼러명 = "" 으로 조회 해야함.

### 특정 값 바운더리에 포함되는지 확인하는 방법
- BETWEEN a AND b
- IN (list)

### CONCAT
- 문자열을 합치는 쿼리

### 내장 함수에 대한 설명
- 함수의 입력 행수에 따라 단일행 함수와 다중행 함수로 구분
- 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET 절에 사용이 가능하다.
- 1:M 관계의 두 테이블을 조인할 경우 M 쪽에 다중행이 출력되어도 단일행 함수를 사용할 수 있다.
- 단일행 함수 및 다중행 함수는 여러 개의 인수가 입력 되어도 단일 값만 반환한다.

- 함수는 벤더에서 제공하는 함수인 내장 함수와 사용자 정의 함수로 나눌 수 있음
- 내장 함수는 단일행 함수와 다중행 함수로 나눌 수 있음
- 다중행 함수는 집계 함수, 그룹 함수, 윈도우 함수로 구분됨

- LENGTH: 문자열의 길이를 반환하는 함수
- CHR: 주어진 ASCII 코드에 대한 문자를 반환하는 함수 (CHR(10) => 줄바꿈)
- REPLACE: 문자열을 치환하는 함수 (REPLACE(C1, CHR(10)) -> 줄바꿈 제거)

### 단일행 문자형 함수의 종류

| 문자형 함수(Oracle, SQL Server)                        | 함수 설명                                                                                                                                            |
| ------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| LOWER(문자열)                                        | 문자열의 알파벳 문자를 소문자로 바꾸어줌                                                                                                                           |
| UPPER(문자열)                                        | 문자열의 알파벳 문자를 대문자로 바꾸어줌                                                                                                                           |
| ASCII(문자)                                         | 문자나 숫자를 ASCII 코드 번호로 바꾸어줌                                                                                                                        |
| CHR(CHAR(ASCII 번호)                                | 문자나 숫자를 ASCII 코드 번호로 바꾸어줌                                                                                                                        |
| CONCAT(문자열1, 문자열2)                                | Oracle, My SQL 에서 유효한 함수, 문자열1과 문자열2를 연결함. 합성 연산자 '\|\|'(Oracle) 나 '+'(SQL Server)와 동일함                                                          |
| SUBSTR / SUBSTRING (문자열, m[, n])                  | 문자열 중 m위치에서 n개의 문자 길이에 해당하는 문자를 돌려준다. n이 생략되면 마지막 문자까지이다.                                                                                        |
| LENGTH / LEN(문자열)                                 | 문자열의 개수를 숫자값으로 돌려준다.                                                                                                                             |
| LTRIM (문자열, [, 지정 문자])                            | 문자열의 첫 문자부터 확인해서 지정 문자가 나타나면 해당 문자를 제거함(지정 문자가 생략되면 공백 값이 디폴트). SQL Server 에서는 LTRIM 함수에 지정문자를 사용할 수 없다. 즉, 공백만 제거할 수 있다.                        |
| RTRIM(문자열, [, 지정 문자])                             | 문자열의 마지막 문자부터 확인해서 지정 문자가 나타나는 동안 해당 문자를 제거한다(지정 문자가 생략되면 공백 값이 디폴트). SQL Server 에서는 LTRIM 함수에 지정문자를 사용할 수 없다. 즉, 공백만 제거할 수 있다.                  |
| TRIM([leading \| trailing \| both] 지정문자 FROM 문자열) | 문자열에서, 머리말, 꼬리말, 또는 양쪽에 있는 지정 문자를 제거한다. (leading \| trailing \| both  가 생략되면 both가 디폴트) SQL Server 에서는 TRIM 함수에 지정문자를 사용할 수 없다. 즉, 공백만 제거할 수 있다. |

### DUAL 테이블의 특성
- 사용자 SYS가 소유하며 모든 사용자가 액세스 가능한 테이블이다.
- SELECT ~ FROM ~ 의 형식을 갖추기 위한 일종의 DUMMY 테이블이다.
- DUMMY 라는 문자열 유형의 칼럼에 'X' 라는 값이 들어 있는 행을 1건 포함하고 있다.

### 단일행 함수의 종류

| 종류         | 내용                           | 함수의 예                                                                                                   |
| ---------- | ---------------------------- | ------------------------------------------------------------------------------------------------------- |
| 문자형 함수     | 문자를 입력하면 문자나 숫자 값을 반환한다.     | LOWER, UPPER, SUBSTR/SUBSTRING, LENGTH/LEN, LTRIM, RTRIM, TRIM, ASCII                                   |
| 숫자형 함수     | 숫자를 입력하면 숫자 값을 반환한다.         | ABS, MOD, ROUND, TRUNC, SIGN, CHR/CHAR, CEIL/CEILING, FLOOR, EXP, LOG, LN, POWER, SIN, COS, TAN         |
| 날짜형 함수     | DATE 타입의 값을 연산한다.            | SYSDATE/GETDATE, EXTRACT/DATEPART, TO_NUMBER(TO_CHAR(d, 'YYYY' \| 'MM' \| 'DD')) / YEAR \| MONTH \| DAY |
| 변환형 함수     | 문자, 숫자, 날짜형 값의 데이터 타입을 변환한다. | TO_NUMBER, TO_CHAR, TO_DATE / CAST, CONVERT                                                             |
| NULL 관련 함수 | NULL을 처리하기 위한 함수             | NVL/ISNULL, NULLIF, COALESCE                                                                            |

### CASE WHEN THEN
- if else와 비슷함

```sql
case 
	when 조건1 then 결과1
	when 조건2 then 결과2
	else 기본결과
end
```

### NULL의 특성
- 널 값은 아직 정의되지 않은 값으로 0 또는 공백과 다르다. 0은 숫자이고, 공백은 하나의 문자이다.
- 테이블을 생성할 때 NOT NULL 또는 PRIMARY KEY로 정의되지 않은 모든 데이터 유형은 널 값을 포함할 수 있다.
- 널 값을 포함하는 연산의 경우 결과 값도 널 값이다. 모르는 데이터에 숫자를 더하거나 빼도 결과는 마찬가지로 모르는 데이터인 것과 같다.
- 결과값을 NULL이 아닌 다른 값을 얻고자 할 때 NVL/ISNULL 함수를 사용한다. NULL 값의 대상이 숫자 유형 데이터인 경우는 주로 0(Zero)으로, 문자 유형 데이터인 경우는 블랭크보다는 'x' 같이 해당 시스템에서 의미 없는 문자로 바꾸는 경우가 많다.

### 단일행 NULL 관련 함수의 종류

| 일반형 함수                                 | 함수 설명                                                                                                 |
| -------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| `NVL(표현식1, 표현식2) / ISNULL(표현식1, 표현식2)` | 표현식1의 결과값이 NULL이면 표현식2의 값을 출력한다. 단, 표현식1과 표현식2의 결과 데이터 타입이 같아야 한다. NULL 관련 가장 많이 사용되는 함수이므로 상당히 중요하다. |
| `NULLIF(표현식1, 표현식2)`                   | 표현식1이 표현식2와 같으면 NULL을, 같지 않으면 표현식1을 리턴한다.                                                             |
| `COALESCE(표현식1, 표현식2, .....)`          | 임의의 개수 표현식에서 NULL이 아닌 최초의 표현식을 나타낸다. 모든 표현식이 NULL이라면 NULL을 리턴한다.                                      |

### 0으로 나누는 경우
에러가 발생

### NULL 값에 AVG 연산
- NULL 값인 행은 AVG 연산 대상에서 제외됨

### 집계 함수의 종류

| 집계 함수                          | 사용 목적                                    |
| ------------------------------ | ---------------------------------------- |
| `COUNT(*)`                     | NULL 값을 포함한 행의 수를 출력한다.                  |
| `COUNT(표현식)`                   | 표현식의 값이 NULL 값인 것을 제외한 행의 수를 출력한다.       |
| `SUM([DISTINCT / ALL] 표현식)`    | 표현식의 NULL 값을 제외한 합계를 출력한다.               |
| `AVG([DISTINCT / ALL] 표현식)`    | 표현식의 NULL 값을 제외한 평균을 출력한다.               |
| `MAX([DISTINCT / ALL] 표현식)`    | 표현식의 최대값을 출력한다.<br>(문자, 날짜 데이터 타입도 사용가능) |
| `MIN([DISTINCT / ALL] 표현식)`    | 표현식의 최소값을 출력한다.<br>(문자, 날짜 데이터 타입도 사용가능) |
| `STDDEV([DISTINCT / ALL] 표현식)` | 표현식의 표준 편차를 출력한다.                        |
| `VARIAN([DISTINCT / ALL] 표현식)` | 표현식의 분산을 출력한다.                           |

> [!Note]
> **분산**: 데이터가 평균으로부터 얼마나 떨어져 있는지를 나타내는 지표
> **표준 편차**: 분산의 제곱근

### GROUP BY 절과 HAVING 절의 특성
- GROUP BY 절을 통해 소그룹별 기준을 정한 후, SELECT 절에 집계 함수를 사용한다.
- 집계 함수의 통계 정보는 NULL 값을 가진 행을 제외하고 수행한다.
- GROUP BY 절에서는 SELECT 절과는 달리 ALIAS 명을 사용할 수 없다.
- 집계 함수는 WHERE 절에는 올 수 없다.
	- 집계 함수를 사용할 수 있는 GROUP BY 절보다 WHERE 절이 먼저 수행된다.
- WHERE 절은 GROUP BY 절의 기준 항목이나 소그룹의 집계 함수를 이용한 조건을 표시할 수 있다.
- GROUP BY 절에 의한 소그룹별로 만들어진 집계 데이터 중, HAVING 절에서 제한 조건을 두어 조건을 만족하는 내용만 출력한다.
- HAVING 절은 일반적으로 GROUP BY 절 뒤에 위치한다.
- 중첩된 그룹함수의 경우 최종 결과값은 1건이 될 수 밖에 없다.