### 순수 관계 연산자와 SQL 문장 비교
**순수 관계 연산자란?**

**SELECT(선택), PROJECT(투영), JOIN(조인), DIVISION(나눗셈)** - 관계형 DB에만 있는 고유 연산자로, 일반 집합 연산자(합/교/차집합)와 구분됨

- SELECT 연산은 WHERE 절로 구현
- PROJECT 연산은 SELECT 절로 구현
- (NATURAL) JOIN 연산은 다양한 JOIN 기능으로 구현
- DIVIDE 연산은 현재 사용되지 않음

### JOIN 의 종류
- `INNER JOIN`: 교집합
- `LEFT JOIN`: 왼쪽 테이블 전부 + 오른쪽 매칭 되는 것
- `RIGHT JOIN`: 오른쪽 테이블 전부 + 왼쪽 매칭되는 것
- `FULL OUTER JOIN`: 양쪽 전부 다

> 참고로 `RIGHT JOIN` === `RIGHT OUTER JOIN`

### 카티시안 곱(Cartesian Product)
두 테이블을 Join 조건 없이 결합하면, 한 쪽 테이블의 모든 행과 다른쪽 테이블의 모든 행이 조합되는 현상

### USING
JOINT시 양 쪽 테이블에 동일한 이름의 칼럼이 있을 때 사용할 수 있는 문법

- `USING T.STADIUM_ID = S>STADIUM_ID` 같은 문법 사용할 수 없음
- `USING(STADIUM_ID)` = 같은 경우 테이블 명 접두사를 붙일 수 없음
	- `T.STADIUM_ID` 같은거는 안됨. `STADIUM_ID`로 써야함.

### CROSS JOIN
테이블 간 JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합을 말함. 결과는 양쪽 `M * N` 건의 데이터 조합이 발생함.


### ON 에서 IN 사용시
모든 행에 대해서 출력을 하되 JOIN 대상을 제한해 해당하지 않는 값에 NULL이 할당됨

### BETWEEN
`BETWEEN 1 AND 3` 은 1, 2, 3 즉 시작과 끝 값 모두 포함


### NOT EXISTS
`NOT EXISTS (구문)`: 구문에서 반환된 행이 1개 이상이면 TRUE를 아니면 FALSE를 반환함

### 집합 연산자의 종류

| 집합 연산자      | 연산자의 의미                                                                                                                                              |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| `UNION`     | 여러 개의 SQL문의 결과에 대한 합집합으로 결과에서 모든 중복된 행은 하나의 행으로 만든다.                                                                                                 |
| `UNION ALL` | 여러 개의 SQL문의 결과에 대한 합집합으로 중복된 행도 그대로 결과로 표시된다. 즉, 단순히 결과만 합쳐놓은 것이다. 일반적으로 여러 질의 결과가 상호 배타적일 떄 많이 사용한다. 개별 SQL문의 결과가 서로 중복되지 않는 경우, `UNION`과 결과가 동일하다. |
| `INTERSECT` | 여러 개의 SQL문의 결과에 대한 교집합니다. 중복된 행은 하나의 행으로 만든다.                                                                                                        |
| `EXCEPT`    | 앞의 SQL문의 결과에서 뒤의 SQL문의 결과에 대한 차집합니다. 중복된 행은 하나의 행으로 만든다.                                                                                             |

### ORDER BY 1, 2
`SELECT A, B FROM 테이블 ORDER BY 1, 2`: `SELECT`절에 나열된 칼럼(`A`, `B`)의 위치를 기준으로 정렬하는 방식

### PRIOR
`CONNECT BY` 절에서 사용되며, 현재 읽은 칼럼을 지정한다. `PRIOR 자식 = 부모` 형태를 사용하면 계층구조에서 부모 데이터에서 자식 데이터(부모 -> 자식) 방향으로 전개하는 순방향 전개를 한다. 그리고 `PRIOR 부모 = 자식` 형태를 사용하면 반대로 자식 데이터에서 부모 데이터(자식 -> 부모) 방향으로 전개하는 역방향 전개를 한다.

### 계층형 질의
- `START WITH` 절은 계층 구조 전개의 시작 위치를 지정하는 구문이다. 즉, 루트 데이터를 지정한다.
- ORDER SIBLINGS BY` 절은 형제 노드 사이에서 정렬을 수행한다.
- 순방향전개란 부모 노드로부터 자식 노드 방향으로 전개하는 것을 말한다.
- 루트 노드의 LEVEL 값은 1이다.
- SQL Server에서의 계층형 질의문은 CTE를 재귀 호출함으로써 계층 구조를 전개한다.
- SQL Server에서의 계층형 질의문은 앵커 멤버를 실행해 기본 결과 집합을 만들고 이후 재귀 멤버를 지속적으로 실행한다.
- 오라클의 계층형 질의문에서 WHERE 절은 모든 전개를 진행한 이후 필터 조건으로서 조건을 만족하는 데이터만을 추출하는데 활용된다.
- 오라클의 PRIOR 키워드는 SELECT, WHERE 절에서도 사용할 수 있다.

### START WITH과 CONNECT BY PRIOR 동작 방식
**START WITH**: 계층 구조의 **시작점(루트)**을 정의
- 어디서부터 탐색을 시작할지 지정
- 조건을 만족하는 모든 행이 루트 노드가 됨

**CONNECT BY**: 부모-자식 관계를 정의
- 현재 행과 다음 행을 어떻게 연결할지 지정
- `PRIOR` 키워드로 방향 결정 (하향식 vs 상향식)

#### PRIOR 키워드의 위치가 중요
```sql
-- 하향식 탐색 (부모 → 자식)
CONNECT BY PRIOR child_col = parent_col
-- "이전(PRIOR) 행의 child_col = 현재 행의 parent_col"

-- 상향식 탐색 (자식 → 부모)  
CONNECT BY child_col = PRIOR parent_col
-- "현재 행의 child_col = 이전(PRIOR) 행의 parent_col"
```

