### 순수 관계 연산자와 SQL 문장 비교
**순수 관계 연산자란?**

**SELECT(선택), PROJECT(투영), JOIN(조인), DIVISION(나눗셈)** - 관계형 DB에만 있는 고유 연산자로, 일반 집합 연산자(합/교/차집합)와 구분됨

- SELECT 연산은 WHERE 절로 구현
- PROJECT 연산은 SELECT 절로 구현
- (NATURAL) JOIN 연산은 다양한 JOIN 기능으로 구현
- DIVIDE 연산은 현재 사용되지 않음

### JOIN 의 종류
- `INNER JOIN`: 교집합
- `LEFT JOIN`: 왼쪽 테이블 전부 + 오른쪽 매칭 되는 것
- `RIGHT JOIN`: 오른쪽 테이블 전부 + 왼쪽 매칭되는 것
- `FULL OUTER JOIN`: 양쪽 전부 다

> 참고로 `RIGHT JOIN` === `RIGHT OUTER JOIN`

### 카티시안 곱(Cartesian Product)
두 테이블을 Join 조건 없이 결합하면, 한 쪽 테이블의 모든 행과 다른쪽 테이블의 모든 행이 조합되는 현상

### USING
JOINT시 양 쪽 테이블에 동일한 이름의 칼럼이 있을 때 사용할 수 있는 문법

- `USING T.STADIUM_ID = S>STADIUM_ID` 같은 문법 사용할 수 없음
- `USING(STADIUM_ID)` = 같은 경우 테이블 명 접두사를 붙일 수 없음
	- `T.STADIUM_ID` 같은거는 안됨. `STADIUM_ID`로 써야함.

### CROSS JOIN
테이블 간 JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합을 말함. 결과는 양쪽 `M * N` 건의 데이터 조합이 발생함.


### ON 에서 IN 사용시
모든 행에 대해서 출력을 하되 JOIN 대상을 제한해 해당하지 않는 값에 NULL이 할당됨

### BETWEEN
`BETWEEN 1 AND 3` 은 1, 2, 3 즉 시작과 끝 값 모두 포함


### NOT EXISTS
`NOT EXISTS (구문)`: 구문에서 반환된 행이 1개 이상이면 TRUE를 아니면 FALSE를 반환함

### 집합 연산자의 종류

| 집합 연산자      | 연산자의 의미                                                                                                                                              |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| `UNION`     | 여러 개의 SQL문의 결과에 대한 합집합으로 결과에서 모든 중복된 행은 하나의 행으로 만든다.                                                                                                 |
| `UNION ALL` | 여러 개의 SQL문의 결과에 대한 합집합으로 중복된 행도 그대로 결과로 표시된다. 즉, 단순히 결과만 합쳐놓은 것이다. 일반적으로 여러 질의 결과가 상호 배타적일 떄 많이 사용한다. 개별 SQL문의 결과가 서로 중복되지 않는 경우, `UNION`과 결과가 동일하다. |
| `INTERSECT` | 여러 개의 SQL문의 결과에 대한 교집합니다. 중복된 행은 하나의 행으로 만든다.                                                                                                        |
| `EXCEPT`    | 앞의 SQL문의 결과에서 뒤의 SQL문의 결과에 대한 차집합니다. 중복된 행은 하나의 행으로 만든다.                                                                                             |

### ORDER BY 1, 2
`SELECT A, B FROM 테이블 ORDER BY 1, 2`: `SELECT`절에 나열된 칼럼(`A`, `B`)의 위치를 기준으로 정렬하는 방식

### PRIOR
`CONNECT BY` 절에서 사용되며, 현재 읽은 칼럼을 지정한다. `PRIOR 자식 = 부모` 형태를 사용하면 계층구조에서 부모 데이터에서 자식 데이터(부모 -> 자식) 방향으로 전개하는 순방향 전개를 한다. 그리고 `PRIOR 부모 = 자식` 형태를 사용하면 반대로 자식 데이터에서 부모 데이터(자식 -> 부모) 방향으로 전개하는 역방향 전개를 한다.

### 계층형 질의
- `START WITH` 절은 계층 구조 전개의 시작 위치를 지정하는 구문이다. 즉, 루트 데이터를 지정한다.
- ORDER SIBLINGS BY` 절은 형제 노드 사이에서 정렬을 수행한다.
- 순방향전개란 부모 노드로부터 자식 노드 방향으로 전개하는 것을 말한다.
- 루트 노드의 LEVEL 값은 1이다.
- SQL Server에서의 계층형 질의문은 CTE를 재귀 호출함으로써 계층 구조를 전개한다.
- SQL Server에서의 계층형 질의문은 앵커 멤버를 실행해 기본 결과 집합을 만들고 이후 재귀 멤버를 지속적으로 실행한다.
- 오라클의 계층형 질의문에서 WHERE 절은 모든 전개를 진행한 이후 필터 조건으로서 조건을 만족하는 데이터만을 추출하는데 활용된다.
- 오라클의 PRIOR 키워드는 SELECT, WHERE 절에서도 사용할 수 있다.

### START WITH과 CONNECT BY PRIOR 동작 방식
**START WITH**: 계층 구조의 **시작점(루트)**을 정의
- 어디서부터 탐색을 시작할지 지정
- 조건을 만족하는 모든 행이 루트 노드가 됨

**CONNECT BY**: 부모-자식 관계를 정의
- 현재 행과 다음 행을 어떻게 연결할지 지정
- `PRIOR` 키워드로 방향 결정 (하향식 vs 상향식)

#### PRIOR 키워드의 위치가 중요
```sql
-- 하향식 탐색 (부모 → 자식)
CONNECT BY PRIOR child_col = parent_col
-- "이전(PRIOR) 행의 child_col = 현재 행의 parent_col"

-- 상향식 탐색 (자식 → 부모)  
CONNECT BY child_col = PRIOR parent_col
-- "현재 행의 child_col = 이전(PRIOR) 행의 parent_col"
```

### SELF JOIN
- 동일 테이블 사이의 조인을 말함
- FROM 절에 동일 테이블이 두 번 이상 나타남
- 동일 테이블 사이의 조인을 수행하면 테이블과 칼럼 이름이 모두 동일하기 때문에 식별을 위해 반드시 테이블 별칭을 사용

```sql
SELECT
	ALIAS명1.칼럼명,
	ALIAS명2.칼럼명,
	...
FROM
	테이블 ALLIAS명1
	테이블 ALIAS명2
WHERE
	ALIAS명1.칼럼명2 = ALIAS명2.칼럼명1;
```

한 테이블 내에서 두 칼럼이 연관 관계가 있을 경우 사용한다.

### 칼럼에서 `||`을 사용하면
문자열 연결 연산임

```sql
SELECT COUNT(DISTINCT A || B)
```

위 쿼리는:
1. **A 컬럼과 B 컬럼의 값을 문자열로 결합**
2. 결합된 값들 중 **중복을 제거(DISTINCT)**
3. **고유한 조합의 개수를 센다(COUNT)**

### 메인 쿼리와 서브 쿼리

| 서브쿼리 종류                       | 설명                                                                                                         |
| ----------------------------- | ---------------------------------------------------------------------------------------------------------- |
| Single Row 서브쿼리(단일 행 서브쿼리)    | 서브쿼리의 실행 결과가 항상 1건 이하인 서브쿼리를 의미한다. 단일 행 서브쿼리는 단일 행 비교 연산자와 함계 사용된다. 단일 행 비교 연산자에는 =, <, <=, >=, <>이 있다.    |
| Multi Row 서브쿼리(다중 행 서브쿼리)     | 서브쿼리의 실행 결과가 여러 건인 서브쿼리를 의미한다. 행 서브쿼리는 다중 행 비교 연산자와 함께 사용된다. 다중 행 비교 연산자에는 IN, ALL, ANY, SOME, EXISTS가 있다. |
| Multi Column 서브쿼리(다중 칼럼 서브쿼리) | 서브쿼리의 실행 결과로 여러 칼럼을 반환한다. 메인쿼리의 조건절에 여러 칼럼을 동시에 비교할 수 있다. 서브쿼리와 메인쿼리에서 비교하고자 하는 칼럼 개수와 칼럼의 위치가 동일해야 한다.    |
#### 서브쿼리를 사용시 주의사항
1. 서브쿼리를 괄호로 감싸서 사용한다.
2. 서브쿼리는 단일행 또는 복수행 비교 연산자와 함께 사용 가능하다. 단일 행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하이어야 하고 복수행 비교 연산자는 서브쿼리의 결과 건수와 상관없다.
3. 서브쿼리에서는 ORDER BY를 사용하지 못한다. ORDER BY 절은 SELECT 절에서 오직 한 개만 올 수 있기 때문에 ORDER BY 절은 메인쿼리의 마지막 문장에 위치해야 한다.
4. 다중 행 서브쿼리 비교 연산자는 단일 행 서브쿼리의 비교 연산자로도 사용할 수 있따.

### COUNT
COUNT 내부에서 case when then 을 사용할 때 NULL 이 반환되면 갯수가 카운트 되지 않고 아니라면 어떤 값이든 갯수가 카운트 됨

### 인라인 뷰
FROM 절에서 사용되는 서브쿼리를 인라인 뷰라고 한다. 서브쿼리의 결과가 마치 실행 시에 동적으로 생성된 테이블인 것처럼 사용할 수 있다. 인라인 뷰는 SQL문이 실행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에 데이터베이스에 해당 정보가 저장되지 않는다. 서브쿼리의 결과가 마치 실행 시에 동적으로 생성된 테이블인 것처럼 사용할 수 있다. 인라인 뷰는 SQL 문이 실행될 때만 임시적으로 생성되는 동적인 뷰이기 때문에 데이터베이스에 해당 정보가 저장되지 않는다.

### 뷰란
하나 이상의 테이블에서 가져온 데이터를 보여주는 가상 테이블이다. 실제로 데이터를 저장하지 않고, SELECT 퀴르를 저장해 놓은 객체이다.

### 뷰 사용의 장점
- **독립성:** 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다.
- **편리성:** 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성할 수 있다. 또한 해당 형태의 SQL 문을 자주 사용할 때 뷰를 이용하면 편리하게 사용할 수 있다.
- **보안성:** 직원의 급여정보와 같이 숨기고 싶은 정보가 존재한다면, 뷰를 생성할 때 해당 칼럼을 빼고 생성함으로써 사용자에게 정보를 감출 수 있다.

### GROUPING
**GROUPING 함수**는 `GROUP BY ROLLUP`, `CUBE`, `GROUPING SETS`와 함께 사용되는 특수 함수로, **집계 레벨을 구분**하기 위해 사용됩니다.

GROUPING 함수는 다음 값을 반환합니다:
- **0**: 해당 컬럼이 GROUP BY에 참여 (일반 그룹)
- **1**: 해당 컬럼이 NULL로 집계됨 (상위 집계 레벨

#### 1. **일반 그룹 (GROUPING = 0)**
- 실제 데이터값으로 그룹화된 일반적인 행
- 예: "MFO + 서울" 조합의 실제 데이터
- 원본 테이블에 존재하는 값들의 조합

#### 2. **상위 집계 레벨 (GROUPING = 1)**
- ROLLUP/CUBE가 **자동으로 생성한 소계나 총계**
- 해당 컬럼을 "무시하고" 집계한 결과
- NULL은 실제 NULL 값이 아니라 "전체"를 의미

|구분|ROLLUP|CUBE|
|---|---|---|
|**집계 방식**|계층적 (왼쪽→오른쪽)|모든 조합|
|**생성 그룹 수**|n+1개|2^n개|
|**사용 시나리오**|시간/조직 계층|다차원 분석|
|**성능**|상대적으로 빠름|많은 조합으로 느림|

- GROUPING SETS을  사용하게 되면 계층구조 각각 생성함
- 일반 그룹 함수를 사용해 CUBE, GROUPING SETS와 같은 그룹 함수와 동일한 결과를 추출할 수 있음
- GROUPING SETS 함수의 경우 함수의 인자로 주어진 칼럼의 순서에 따라 결과가 달라지지 않음. ROLLUP의 경우 순서에 따라 결과가 달라짐
- CUBE, ROLLUP, GROUPING SETS 함수들의 대상 칼럼 중 집계된 칼럼 이외의 대상 칼럼 값은 NULL을 반환함
- CUBE 그룹 함수는 인자로 주어진 칼럼의 결합 가능한 모든 조합에 대해서 집계를 수행하므로 다른 그룹 함수에 비해 시스템에 대한 부하가 큼

### GROUPING과 INNER JOIN
- 유효한 값만 남기기 위해서 사용하곤 함


### 윈도우 함수
SQL 윈도우 함수는 **행들의 집합에 대해 계산을 수행하면서도 원본 행들을 그대로 유지**하는 함수입니다. 일반 집계 함수(GROUP BY)와 달리 행이 합쳐지지 않아서, 각 행마다 집계 결과를 함께 볼 수 있다는 게 가장 큰 특징이죠.

**기본 구조**는 `함수명() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE ...)`입니다. PARTITION BY로 계산 범위를 나누고, ORDER BY로 정렬 기준을 정하며, ROWS/RANGE로 윈도우 프레임(계산할 행의 범위)을 지정할 수 있습니다.

**주요 종류**를 보면, 먼저 집계 윈도우 함수가 있습니다. SUM, AVG, COUNT, MAX, MIN 같은 것들을 윈도우 함수로 사용할 수 있어요. 예를 들어 각 부서별 평균 급여를 모든 직원 행에 함께 표시할 수 있습니다.

순위 함수도 자주 쓰이는데, ROW_NUMBER는 단순 순번, RANK는 동점일 때 순위를 건너뛰고, DENSE_RANK는 건너뛰지 않습니다. NTILE은 데이터를 N개 그룹으로 나눌 때 유용하죠.

값 접근 함수인 LAG/LEAD는 이전/다음 행의 값을 가져오고, FIRST_VALUE/LAST_VALUE는 윈도우 내 첫/마지막 값을 가져옵니다. 시계열 데이터에서 전월 대비 증감을 계산할 때 특히 유용합니다.
### RANK
RANK 함수는 ORDER BY를 포함한 QUERY 문에서 특정 항목(칼럼)에 대한 순위를 구하는 함수이며 동일한 값에 대해서는 동일한 순위를 부여하게 됨

- **RANK**: 동점일 때 같은 순위, 다음 순위는 건너뜀 (1,1,3,4...)
- **DENSE_RANK**: 동점일 때 같은 순위, 다음 순위 연속 (1,1,2,3...)
- **ROW_NUMBER**: 무조건 고유 순번 (1,2,3,4...)