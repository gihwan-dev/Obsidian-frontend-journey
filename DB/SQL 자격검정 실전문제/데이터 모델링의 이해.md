### 발생 시점에 따른 엔터티 분류
#### 1. 기본 / 키 엔터티 (Fundamental / Key Entitiy)
**독립적으로 먼저 존재하는 엔터티**
- 다른 엔터티의 부모 역할
- 업무 수행 시 가장 먼저 생성됨
- 다른 엔터티에 의존하지 않음

#### 2. 중심 엔터티 (Main Entity)
**기본 엔터티로부터 발생하고, 행위 엔터티를 생성하는 중간 엔터티**
- 기본 텐터티와 행위 엔터티 사이의 다리 역할
- 업무의 중심이 되는 데이터

#### 3. 행위 엔터티 (Action / Transaction Entity)
**실제 행위나 거래가 발생해 생성되는 엔터티**
- 시간의 흐름에 따라 계속 발생
- 통계 / 이력 데이터의 주요 소스
- 가장 많은 데이터가 누적됨

### 데이터 모델링의 3대 특징
- **추상화**: 현실 세계를 일정한 형식으로 표현
- **단순화**: 복잡한 현실을 이해하기 쉽게 표현
- **명확화**: 애매모호함을 배제하고 정확하게 표현

### 데이터 모델링이란
- 정보 시스템을 구축하기 위한 데이터 관점의 업무 분석 기법
- 현실세계의 데이터에 대해 약속된 표기법에 의해 표현하는 방법
- 데이터베이스를 구축하기 위한 분석/설계의 과정

### 데이터 모델링 유의점
##### 1. 중복
**동일한 데이터가 여로 곳에 저정되는 것**
데이터 불일치 가능성, 저장공간 낭비, 수정 시 여러 곳을 변경해야 함

##### 2. 비유연성
**데이터 구조가 업무 변화에 대응하기 어려운 것**
요구사항 변경 시 데이터 구조 전체를 수정해야 하는 경우 발생

##### 3. 비일관성
**데이터의 정합성이 깨지는 것**
같은 의미의 데이터가 다른 값으로 저장되어 신뢰성 저하

### 데이터 모델링 개념
##### 개념적 데이터 모델링
추상화 수준이 높고 업무중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링, EA수립시 많이 이용

##### 논리적 데이터 모델링
시스템으로 구축하고자 하는 업무에 대해 Key, 속성, 관계 등을 정확하게 표현, 재사용성이 높음

##### 물리적 데이터 모델링
실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려해 설계


### 데이터베이스 스키마 구조 3단계
##### 1. 외부 스키마
사용자나 애플리케이션이 실제로 보는 데이터의 형태
- 각 사용자 그룹마다 다른 뷰를 제공
- 필요한 데이터만 선택적으로 노출
- 보안과 권한 관리의 첫 번째 계층
##### 2. 개념 스키마
데이터베이스 전체의 논리적 구조
- 테이블, 칼럼, 관계(FK), 제약조건 등을 정의
- 물리적 저장 방식과 독립적
- 데이터베이스 전체의 "설계도"

##### 3. 내부 스키마
데이터가 실제로 디스크에 저장되는 물리적 방식
- 인덱스 구조(B-Tree, Bitmap 등)
- 데이터 블록, 익스텐트, 세그먼트 할당
- 파일 시스템 상의 데이터 파일 위치

### ERD 표기법
1976년 피터첸에 의해 Entity - Relationship Model(E-R Model) 이라는 표기법이 만들어졌다.

![[Pasted image 20251104082352.png]]
위 이미지 표기법은 `Crow's Foot Notation`을 사용. 데이터베이스 모델링에서 가장 많이 쓰이는 방식

##### 카디널리티 표기
선의 끝 모양으로 관계의 수를 나타냄
```
─────| → 1 (정확히 하나) 
─────< → N (여러 개, Crow's Foot) 
─────O → 0 또는 1 (선택적) 
─────O< → 0 또는 N (선택적, 여러 개)
```

이미지를 분석하면, 고객은 반드시 정확히 하나가 존재하며 주문은 선택적이며 여러개 존재할 수 있다.

### ERD 작성 순서
1. 엔터티를 그린다.
2. 엔터티를 적절하게 배치한다.
3. 엔터티간 관계를 설정한다.
4. 관계명을 기술한다.
5. 관계의 참여도를 기술한다.
6. 관계의 필수여부를 기술한다.

---
### 엔터티의 특징
- 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다.
- 유일한 식별자에 의해 실별이 가능해야 한다.
- 영속적으로 존재하는 인스턴스의 집합이어야 한다.
- 엔터티는 업무 프로세스에 의해 이용되어야 한다.
- 엔터티는 반드시 속성이 있어야 한다.
- 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다.

### 엔티티의 이름을 부여하는 방법
- 현업의 업무 용어를 사용해 업무상의 의미를 분명하게 해야함
- 모든 엔터티에서 유일한 이름이 부여되어야 함
- 엔터티가 생성되는 의미대로 자연스럽게 부여해야 함
- 가능하면 약어를 사용하지 않아야함

### 데이터 모델링 용어 정리
- 엔터티: 업무에서 관리해야 하는 정보의 집합
	- 예: 사원, 부서, 고객, 주문
- 인스턴스: 엔터티의 개별 발생 건 (실제 데이터 행)
	- 예: "홍길동" 사원 한 명의 레코드
- 속성: 엔터티를 구성하는 항목, 더 이상 분리되지 않는 최소 데이터 단위
	- 예: 사원번호, 사원명, 생년월일, 부서 코드
- 관계: 엔터티 간의 연관성
	- 예: 사원은 부서에 소속된다

### 엔터티, 인스턴스, 속성, 속성값의 관계
- 한 개의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다
- 한 개의 엔터티는 두 개 이상의 속성을 갖는다
- 한 개의 속성은 한 개의 속성값을 갖는다

### 속성의 특성에 따른 분류
##### 기본 속성
- 업무로부터 추출한 본래의 속성
- 가장 일반적이고 많이 사용되는 속성
- 외부에서 입력되거나 수집된 실제 데이터
- 예시:
	- 고객명, 주민등록번호, 주소, 전화번호
	- 주문일자, 상품명, 단가, 수량

##### 설계 속성
- 업무에 존재하지 않지만 시스템 구현을 위해 설계자가 인위적으로 만든 속성
- 주로 관리나 시스템 운영을 위한 목적
- 예시:
	- 일련번호, 등록일시, 등록자 ID
	- 수정일시, 수정자 ID
	- 삭제여부, 사용여부

##### 파생 속성
- 다른 속성들로부터 계산되거나 변환되어 생성되는 속성
- 저장하지 않고 조회시 계산할 수 있고, 성능을 위해 미리 계산해서 저장할 수도 있음
- 예시:
	- 합계 금액 = 단가 x 수량
	- 나이 = 현재년도 - 생년월일
	- 재고수량 = 입고수량 - 출고수량


### 도메인이란
각 속성은 가질 수 있는 값의 범위가 있는데 이를 그 속성의 **도메인** 이라하며, 엔터티 내에서 속성에 대한 데이터타입과 크기 그리고 제약사항을 지정하는 것이다.

> [!Note] 도메인의 사전적 의미
> 라틴어 "dominium" (지배, 소유)에서 유래해서 프랑스어 "domaine"을 거쳐 영어로 정착함
> 
> **사전적 의미**
> - 영역, 범위, 구역
> - 지배권, 관할권이 미치는 범위
> - 특정한 활동이나 지식의 분야
>   
> 결국 **domain** = **"특정한 경계 안의 영역/범위"** 라는 공통된 의미를 가지고 있음

### 속성의 명칭 부여
- 해당업무에서 사용하는 이름을 부여 한다
- 서술식 속성명은 사용하지 않는다
- 약어사용은 가급적 제한한다
- 전체 데이터모델에서 유일성 확보하는 것이 좋다

### ERD 다이어그램과 클래스 다이어그램의 차이
ERD에서는 존재적 관계와 행위에 의한 관계를 구분하지 않지만 클래스다이어그램 에서는 이것을 구분해 연관관계와 의존관계로 표현한다.

관계의 표기법은 관계명, 관계차수, 선택성 3가지 개념을 사용한다.

##### 존재적 관계
**"~이다", "~을 가진다"의 관계 - 데이터의 구조적 연결**
```text
사원 --- 소속 --- 부서
(사원은 부서에 소속된다)

주문 --- 포함 --- 주문상세
(주문은 주문상세를 가진다)
```

**특징:**
- 데이터베이스에 실제로 **저장되는 관계**
- Foreign Key로 표현
- 항상 존재하는 구조적 관계
- 시간이 지나도 변하지 않는 고정적 연결

##### 행위에 의한 관계
**"~한다", "~을 실행한다"의 관계 - 프로세스 / 작업 중심**
```text
고객 --- 주문한다 --- 상품
(고객이 상품을 주문하는 행위)

직원 --- 승인한다 --- 휴가신청
(직원이 휴가신청을 승인하는 행위)
```

**특징:**
- **일시적인 행위나 프로세스**
- 메서드 호출이나 임시 참조로 표현
- 특정 시점에만 발생
- 데이터로 저장되지 않을 수도 있음
##### 연관관계 vs 의존관계

**연관관계 (Association)** - 실선 ━

```java
class 사원 {
    private 부서 dept;  // 멤버 변수로 보유
}
```

- 객체를 멤버 변수로 **계속 보유**
- 강한 결합

**의존관계 (Dependency)** - 점선 ┄

```java
class 주문서비스 {
    public void 처리(결제시스템 payment) {  // 파라미터로만 사용
        payment.승인();
    }
}
```

- 메서드 파라미터나 지역 변수로만 **임시 사용**
- 약한 결합
##### 핵심 차이
**ERD**:
- 모든 관계를 똑같이 실선으로 표현
- "데이터를 어떻게 저장하나?"

**클래스 다이어그램**:
- 연관(━)과 의존(┄)을 구분
- "객체들이 얼마나 강하게 결합되어 있나?"

**한 줄 정리**:

- **연관** = 멤버 변수 (계속 가지고 있음)
- **의존** = 파라미터 (필요할 때만 사용)

### 두 개의 엔터티 사이에 정의한 관계를 체크하는 사항
- 두 개의 엔터티 사이에 관심 있는 연관규칙이 존재하는가
- 두 개의 언테티 사이에 정보의 조합이 발생되는가
- 업무기술서, 장표에 관계연결을 가능하게 하는 명사가 있는가
- 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가

### 관계 읽기
- 기준 엔터티를 한 개 또는 각으로 읽는다
- 대상 엔터티의 관계참여도 즉 개수(하나, 하나 이상)를 읽는다
- 관계선택사양과 관계명을 읽는다

### 식별자의 종류
- 엔터티 내에서 대표성을 가지는가에 따라 주식별자와 보조식별자로 구분
- 엔터티 내에서 스스로 생성되었는지 여부에 따라 내부식별자와 외부식별자로 구분
- 단일 속성으로 식별이 되는가에 따라 단일식별자와 복합식별자로 구분
- 원래 업무적으로 의미가 있던 식별자 속성을 대체하여 일련번호와 같이 새롭게 만든 식별자를 구분하기 위해 본질식별자와 인조식별자로 구분

### 주식별자의 특징
- 유일성: 주식별자에 의해 엔터티내에 모든 인스턴스들을 유일하게 구분
- 최소성: 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
- 불변성: 주식별자가 한 번 특정 엔터티에 지정되면 그 식별자의 값은 변하지 않아야 함
- 존재성: 주식별자가 지정되면 반드시 데이터 값이 존재

