데이터베이스에서 **커서(Cursor)**는 **SQL 문을 실행하기 위한 메모리 작업 영역**이에요. SQL 문 하나당 하나의 커서가 필요하다고 생각하면 돼요.

## 커서의 생명주기 (Parse → Execute → Fetch)

커서는 크게 세 단계를 거쳐요:

### 1. **Parse (파싱)**

- SQL 문법 검사
- 객체(테이블, 컬럼) 존재 여부 확인
- 권한 검사
- **실행 계획 생성** (어떤 인덱스를 쓸지, 테이블 조인 순서 등)
- Hard Parse vs Soft Parse로 나뉨

### 2. **Execute (실행)**

- 실제 SQL 실행
- DML(INSERT/UPDATE/DELETE)은 이 단계에서 작업 완료
- SELECT는 이 단계에서 데이터를 찾기만 하고 아직 가져오지 않음

### 3. **Fetch (인출)**

- **SELECT 결과를 실제로 가져오는 단계**
- 결과가 많으면 여러 번 Fetch 발생
- INSERT/UPDATE/DELETE는 Fetch 없음 (결과 행이 없으니까)

## 왜 모니터링에서 중요한가?

```
예시: SELECT * FROM users WHERE id = 1
Parse: 0.01초 → 실행계획 만드는 시간
Execute: 0.02초 → 인덱스로 데이터 찾는 시간  
Fetch: 0.00초 → 1건만 가져오니 빠름

예시: SELECT * FROM big_table
Parse: 0.01초
Execute: 0.05초
Fetch: 3.50초 → 수백만 건 가져오는데 시간 소요!
```

### DBA가 주목하는 포인트:

1. **Parse 시간이 길다**
    
    - Hard Parse가 많이 발생 → SQL 튜닝 필요
    - 실행계획 재사용 못함 → Bind 변수 사용 권장
2. **Execute 시간이 길다**
    
    - 인덱스 부족, 테이블 스캔 발생
    - 조인 비효율
3. **Fetch 시간이 길다**
    
    - 결과 건수가 너무 많음
    - 네트워크 전송 오버헤드
    - 페이징 처리 필요

## 모니터링 UI 구현 시 고려사항:

기환님이 구현하실 때는 이런 식으로 시각화하면 좋아요:

```
SQL 문: SELECT * FROM orders WHERE ...
├─ Total Time: 5.23s
   ├─ Parse:   0.01s (0.2%)  ✓
   ├─ Execute: 0.22s (4.2%)  ✓
   └─ Fetch:   5.00s (95.6%) ⚠️ 병목!
```

**색상 구분:**

- Parse/Execute/Fetch 비율을 스택 바 차트로
- 병목 구간을 빨간색으로 강조
- Parse 횟수가 Execute 횟수보다 많으면 경고 (캐시 미사용)

이 정보는 DBA가 "어느 단계에서 느린지"를 즉시 파악해서 튜닝 방향을 결정하는 데 핵심적이에요!