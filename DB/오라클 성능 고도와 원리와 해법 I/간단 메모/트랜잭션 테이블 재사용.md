## 트랜잭션 테이블 슬롯 재사용
### 1. **트랜잭션 테이블 슬롯이란?**

**ITL (Interested Transaction List) = 트랜잭션 테이블:**
```
데이터 블록 구조:
┌─────────────────────┐
│ Block Header        │
│  ITL Slots:         │
│  [Slot 1] ← 트랜잭션 A 정보
│  [Slot 2] ← 트랜잭션 B 정보
│  [Slot 3] ← 비어있음
├─────────────────────┤
│ Row Data            │
└─────────────────────┘
```

**각 슬롯에 저장되는 정보:**
- Transaction ID (XID)
- SCN (System Change Number)
- Undo 정보
- 커밋 여부

---
## 2. **재사용의 의미**
### **핵심 개념:**
```
ITL 슬롯 = 주차 공간 🅿️

[Slot 1] 트랜잭션 A 사용 중
[Slot 2] 트랜잭션 B 사용 중
[Slot 3] 비어있음

→ 트랜잭션 A 커밋
→ Slot 1이 "재사용 가능" 상태로 변경
→ 새로운 트랜잭션 C가 Slot 1을 재사용 ✅
```

**블록당 제한된 슬롯 수:**
- 기본값: 보통 2-3개
- 최대값: INITRANS, MAXTRANS 파라미터로 설정
- **슬롯이 부족하면 대기 발생!**

---
## 3. **재사용 시나리오**
### **정상 케이스:**
```
10:00 - TX 100이 Slot 1 획득 → Row 1 수정
10:01 - TX 101이 Slot 2 획득 → Row 2 수정
10:02 - TX 100 커밋 → Slot 1 재사용 가능
10:03 - TX 102가 Slot 1 재사용 → Row 3 수정 ✅
```

### **문제 케이스 (ITL Waits):**
```
블록에 ITL 슬롯이 2개만 있는 경우:

[Slot 1] TX 100 - Row 1 수정 중 (미커밋)
[Slot 2] TX 101 - Row 2 수정 중 (미커밋)

→ TX 102가 Row 3을 수정하려 함
→ 빈 슬롯 없음! ❌
→ TX 100 또는 101이 커밋할 때까지 대기
→ 대기 이벤트: "enq: TX - allocate ITL entry"
```

---
## 4. **클린아웃과의 관계**

**블록 클린아웃 시 슬롯 재사용 정리:**
```
커밋 전:
[Slot 1] TX 100, SCN=1000, Active

커밋 직후:
[Slot 1] TX 100, SCN=1001, Committed (플래그만 변경)

클린아웃 후:
[Slot 1] 완전히 정리됨 → 재사용 준비 완료
```

**지연된 블록 클린아웃:**
- 커밋 시점에 즉시 정리 안 될 수 있음
- 다음 접근 시 클린아웃 수행
- **RAC 환경에서는 Exclusive 모드 필요** (앞서 설명한 내용!)

---
## 5. **INITRANS vs MAXTRANS**
### **파라미터 설정:**
```sql
-- 테이블 생성 시
CREATE TABLE emp (
    empno NUMBER,
    ename VARCHAR2(50)
) 
INITRANS 2      -- 초기 ITL 슬롯 2개
MAXTRANS 255;   -- 최대 255개까지 확장 가능 (11g부터 고정 255)

-- 기존 테이블 변경
ALTER TABLE emp INITRANS 5;
```

**의미:**
- **INITRANS**: 블록 생성 시 예약할 ITL 슬롯 수
- **MAXTRANS**: 필요 시 동적 확장 가능한 최대 슬롯 수
- 슬롯이 많을수록 블록 헤더 오버헤드 증가

---
## 6. **MFO 모니터링 관점**
### **핵심 지표**

**ITL Waits 감지:**
```sql
-- ITL 대기 이벤트 조회
SELECT 
    event,
    total_waits,
    time_waited,
    average_wait
FROM v$system_event
WHERE event LIKE '%ITL%'
   OR event LIKE '%TX - allocate%';
```

**테이블별 ITL 설정 확인:**
```sql
SELECT 
    table_name,
    ini_trans,  -- INITRANS 값
    max_trans   -- MAXTRANS 값
FROM user_tables
WHERE ini_trans < 3;  -- 낮은 INITRANS 찾기
```
### **UI 표시 요소**

**실시간 Alert:**
```javascript
{
  event: "enq: TX - allocate ITL entry",
  count: 150,           // 발생 횟수
  avgWaitTime: "250ms", // 평균 대기 시간
  affectedTable: "ORDERS",
  recommendation: "INITRANS 증가 필요"
}
```

**대시보드 구성:**
```
[ITL 경합 Top 10 테이블]
┌─────────────┬──────────┬─────────────┐
│ Table       │ Waits    │ Avg Time    │
├─────────────┼──────────┼─────────────┤
│ ORDERS      │ 1,523    │ 180ms  ⚠️   │
│ ORDER_ITEMS │ 892      │ 95ms        │
│ CUSTOMERS   │ 234      │ 45ms        │
└─────────────┴──────────┴─────────────┘

권장 조치: ORDERS 테이블 INITRANS 2 → 5로 증가
```

---
## 7. **실무 문제 해결**
### **Case: 동시 트랜잭션 과다로 ITL 경합**

**증상:**
```
- "enq: TX - allocate ITL entry" 대기 빈번
- 특정 Hot 블록에 트랜잭션 집중
- 응답 시간 지연
```

**해결:**
```sql
-- 1. INITRANS 증가
ALTER TABLE orders INITRANS 10;

-- 2. 테이블 재구성 (기존 블록은 그대로)
ALTER TABLE orders MOVE;

-- 3. PCTFREE 증가로 블록당 Row 수 감소
ALTER TABLE orders PCTFREE 30;
```

**근본 원인 분석:**
```
동일 블록의 여러 Row를 동시 수정
→ 슬롯 부족
→ 블록 분산 또는 슬롯 증가 필요
```

---
## 8. **Hot Block vs ITL 슬롯**

**관계도:**
```
Hot Block (여러 TX가 동일 블록 접근)
    ↓
ITL 슬롯 경합 발생
    ↓
옵션 1: INITRANS 증가 (더 많은 슬롯)
옵션 2: 블록 분산 (Row 재배치)
```

---
## 요약

**트랜잭션 테이블 슬롯 재사용:**
```
1개 블록당 제한된 ITL 슬롯
    ↓
트랜잭션 커밋 → 슬롯 재사용 가능
    ↓
슬롯 부족 시 → ITL Waits 발생
```

**핵심:**
- ITL 슬롯 = 블록당 동시 트랜잭션 허용 개수
- 커밋 후 재사용으로 효율성 확보
- 슬롯 부족 = 성능 병목

**모니터링 포인트:**
- `enq: TX - allocate ITL entry` 이벤트
- 테이블별 INITRANS 설정
- Hot Block 식별