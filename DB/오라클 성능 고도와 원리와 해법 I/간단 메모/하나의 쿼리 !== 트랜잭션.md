## 하나의 쿼리 ≠ 트랜잭션

맞습니다. **하나의 쿼리와 트랜잭션은 다른 개념**이에요.

### 트랜잭션의 범위

```sql
-- 트랜잭션 시작
BEGIN TRANSACTION;

  -- 쿼리 1: 계좌에서 인출
  UPDATE account SET balance = balance - 10000 WHERE account_id = 'A';
  
  -- 쿼리 2: 다른 계좌에 입금
  UPDATE account SET balance = balance + 10000 WHERE account_id = 'B';
  
  -- 쿼리 3: 거래 내역 기록
  INSERT INTO transaction_log VALUES (...);

-- 트랜잭션 종료
COMMIT;
```

이 경우 **3개의 쿼리가 하나의 트랜잭션**을 구성합니다.

### 문장 vs 트랜잭션 수준 읽기 일관성

**문장 수준 읽기 일관성 (Statement-level)**

- **각 쿼리가 시작된 시점**의 데이터를 읽음
- Oracle의 기본 격리 수준인 `READ COMMITTED`에서 제공
- 하나의 SELECT 문이 실행되는 동안은 일관된 데이터를 봄

```sql
-- 트랜잭션 시작
BEGIN TRANSACTION;

  -- 쿼리 1 (시각 T1에 시작)
  SELECT sum(balance) FROM account;  -- 이 쿼리 내에서는 T1 시점 데이터 유지
  
  -- (다른 트랜잭션이 데이터 변경하고 COMMIT 함)
  
  -- 쿼리 2 (시각 T2에 시작)  
  SELECT sum(balance) FROM account;  -- T2 시점 데이터를 봄 (변경된 데이터 반영!)

COMMIT;
```

**트랜잭션 수준 읽기 일관성 (Transaction-level)**

- **트랜잭션이 시작된 시점**의 데이터를 읽음
- Oracle의 `SERIALIZABLE` 격리 수준에서 제공
- 트랜잭션 내 모든 쿼리가 동일한 시점의 데이터를 봄

```sql
-- SERIALIZABLE 모드로 설정
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

BEGIN TRANSACTION;

  -- 쿼리 1 (시각 T1)
  SELECT sum(balance) FROM account;  -- 트랜잭션 시작 시점(T1) 데이터
  
  -- (다른 트랜잭션이 데이터 변경하고 COMMIT 함)
  
  -- 쿼리 2 (시각 T2)
  SELECT sum(balance) FROM account;  -- 여전히 T1 시점 데이터를 봄!

COMMIT;
```

### 모니터링 관점에서의 중요성

MFO 같은 모니터링 솔루션에서 이 차이는 다음과 같이 나타날 수 있어요:

1. **Long Running Query 모니터링**: 하나의 긴 쿼리가 실행 중일 때 Undo 데이터를 많이 사용할 수 있음
2. **Snapshot Too Old 에러**: 트랜잭션이 너무 오래 지속되면 필요한 Undo 데이터가 재사용되어 발생
3. **격리 수준별 성능 차이**: SERIALIZABLE은 더 많은 Undo 읽기가 필요하므로 성능 영향

회고에서 말씀하신 것처럼, 실제로는 업무적 관점에서 여러 SQL을 묶어 하나의 트랜잭션으로 설계하는 게 일반적입니다!