## 대기 이벤트
- 대기 이벤트란 오라클 프로세스 간 커뮤니케이션과 상호작용에서 일을 계속 진행할 수 있는 조건이 충족 될 때 까지 수면(`sleep`) 상태에 빠지는 것을 의미한다. 오라클은 대기 이벤트 마다 그 상태정보를 파일 또는 SGA 메모리 내에 저장해둔다.
- 대기 이벤트는 원래 오라클 개발자들이 디버깅 용도로 개발한 것이라고 한다.
- 7.0에서는 100여개, 10g에서 890여개, 11g에는 960개가 넘는 대기 이벤트가 정의돼 사용되고 있다.
- 오라클은 `Wait Event`라고 부르지만 `SQL Server` 에서는 "대기 유형(`Wait Type`)" 이라고 부른다.
- 시스템 커널 레벨에서 설명하면, 프로세스가 할 일을 모두 마쳤거나 다른 프로세스를 기다려야 하는 상황에서 CPU를 쥔 채 대기하지 않고 OS에 반환하고 수면(`sleep`) 상태에 빠지는 것을 말한다.
- 수명 상태의 프로세스를 깨우도록 신호를 보내는 것을 `interrupted` 라고 한다.
- 대기 이벤트가 지속적으로 많이 발생하면 병목이 있음을 알리는 신호지만 모든 대기 이벤트가 그렇지는 않다.
- 대기 이벤트는 다음 상황에서 발생한다:
	1. 자신이 필요로 하는 특정 리소스가 다른 프로세스에 의해 사용 중일 때
	2. 다른 프로세스에 의해 선행작업이 완료되기를 기다릴 때
	3. 할 일이 없을 때
- 오라클 프로세스는 수면 상태로 들어갈 때 타이머를 설정한다. 선행 프로세스가 `interrupted` 하지 않더라도, 타이머에 설정된 시간이 도래(`timeout`)할 때마다 한번씩 깨어나 할 일을 확인한다.
- 타임아웃 설정 값은 대기 이벤트마다 모두 다르다.
- 대기중이던 프로세스가 활동을 재개하는 시점은 다음과 같다:
	1. 대기 상태에 빠진 프로세스가 기다리던 리소스가 사용 가능해 지거나
	2. 작업을 계속 진행하기 위한 선행작업이 완료되거나
	3. 해야 할 일이 생겼을 때
- 대기 이벤트가 무엇인지 개념을 좀더 명확히 하기 위해 래치에 대해 이해할 필요가 있다.
- 래치를 얻는 과정 자체가 경합을 의미하지 않는다. 공유된 자원을 읽으려면 래치를 얻는 것이 당연한 일이므로 `v$latch` 뷰에서 `gets` 횟수가 증가한다고 해서 문제될 것은 없다.
- `v$latch`뷰를 조회하면 `gets`, `misses`, `spin_gets`, `sleeps` 항목들이 집계된다.
	- `gets`: 래치 요청 횟수를 말한다.
	- `misses`: 래치를 요청 했는데 자원이 사용 중이어서 첫 번째 시도에서 곧바고 래치를 얻지 못하는 횟수다. `gets`에서 `misses` 횟수를 빼면 다른 프로세스가 래치 해제를 기다리지 않고 곧바로 래치 획득에 성공한 횟수(`simple_gets`)가 구해진다.
	- `spin_gets`: 래치를 요청한 첫 번째 시도에서 곧바로 래치를 얻지는 못했지만, 이후 `spin` 하는 과정에서 래치 획득에 성공한 횟수다. `misses`에서 `sleep`을 뺀 횟수와 일치한다.
	- `sleeps`: 정해진 횟수만큼 계속 `spin` 했는데도 결국 래치를 얻지 못해 대기 상태로 빠진 횟수다. 이 때 발생하는 것이 `latch free` 대기 이벤트다. 오라클 9i 까지는 모든 래치에 대한 대기 이벤트를 `latch free` 하나로 통합해 보여주었지만, 10g 부터는 세분화해 `latch: cache buffers chains`, `latch: library cache lock` 처럼 별도의 이벤트 명을 부여했다.

## Shared Pool
- Shared Pool은 SGA의 가장 중요한 구성요소 중 하나다.
- Shared Pool은 딕셔너리 캐시와 라이브러리 캐시로 나뉜다.
	- **딕셔너리 캐시**: 오라클 딕셔너리 정보를 저장해 두는 캐시 영역으로서 Row 단위로 읽고 쓰기 때문에 '로우 캐시(`Row Cache`)' 라고도 불린다. 테이블, 인덱스 같은 [[오브젝트]]는 물론 [[테이블스페이스]], [[데이터파일]], [[세그먼트]], [[익스텐트]], 사용자, [[제약]], [[Sequence]], [[DB Link]]에 관한 정보들을 캐싱한다.
		- `v$rowcache`에서 딕셔너리 캐시 활동성에 대한 통계를 조회해 볼 수 있음. 여기서 히트율(`Hit Ratio`)를 조사했을 때 수치가 낮게 나오면 Shared Pool 사이즈를 늘리는 것을 고려해 볼 필요가 있다.
	- **라이브러리 캐시**: DB 버퍼 캐시, Redo 로그 버퍼 매시, 딕셔너리 캐시 등은 데이터 입출력을 빠르게 하기 위한 캐시영역 이라면 라이브러리 캐시는 ==사용자가 던진 SQL과 그 실행 계획을 저장해 두는 캐시영역==이다.
		- 사용자가 SQL이라는 명령어를 통해 결과집합을 요청하면 이를 최적으로 수행하기 위한 처리 루틴이 필요한데 이를 실행계획(`execution plan`) 이라고 함
		- 쿼리 구문 분석을 통해 문법 오류 및 실행 권한 등을 확인하고, 최적화를 통해 실행계획을 만들고, SQL 실행 엔진이 이해할 수 있는 형태로 포맷팅하는 전 과정을 하드 파싱(`Hard Parsing`)이라고 한다.
		- 최적화는 하드 파싱을 무겁게 만드는 가장 결정적 요인인데, 같은 SQL을 처리하려고 무거운 작업을 반복 수행하는 것은 매우 비효율 적이기 때문에 이를 위해 캐시 공간을 두었고, 그게 바로 라이브러리 캐시 영역이다.
		- 라이브러리 캐시 최적화 원리는 캐싱된 SQL과 실행계획의 재사용성을 높이는 데에 있다.