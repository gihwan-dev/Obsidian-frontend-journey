## 트랜잭션 수준 읽기 일관성
- **문장 수준 읽기 일관성**이란 쿼리가 시작된 시점을 기준으로 데이터를 일관성 있게 읽어들이는 것을 말한다
- **트랜잭션 수준 읽기 일관성**은 트랜잭션이 시작된 시점을 기준으로 일관성 있게 데이터를 읽어들이는 것을 말한다

> [!Note] 참고 자료
> - [[쿼리, 트랜잭션의 차이점]]
> - [[하나의 쿼리 !== 트랜잭션]]

- 오라클은 완벽한 문장수준의 읽기 일관성을 보장하지만, 트랜잭션에 대해서는 기본적으로 보장하지 않는다
- 트랜잭션 수준으로 읽기 일관성을 강화하려면 트랜잭션 고립화 수준을 높여 주어야 한다
- 트랜잭션 고립화 수준
	- **레벨 0**: 트랜잭션이 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용. Oracle은 이 레벨을 지원하지 않음
	- **레벨 1**: 트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용. 대부분의 DBBMS가 기본모드로 채택하고 있는 일관성 모드
	- **레벨 2**: 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신한거나 삭제하는 것을 불허함으로써 같은 데이터를 두 번 쿼리했을 때 일관성 있는 결과를 리턴
	- **레벨 3**: 선행 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못할 뿐만 아니라 중간에 새로운 레코드를 삽입하는 것도 막아줌
- 낮은 단계의 트랜잭션 고립화 수준을 사용할 때 아래 세 가지 현상이 발생할 수 있음:
	- **Dirty Read**
		- 아직 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생
		- SQL Server, Sysbase 등은 이를 구현하기 위해 공유 Lock을 사용한다. 갱신 중인 레코드에는 배타적 Lock이 걸려, 공유 Lock과 호환되지 않으므로 갱신 중인 레코드를 읽지 못한다
		- Lock으로 인한 동시성 저하로 인해 Dirty Read를 허용하도록 프로그래밍 하는 경우도 종종 있음
		- Oracle에서는 Undo를 활용해 Lock이 없어도 Dirty Read를 피할 수 있고, 레벨 0 수준으로 트랜잭션 고립화 수준을 낮추는 방법을 아예 제공하지 않는다
	- **Non-Repeatable Read**
		- 한 트랜잭션 내에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성이 발생하는 것을 의미
		- 한 트랜잭션 내에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성이 발생하는 것을 말함
	- **Phantom Read**
		- 한 트랜잭션 안에서 일정범위의 레코드들을 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 현상을 말함
- 트랜잭션 고립화 수준을 높이면 일관성은 향상되지만, Lock을 더 오랫동안 유지하게 되어 동시성은 저하된다
- 오라클은 트랜잭션 고립화 수준을 높이더라도 Lock을 사용하지 않으므로 동시성이 저하되지는 않는다

## 비관적 vs 낙관적 동시성 제어
- **비관적 동시성 제어**: 사용자들이 같은 데이터를 동시에 수정 할 것이라고 가정. 따라서 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회 또는 갱신처리가 완료될 때까지 이를 유지
- **낙관적 동시성 제어**: 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정. 따라서 데이터를 읽을 때는 Lock을 설정하지 않음
- 오라클 10g부터 제공되는 Pseudo 칼럼 `ora_rowscn`을 활용하면 `Timestamp`를 오라클이 직접 관리해 주므로 쉽고 완벽하게 동시성을 제어할 수 있음(로우 단위로 SCN을 기록)

## 오라클 Lock
- 오라클은 공유 리소스와 사용자 데이터를 보호할 목적으로 DML Lock, DDL Lock, 래치, 버퍼 Lock, 라이브러리 캐시 Lock/Pin 등 다양한 종류의 Lock을 사용
	- **래치**: SGA에 공유돼 있는 갖가지 자료구조를 보호할 목적으로 사용하는 가벼운 Lock
	- **버퍼 Lock**: 버퍼 블록에 대한 액세스를 직렬화
	- **라이브러리 캐시 Lock**: 라이브러리 캐시 오브젝트에 대한 핸들을 보호
	- **라이브러리 캐시 Pin**: 라이브러리 캐시 오브젝트의 실제 내용이 담긴 힙(Heap)을 보호
- 앱 개발 측면에서 가장 중요하게 다루어야 할 Lock은 DML Lock:
	- **DML 테이블 Lock**: Enqueue Lock으로 구현
	- **DML 로우 Lock**: 로우 단위 Lock과 트랜잭션 Lock을 조합해서 구현

### Enqueue Lock
- `Enqueue`는 공유 리소스에 대한 액세스를 관리하는 Lock 메커니즘
- `Enqueue`에 의해 보호되는 공유 리소스로는 테이블, 트랜잭션, 테이블스페이스, 시퀀스, Temp 세그먼트 같은 것들이 있음
- `Enqueue Lock`은 래치와 달리 순서가 보장되는 큐 구조를 사용
- `Enqueue Lock`으로 관리되는 공유 리소스에 대해 Lock을 획득하려면 먼저 `Enqueue 리소스`를 할당받아야 함
- `Enqueue 리소스`는 소유자, 대기자 목록을 관리할 수 있는 구조체를 말함

### Tx Lock (=트랜잭션 Lock)
> TX: 트랜잭션을 의미하는 약어
- 트랜잭션을 시작하려면 먼저 Undo 세그먼트 헤더에 위치한 트랜잭션 테이블로부터 슬롯 하나를 할당 받아야함
- \