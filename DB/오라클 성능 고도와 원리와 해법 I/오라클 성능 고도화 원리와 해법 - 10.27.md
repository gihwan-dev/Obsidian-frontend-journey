## 트랜잭션 수준 읽기 일관성
- **문장 수준 읽기 일관성**이란 쿼리가 시작된 시점을 기준으로 데이터를 일관성 있게 읽어들이는 것을 말한다
- **트랜잭션 수준 읽기 일관성**은 트랜잭션이 시작된 시점을 기준으로 일관성 있게 데이터를 읽어들이는 것을 말한다

> [!Note] 참고 자료
> - [[쿼리, 트랜잭션의 차이점]]
> - [[하나의 쿼리 !== 트랜잭션]]

- 오라클은 완벽한 문장수준의 읽기 일관성을 보장하지만, 트랜잭션에 대해서는 기본적으로 보장하지 않는다
- 트랜잭션 수준으로 읽기 일관성을 강화하려면 트랜잭션 고립화 수준을 높여 주어야 한다
- 트랜잭션 고립화 수준
	- **레벨 0**: 트랜잭션이 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용. Oracle은 이 레벨을 지원하지 않음
	- **레벨 1**: 트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용. 대부분의 DBBMS가 기본모드로 채택하고 있는 일관성 모드
	- **레벨 2**: 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신한거나 삭제하는 것을 불허함으로써 같은 데이터를 두 번 쿼리했을 때 일관성 있는 결과를 리턴
	- **레벨 3**: 선행 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못할 뿐만 아니라 중간에 새로운 레코드를 삽입하는 것도 막아줌
- 낮은 단계의 트랜잭션 고립화 수준을 사용할 때 아래 세 가지 현상이 발생할 수 있음:
	- **Dirty Read**
		- 아직 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생
		- SQL Server, Sysbase 등은 이를 구현하기 위해 공유 Lock을 사용한다. 갱신 중인 레코드에는 배타적 Lock이 걸려, 공유 Lock과 호환되지 않으므로 갱신 중인 레코드를 읽지 못한다
		- Lock으로 인한 동시성 저하로 인해 Dirty Read를 허용하도록 프로그래밍 하는 경우도 종종 있음
		- Oracle에서는 Undo를 활용해 Lock이 없어도 Dirty Read를 피할 수 있고, 레벨 0 수준으로 트랜잭션 고립화 수준을 낮추는 방법을 아예 제공하지 않는다
	- **Non-Repeatable Read**
		- 한 트랜잭션 내에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성이 발생하는 것을 의미
		- 