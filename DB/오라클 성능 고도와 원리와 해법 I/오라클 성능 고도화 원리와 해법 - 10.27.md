## 트랜잭션 수준 읽기 일관성
- **문장 수준 읽기 일관성**이란 쿼리가 시작된 시점을 기준으로 데이터를 일관성 있게 읽어들이는 것을 말한다
- **트랜잭션 수준 읽기 일관성**은 트랜잭션이 시작된 시점을 기준으로 일관성 있게 데이터를 읽어들이는 것을 말한다

> [!Note] 참고 자료
> - [[쿼리, 트랜잭션의 차이점]]
> - [[하나의 쿼리 !== 트랜잭션]]

- 오라클은 완벽한 문장수준의 읽기 일관성을 보장하지만, 트랜잭션에 대해서는 기본적으로 보장하지 않는다
- 트랜잭션 수준으로 읽기 일관성을 강화하려면 트랜잭션 고립화 수준을 높여 주어야 한다
- 트랜잭션 고립화 수준
	- **레벨 0**: 트랜잭션이 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용. Oracle은 이 레벨을 지원하지 않음
	- **레벨 1**: 트랜잭션이 커밋되어 확정된 데이터만 읽는 것을 허용. 대부분의 DBBMS가 기본모드로 채택하고 있는 일관성 모드
	- **레벨 2**: 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신한거나 삭제하는 것을 불허함으로써 같은 데이터를 두 번 쿼리했을 때 일관성 있는 결과를 리턴
	- **레벨 3**: 선행 트랜잭션이 읽은 데이터를 후행 트랜잭션이 갱신하거나 삭제하지 못할 뿐만 아니라 중간에 새로운 레코드를 삽입하는 것도 막아줌
- 낮은 단계의 트랜잭션 고립화 수준을 사용할 때 아래 세 가지 현상이 발생할 수 있음:
	- **Dirty Read**
		- 아직 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생
		- SQL Server, Sysbase 등은 이를 구현하기 위해 공유 Lock을 사용한다. 갱신 중인 레코드에는 배타적 Lock이 걸려, 공유 Lock과 호환되지 않으므로 갱신 중인 레코드를 읽지 못한다
		- Lock으로 인한 동시성 저하로 인해 Dirty Read를 허용하도록 프로그래밍 하는 경우도 종종 있음
		- Oracle에서는 Undo를 활용해 Lock이 없어도 Dirty Read를 피할 수 있고, 레벨 0 수준으로 트랜잭션 고립화 수준을 낮추는 방법을 아예 제공하지 않는다
	- **Non-Repeatable Read**
		- 한 트랜잭션 내에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성이 발생하는 것을 의미
		- 한 트랜잭션 내에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성이 발생하는 것을 말함
	- **Phantom Read**
		- 한 트랜잭션 안에서 일정범위의 레코드들을 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 현상을 말함
- 트랜잭션 고립화 수준을 높이면 일관성은 향상되지만, Lock을 더 오랫동안 유지하게 되어 동시성은 저하된다
- 오라클은 트랜잭션 고립화 수준을 높이더라도 Lock을 사용하지 않으므로 동시성이 저하되지는 않는다

## 비관적 vs 낙관적 동시성 제어
- **비관적 동시성 제어**: 사용자들이 같은 데이터를 동시에 수정 할 것이라고 가정. 따라서 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회 또는 갱신처리가 완료될 때까지 이를 유지
- **낙관적 동시성 제어**: 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정. 따라서 데이터를 읽을 때는 Lock을 설정하지 않음
- 오라클 10g부터 제공되는 Pseudo 칼럼 `ora_rowscn`을 활용하면 `Timestamp`를 오라클이 직접 관리해 주므로 쉽고 완벽하게 동시성을 제어할 수 있음(로우 단위로 SCN을 기록)

## 오라클 Lock
- 오라클은 공유 리소스와 사용자 데이터를 보호할 목적으로 DML Lock, DDL Lock, 래치, 버퍼 Lock, 라이브러리 캐시 Lock/Pin 등 다양한 종류의 Lock을 사용
	- **래치**: SGA에 공유돼 있는 갖가지 자료구조를 보호할 목적으로 사용하는 가벼운 Lock
	- **버퍼 Lock**: 버퍼 블록에 대한 액세스를 직렬화
	- **라이브러리 캐시 Lock**: 라이브러리 캐시 오브젝트에 대한 핸들을 보호
	- **라이브러리 캐시 Pin**: 라이브러리 캐시 오브젝트의 실제 내용이 담긴 힙(Heap)을 보호
- 앱 개발 측면에서 가장 중요하게 다루어야 할 Lock은 DML Lock:
	- **DML 테이블 Lock**: Enqueue Lock으로 구현
	- **DML 로우 Lock**: 로우 단위 Lock과 트랜잭션 Lock을 조합해서 구현

### Enqueue Lock
- `Enqueue`는 공유 리소스에 대한 액세스를 관리하는 Lock 메커니즘
- `Enqueue`에 의해 보호되는 공유 리소스로는 테이블, 트랜잭션, 테이블스페이스, 시퀀스, Temp 세그먼트 같은 것들이 있음
- `Enqueue Lock`은 래치와 달리 순서가 보장되는 큐 구조를 사용
- `Enqueue Lock`으로 관리되는 공유 리소스에 대해 Lock을 획득하려면 먼저 `Enqueue 리소스`를 할당받아야 함
- `Enqueue 리소스`는 소유자, 대기자 목록을 관리할 수 있는 구조체를 말함

### Tx Lock (=트랜잭션 Lock)
> TX: 트랜잭션을 의미하는 약어
- 트랜잭션을 시작하려면 먼저 Undo 세그먼트 헤더에 위치한 트랜잭션 테이블로부터 슬롯 하나를 할당 받아야함
- 오라클에서는 CR 블록을 활용해 레코드가 갱신 중이더라도 읽기 작업에 대해서는 블로킹 없이 작업을 진행함
- 하지만 변경중인 레코드를 동시에 변경하려는 트랜잭션에 대해서는 엑세스를 직렬화해야 하며, 그 목적으로 사용하는 Lock 메커니즘이 트랜잭션 Lock(TX Lock)이다
- TX Lock은 트랜잭션이 첫 번째 변경을 시작할 때 얻고, 커밋 또는 롤백할 때 해제함
- TX Lock도 `Enqueue Lock`으로 구현됨. `TX Lock`을 위한 `Enqueue 리소스` 구조체의 식별자는 아래 정보를 포함:
	- `TYPE`: `TX`
	- `ID1`: Undo 세그먼트 + 트랜잭션 슬롯 번호
	- `ID2`: 트랜잭션 Sequence 번호
- 트랜잭션이 아직 커밋되지 않은 상태를 `Active` 상태라고 함
- TX Lock으로 인해 대기중인 트랜잭션은 3초마다 한번씩 TX Lock 상태를 확인해 교착상태 발생 여부를 확인함
- TX 관련된 이벤트 명은 트랜잭션과 관련된 대기 이벤트
- TX Lock 발생 원인은 아래 6가지가 있음
	- DML 로우 Lock
	- 무결성 제약 위배 가능성
		- 일반적으로 update나 delete 시에만 발생
		- insert는 새로운 레코드를 삽입하는 것이므로 로우 Lock 경합이 발생하지 않음
		- 하지만 [[Unique 인덱스가 정의되어 있을 때는 insert에 의한 로우 Lock 경합이 생길 수 있음]]
	- 비트맵 인덱스 엔트리 갱신
	- ITL 슬롯 부족
	- 인덱스 분할
	- 기타
