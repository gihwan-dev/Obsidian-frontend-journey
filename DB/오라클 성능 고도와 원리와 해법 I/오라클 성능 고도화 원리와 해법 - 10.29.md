## TX Lock
- **무결성 제약 위배 가능성 또는 [[비트맵 인덱스]] 엔트리 갱신**
	- 로우 Lock 경합은 일반적으로 update나 delete 시에만 발생함
	- insert는 새로운 레코드를 삽입하는 것이므로 로우 Lock이 발생하지 않음
	- 하지만 테이블에 Unique 인덱스가 정의되어 있을 때는 insert에 의한 로우 Lock 경합이 생길 수 있음
	- 그런 경우 `enq: TX - row lock contention` 대기 이벤트가 `Shared` 모드로 발생함
	- [[비트맵 인덱스]] 엔트리에 대한 갱신을 수행할 때도 `Shared` 모드로 `enq: TX - row lock contention` 이벤트가 발생할 수 있음. 비트맵 인덱스는 그 구조상 하나의 엔트리가 여러 개 레코드와 매핑되기 때문
- **ITL 슬롯 부족**
	- 블록에 레코드를 추가/갱신/삭제하려면, ITL 슬롯을 먼저 할당 받고 그 곳에 트랜잭션 ID를 먼저 기록해야함
	- 빈 ITL 슬롯이 없다면, ITL 슬롯을 사용 중인 트랜잭션 중 하나가 커밋 또는 롤백할 때까지 기다려야 하며, 이떄 `Shared` 모드 `enq: TX - allocate ITL entry` 대기 이벤트가 발생함
	- insert 시에는 ITL 슬롯이 필요하지 않음, 9i 부터는 테이블 블록에 대한 ITL 경합이 발생하지 않음
	- ITL 경합에 의한 대기 현상이 자주 발생하는 세그먼트(테이블, 인덱스, 파티션)에 대해서는 INITRANS를 늘려주어야 하며, 그런 세그먼트 복록은 `v$segstat`을 통해 확인할 수 있음
- **인덱스 분할**
	- 테이블은 레코드간 정렬 상태를 유지하지 않기 때문에 입력할 공간이 부족할 때 새로운 블록을 할당 받아 입력하면 됨
	- 인덱스는 정렬된 상태를 유지해야 하기 때문에 아무 블록에나 값을 입력할 수 없음
	- 값을 입력할 위치에 빈 공간이 없으면 인덱스 분할을 실시해 새 값을 입력할 공간을 확봫며, 이 과정에서 Lock 경합이 발생할 수 있음
	- 익덱스 분할을 진행하는 동안 트랜잭션이 발생하면 `Shared` 모드에서 `enq: TX - index contention` 이벤트를 만나게 됨
