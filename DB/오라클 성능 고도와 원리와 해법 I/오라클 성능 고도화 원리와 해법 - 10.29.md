## TX Lock
- **무결성 제약 위배 가능성 또는 [[비트맵 인덱스]] 엔트리 갱신**
	- 로우 Lock 경합은 일반적으로 update나 delete 시에만 발생함
	- insert는 새로운 레코드를 삽입하는 것이므로 로우 Lock이 발생하지 않음
	- 하지만 테이블에 Unique 인덱스가 정의되어 있을 때는 insert에 의한 로우 Lock 경합이 생길 수 있음
	- 그런 경우 `enq: TX - row lock contention` 대기 이벤트가 `Shared` 모드로 발생함
	- [[비트맵 인덱스]] 엔트리에 대한 갱신을 수행할 때도 `Shared` 모드로 `enq: TX - row lock contention` 이벤트가 발생할 수 있음. 비트맵 인덱스는 그 구조상 하나의 엔트리가 여러 개 레코드와 매핑되기 때문
- **ITL 슬롯 부족**
	- 블록에 레코드를 추가/갱신/삭제하려면, ITL 슬롯을 먼저 할당 받고 그 곳에 트랜잭션 ID를 먼저 기록해야함
	- 빈 ITL 슬롯이 없다면, ITL 슬롯을 사용 중인 트랜잭션 중 하나가 커밋 또는 롤백할 때까지 기다려야 하며, 이떄 `Shared` 모드 `enq: TX - allocate ITL entry` 대기 이벤트가 발생함
	- insert 시에는 ITL 슬롯이 필요하지 않음, 9i 부터는 테이블 블록에 대한 ITL 경합이 발생하지 않음
	- ITL 경합에 의한 대기 현상이 자주 발생하는 세그먼트(테이블, 인덱스, 파티션)에 대해서는 INITRANS를 늘려주어야 하며, 그런 세그먼트 복록은 `v$segstat`을 통해 확인할 수 있음
- **인덱스 분할**
	- 테이블은 레코드간 정렬 상태를 유지하지 않기 때문에 입력할 공간이 부족할 때 새로운 블록을 할당 받아 입력하면 됨
	- 인덱스는 정렬된 상태를 유지해야 하기 때문에 아무 블록에나 값을 입력할 수 없음
	- 값을 입력할 위치에 빈 공간이 없으면 인덱스 분할을 실시해 새 값을 입력할 공간을 확봫며, 이 과정에서 Lock 경합이 발생할 수 있음
	- 인덱스 분할을 진행하는 동안 트랜잭션이 발생하면 `Shared` 모드에서 `enq: TX - index contention` 이벤트를 만나게 됨
- **기타 트랜잭션 Lock**
	- 앞서 열거한 TX Lock 이외의 트랜잭션 대기 상황이 여기에 포함된거 "같다" 라고 설명
- **DML 로우 Lock**
	- DML Lock은 다중 사용자에 의해 동시에 액세스되는 사용자 데이터의 무결성을 보호해줌
	- DML 수행 중에 호환되지 않는 다른 DML 또는 DDL 오퍼레이션의 수행을 방지시켜 주는 것
	- 그 중 **로우 Lock**은 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지함
	- 오라클은 로우 Lock을 로우 단위(row-level) Lock과 TX Lock을 조합해서 구현함. 즉, 로우를 갱신 하려면 Undo 세그먼트에서 트랜잭션 슬롯을 먼저 할당받고, Enqueue 리소스를 통해 TX Lock을 획득해야함. 이후 insert, update, delete, merge 문장을 통해 갱신하는 각 로우마다 Exclusive 모드로 로우 단위 Lock을 획득함
	- 
