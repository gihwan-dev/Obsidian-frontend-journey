## TX Lock
- **무결성 제약 위배 가능성 또는 [[비트맵 인덱스]] 엔트리 갱신**
	- 로우 Lock 경합은 일반적으로 update나 delete 시에만 발생함
	- insert는 새로운 레코드를 삽입하는 것이므로 로우 Lock이 발생하지 않음
	- 하지만 테이블에 Unique 인덱스가 정의되어 있을 때는 insert에 의한 로우 Lock 경합이 생길 수 있음
	- 그런 경우 `enq: TX - row lock contention` 대기 이벤트가 `Shared` 모드로 발생함
	- [[비트맵 인덱스]] 엔트리에 대한 갱신을 수행할 때도 `Shared` 모드로 `enq: TX - row lock contention` 이벤트가 발생할 수 있음. 비트맵 인덱스는 그 구조상 하나의 엔트리가 여러 개 레코드와 매핑되기 때문
- **ITL 슬롯 부족**
	- 블록에 레코드를 추가/갱신/삭제하려면, ITL 슬롯을 먼저 할당 받고 그 곳에 트랜잭션 ID를 먼저 기록해야함
	- 빈 ITL 슬롯이 없다면, ITL 슬롯을 사용 중인 트랜잭션 중 하나가 커밋 또는 롤백할 때까지 기다려야 하며, 이떄 `Shared` 모드 `enq: TX - allocate ITL entry` 대기 이벤트가 발생함
	- insert 시에는 ITL 슬롯이 필요하지 않음, 9i 부터는 테이블 블록에 대한 ITL 경합이 발생하지 않음
	- ITL 경합에 의한 대기 현상이 자주 발생하는 세그먼트(테이블, 인덱스, 파티션)에 대해서는 INITRANS를 늘려주어야 하며, 그런 세그먼트 복록은 `v$segstat`을 통해 확인할 수 있음
- **인덱스 분할**
	- 테이블은 레코드간 정렬 상태를 유지하지 않기 때문에 입력할 공간이 부족할 때 새로운 블록을 할당 받아 입력하면 됨
	- 인덱스는 정렬된 상태를 유지해야 하기 때문에 아무 블록에나 값을 입력할 수 없음
	- 값을 입력할 위치에 빈 공간이 없으면 인덱스 분할을 실시해 새 값을 입력할 공간을 확보하며, 이 과정에서 Lock 경합이 발생할 수 있음
	- 인덱스 분할을 진행하는 동안 트랜잭션이 발생하면 `Shared` 모드에서 `enq: TX - index contention` 이벤트를 만나게 됨
- **기타 트랜잭션 Lock**
	- 앞서 열거한 TX Lock 이외의 트랜잭션 대기 상황이 여기에 포함된거 "같다" 라고 설명
- **DML 로우 Lock**
	- DML Lock은 다중 사용자에 의해 동시에 액세스되는 사용자 데이터의 무결성을 보호해줌
	- DML 수행 중에 호환되지 않는 다른 DML 또는 DDL 오퍼레이션의 수행을 방지시켜 주는 것
	- 그 중 **로우 Lock**은 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지함
	- 오라클은 로우 Lock을 로우 단위(row-level) Lock과 TX Lock을 조합해서 구현함. 즉, 로우를 갱신 하려면 Undo 세그먼트에서 트랜잭션 슬롯을 먼저 할당받고, Enqueue 리소스를 통해 TX Lock을 획득해야함. 이후 insert, update, delete, merge 문장을 통해 갱신하는 각 로우마다 Exclusive 모드로 로우 단위 Lock을 획득함
	- 참고로 오라클에서는 "읽기" 작업에 대해서는 절대 Lock에 의한 대기 현상이 발생하지 않도록 구현되어있다
- **DML 테이블 Lock**
	- 오라클은 로우 Lock 획득 시, 해당 테이블에 대한 테이블 Lock도 동시에 획득함
	- 그럼으로써 현재 트랜잭션이 갱신 중인 테이블에 대한 호환되지 않는 DDL 오퍼레이션을 방지
	- DDL 문을 이용해 테이블 구조를 변경하려는 세션은 해당 테이블에 TM Lock이 설정돼 있는지를 먼저 확인하고, 하나라도 있으면 ORA-00054 메시지를 던지고 작업을 멈춤
	- DDL 문이 먼저 수행 중일 때는, DML 문을 수행하려는 세션이 TX Lock을 얻으려고 대기. 이 떄 `enq: TM - contention` 이벤트가 발생함
- **Lock을 푸는 열쇠, 커밋**
	- 가끔 블로킹과 교착상태를 구분 못하는 분들을 만난다고 함.
	- **블로킹**:
		- Lock 경합이 발생해 특정 세션이 작업을 진행하지 못하고 멈춰 선 경우를 말함. 이것을 해소하는 방법은 커밋뿐
	- **교착 상태(Deadlock)**:
		- 두 세션이 각각 Lock을 설정한 리소스를, 서로 액세스하려고 마주보고 진행하는 상황이며, 둘 중 하나가 뒤로 물러나지 않으면 영영 풀릴 수 없음
	- 오라클에서 교착상태가 발생하면, 이를 먼저 인지한 세션이 문장 수준 롤백을 진행한 후에 에러 메시지 `ORA-00060: deadlock detected while waiting for resource` 에러를 던짐
	- 교착상태를 발생시킨 문장 하나만 롤백하는 것
	- 이제 교착상태는 해소됐지만 블로킹 상태에 놓이게 됨. 따라서 이 메시지를 받은 세션은 커밋 또는 롤백을 결정해야함. 만약 프로그램 내에서 이 에러에 대한 예외 처리를 하지 않는다면 대기 상태를 지속하게 되므로 주의가 필요함
	- 오라클은 데이터를 읽을 때 Lock을 사용하지 않으므로, Lock 경합이 상대적으로 적게 발생함
	- 그래서 트랜잭션을 길게 가져갈 수 있음
	- 다만 트랜잭션이 너무 길게 되면 롤백할 때 너무 많은 시간이 걸릴 수 있음
	- 그렇다고 너무 자주 커밋하면 Snapshot too old(ORA-01555) 에러를 유발할 가능성이 높아지고, LGWR가 로그 버퍼를 비우는 동안 발생하는 `log file sync` 대기 이벤트로 인해 성능 저하 현상을 겪을 수 있음
	- 10gR2 부터 아래의 비동기식 커밋을 활용해 성능 저하를 개선할 수 있음:
		- **WAIT(Default)**: LGWR가 로그버퍼를 파일에 기록했다는 완료 메시지를 받을 때까지 대기하며, 그 동안 `log file sync` 대기 이벤트가 발생(동기식 커밋)
		- **NOWAIT**: LGWR의 완료 메시지를 기다리지 않고 바로 다음 트랜잭션을 진행해, `log file sync` 대기 이벤트가 발생하지 않음
		- **IMMEDIATE(Default)**: 커밋 명령을 받을 때마다 LGWR가 로그 버퍼를 파일에 기록
		- **BATCH**: 세션 내부에 트랜잭션 데이터를 일정량 버퍼링했다가 일괄 처리
	- 다만 비동기식 커밋 옵션을 사용하면, 트랜잭션 커밋 이후 인스턴스에 문제가 생기거나, Redo 로그가 위치한 파일 시스템에 문제가 생겨 쓰기 작업을 진행할 수 없게 되면 커밋이 정상적으로 완료되지 못할 수 있음
