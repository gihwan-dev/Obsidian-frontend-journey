## 오라클 성능 관리
- 쿼리 성능에 문제가 생기면 Explain Plan을 통해 실행계획을 먼저 확인
- 그것만으로 정확히 파악할 수 없을 때는 AutoTrace를 걸어 실제 일량을 측정하거나, SQL 트레이스를 걸어 내부 수행 절차가 어느 단계에서 부하를 일으키는지 눈으로 확인
- 문제점이 파악되면 쿼리를 변환 혹은 옵티마이저 힌트를 사용해 튜닝
- 그것만으로 부족하다면 인덱스 조정을 병행

### Explain Plan
- SQL 수행 이전 실행계획을 확인하고자 할 때, `explain plan` 명령을 사용함. 이 명령어를 사용하려면 먼저 `plan_table`을 생성해야함
- 오라클 10g 부터는 설치 시 기본적으로 `sys.plan_table$` 테이블이 만들어짐
- `plan_table`이 있다면, `explain plan for` 명령으를 통해 SQL에 대항 실행계획을 `plan_table`에 저장할 수 있음
- SQL Repository에 저장된 모든 SQL에 대해 매일 `explain plan` 명령을 수행해 실행계획을 별도 테이블로 저장해 둔다면 안정적인 시스템 운영 및 성능관리에 활용할 수 있음

### AutoTrace
- SQL 튜닝에 유용한 정보를 많이 포함하고 있어 즐겨 사용되는 도구 중 하나
- 아래 같은 옵션 조합이 있음:
	- `set autotrace on`: SQL을 실제 수행하고 그 결과와 함께 실행계획 및 실행통계를 출력
	- `set autotrace on explain`: SQL을 실제 수행하고 그 결과와 함계 실행계획을 출력
	- `set autotrace on statistics`: SQL을 실제 수행하고 그 결과와 함꼐 실행통계를 출력
	- `set autotrace traceonly`: SQL을 실제 수행하지만 그 결과는 출력하지 않고 실행계획과 통계만을 출력
	- `set autotrace traceonly explain`: SQL을 실제 수행하지 않고 실행계획만 출력
	- `set autotrace traceonly statistics`: SQL을 실제 수행하지만 그 결과는 출력하지 않고 실행통계만을 출력

### SQL 트레이스
- SQL을 튜닝할 때 가장 많이 사용되는 도구
- 사전 실행계획과 AutoTrace 결과만으로 부하원인을 찾을 수 없을 때, SQL 트레이스를 통해 쉽게 찾아낼 수 있음
- 트레이스 파일을 TKProf 유틸리티를 사용하면 트레이스 파일을 포맷팅할 수 있음
- ![[Pasted image 20251030072204.png]]
- SQL 문 바로 아래 Call 칼럼들의 의미:
	- `call`
		- [[커서]] 상태에 따라 Parse, Execute, Fetch 세 개의 Call로 나누어 각각에 대한 통계정보를 보여줌
			- `Parse`: 커서를 파싱하고 실행계획을 생성하는 데 대한 통계
			- `Execute`: 커서의 실행 단계에 대한 통계
			- `Fetch`: 레코드를 실제로 `Fetch`하는 데 대한 통계
	- `count`
		- `Parse`, `Execute`, `Fetch` 각 단계가 수행된 횟수
	- `cpu`
		- 현재 커서가 각 단계에서 사용한 `cpu time`
	- `elapsed`
		- 현재 커서가 각 단계를 수행하는 데 소요된 시간
	- `disk`
		- 디스크로부터 읽은 블록 수
	- `query`
		- Consistent 모드에서 읽은 버퍼 블록 수
	- `current`
		- Current 모드에서 읽은 버퍼 블록 수
	- `rows`
		- 각 단계에서 읽거나 갱신한 처리 건수
		- 
- CPU Time과 Elapsed Time의 차이
	- Elapsed Time = CPU Time + Wait Time  = Response 시점 - Call 시점
		- 참고: [[Call 시점과 Response 시점의 차이]]
		- Elapsed Time은 Call 단위로 측정이 이루어짐
		- 사용자로부터 데이터베이스 Call을 받은 순간부터 Response를 보내는 순간까지의 소요시간을 의미
		- 예를 들어, 13초에 Call을 보냈는데 25초에 Response를 받았다면 Call Elapsed Time은 12초가 됨
		- 애플리케이션 커서 캐싱 기법을 사용하지 않는 한 하나의 SELECT 문을 수행하는 동안 최소 3번의 Call이 발생하며, DML문은 단 2번의 Call이 발생함
			- SELECT문 = Parse Call + Execute Call + Fetch Call
			- DML문 = Parse Call + Execute Call
		- 따라서 하나의 SQL을 수행할 때의 Total Elapsed Time은 수행 시 발생하는 모든 Call의 Elapsed Time을 더해서 구함
	- CPU Time = OS 레벨에서 해당 프로세스가 실제로 CPU 코어를 사용한 시간 

### DMBS_XPLAN 패키지
- 오라클 9.2 버전에 소개된 `dbms_xplan` 패키지를 통해 `plan_table`에 저장된 실행계획을 좀 더 쉽게 출력해 볼 수 있게 됨
- 10g 부터는 라이브러리 캐시에 캐싱돼 있는 SQL 커서에 대한 실행계획은 물론 Row Source별 수행통계까지 손쉽게 출력해 볼 수 있도록 기능이 확장됨
- ![[Pasted image 20251030075707.png]]
- Rows, Bytes, Cost, Partition, Parallel, Predicate, Projection, Alias, Remote, Note 등의 옵션이 있음
- 오라클은 라이브러리 캐시에 캐싱돼 있는 각 커서에 대한 수행통계를 볼 수 있도록 `v$sql` 뷰를 제공함. 그 중 활용도가 가장 높은 것이 `v$sql_plan`과 `v$sql_plan_statistics`. 그리고 이 두 뷰를 합쳐서 보여주는 것이. `v$sql_plan_statistics_all`
	- `v$sql_plan`, `v$sql_plan_statistics` 조회하려면 마지막 수행한 SQL의 `sql_id`와 `child_number` 값을 알아야함

### V$SYSSTAT
- 인스턴스 기동 후 현재까지 누적된 수행 통계치를 시스템 레벨로 확인하고자 할 때 사용하는 뷰
- 개별 세션별로 확인하려면 `v$sesstat`을 확인할 수 있음