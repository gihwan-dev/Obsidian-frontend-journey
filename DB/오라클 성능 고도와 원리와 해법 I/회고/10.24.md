오늘 읽었던 내용은 트랜잭션과 Lock에 관한 내용이었습니다. 특히 트랜잭션을 이렇게 자세히? 설명하는 글을 본 적이 없었어서 이게 트랜잭션이구나~~ 를 이해할 수 있어서 너무 좋았습니다!

대부분의 DBMS(DB2, SQL Server, Sysbase) 등은 Lock을 통해 읽기 일관성을 구현하지만, 오라클은 Undo 데이터를 활용해(시점 정보를 기반으로 데이터를 해당 시점으로 롤백하는 방식으로) 읽기 일관성을 구현했습니다. 그렇기에 Lock을 사용하지 않아 다른 DBMS 보다 동시성 측면에서 우월하다고 평가할 수 있다고 하네요!

SQL Server도 최근 버전에서 Snapshot 모드로 설정해 비슷한 읽기 일관성 모델로 데이터베이스를 운영할 수 있는 기능을 지원하기 시작했다고 합니다ㅎㅎ

오라클 10g 에서부터는 대기 이벤트를 아래와 같이 분류한다고 합니다:
- Administrative: 46개
- Application: 12개
- Cluster: 47개
- Commit: 1개
- Concurrency: 24개
- Configuration: 23개
- Idle: 62개
- Network: 26개
- Other: 588개
- Scheduler: 2개
- System I/O: 24개
- User I/O: 17개

특히 흥미로운 점은 Lock 경합의 대부분을 차지하는 특정 이벤트(`enq: TM - contention`, `enq: TX - row lock contention`)들이 Concurrency가 아닌 Application으로 분류되는데, 이는 테이블 및 로우 Lock 관련 이벤트를 DBA의 이슈가 아닌 개발자 이슈임을 분명히 밝히고 있는 것이라고 하네요! Lock 이 발생했을 때 DBA가 할 수 있는 일은 사실상 프로세스 종료 밖에 없고, 근본적인 원인은 소프트웨어에 있다고 합니다!

다음은 트랜잭션에 대한 내용입니다! 가장 얻은게 많은(?) 내용이었다고 생각해요. 우선 동시성과 일관성에 대해 얘기하면 좋을거 같습니다.

- **동시성**: 다중 사용자가 같은 데이터를 동시에 액세스
- **일관성**: 자신이 발생시킨 변경 사항과 다른 트랜잭션의 변경 사항을 포함해 일관성 있는 데이터를 제공

다만 이 두 성질은 서로 베타적인 관계로 트레이드오프 관계에 있습니다.

일관성 있게 데이터가 처리되려면 두 개 이상의 갱신연산이 동시에 실행될 수 있어야 하는데, 이는 불가능 합니다. 그렇기에 DBMS들은 차선책을 활용합니다. 여러 개의 수정 작업이 하나의 작업처럼 "전부" 처리되거나 "아예 처리되지 않도록" 하는 것입니다. 이러한 일의 최소 단위를 트랜잭션이라고 합니다(트랜잭션의 원자성).

엥? 싶었지만 예로 보면 이해하기 좋았던거 같아요! 은행 업무의 "계좌이체" 트랜잭션을 예로 들겠습니다. "계좌이체" 트랜잭션은 하나의 예금 계좌에서 인출해 다른 예금 계좌에 입금하는데, 이 두 작업은 하나의 단위로 함께 수행되어야 합니다. 예금 계좌를 읽어 인출하고 다른 예금 계좌에 입금하는 것 까지가 "계좌이체" 트랜잭션이 됩니다.

그래서 트랜잭션은 업무 처리의 기본 단위를 정의하는 것이고, 실제 어플리케이션 설계단계에서는 업무적인 관점에서 좀 더 포괄적으로 정의하게 된다고 합니다. 간단하게 말하면 하나의 SQL 스크립트가 실행되는걸 트랜잭션이라고 말할 수 있지 않을까? 하는 생각을 했던거 같아요!

이  내용을 읽으면서 아~ 이게 트랜잭션 이구나 하는 생각을 했던거 같습니다ㅎㅎ

오늘은 집중이 잘 되었던 날인거 같습니다! 그만큼 내용도 길어지긴 했지만... 나누고픈 내용이 많아서 열심히 적어 봤습니다!! 최근 디자인 시스템으로 바쁜데, 날씨까지 춥다보니 다들 건강 잘 챙기셔야 할거 같습니다ㅎㅎ 드디어 금요일 이네요~~ 오늘도 파이팅 하시죠!! 금요팅입니다~!~!
