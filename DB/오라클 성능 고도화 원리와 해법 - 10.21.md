- 블록 클린아웃은 트랙잭션에 의해 설정된 로우 Lock을 해제하고 블록 헤더에 커밋 정보를 기록하는 오퍼레이션
- [[오라클에서 로우 단위 Lock은 레코드의 속성으로 관리]]되며, 이는 로우 헤더로부터 블록 헤더에 있는 ITL 엔트리를 가리키는 포인터다
- 사용자가 트랜잭션을 커밋하면 블록 클린아웃까지 완료해야 완전한 커밋
- 대량의 갱신 작업에서는 커밋 정보를 트랜잭션에 기록하고 빠르게 커밋을 끝냄. 이후 해당 블록에 처음 액세스 되는 시점에 클린아웃
- 항상 이 방식으로 동작하지 않으면 Delayed 블록 클린아웃과 커밋 클린아웃 두 가지 메커니즘을 사용
- **Delayed 블록 클린아웃**
	- 트랜잭션이 갱신한 블록 개수가 총 버버 캐시 블록 개수의 1/10을 초과할 때 사용
		1. ITL 슬롯에 커밋 정보 저장
		2. 레코드에 기록된 Lock Byte 해제
		3. Online Redo에 Logging
	- Active 상태의 블록, 즉 다른 트랜잭션이 발생시킨 변경사항에 대한 커밋 정보가 아직 ITL에 기록되지 않았다면 읽기 전에 먼저 블록 클린아웃을 시도
	- ITL 슬롯의 트랜잭션 ID를 이용해 Undo 세그먼트 헤더에 있는 트랜잭션 테이블 슬롯을 찾아가 트랜잭션 현재 상태 확인 -> 커밋된 트랜잭션 이라면 ITL 슬롯에 반영 이후 로우 Lock 정보를 해제해 블록을 클린아웃 -> 블록 클린아웃을 위한 갱신 내용도 Redo에 로깅 및 블록 SCN 변경
- **커밋 클린아웃(= Fast 블록 클린아웃)**
	- 블록 클린아웃도 쓰기 작업이므로 Current 블록에 작업을 수행
	- RAC, OPS 환경에서는 Exclusive 모드로 Current 블록을 요청. RAC에서는 Dirty 상태의 버퍼 블록을 디스크 쓰기 작업 없이 인스턴스끼리 주고받는 것이 가능
	- 과거 OPS 환경에서는 일단 Dirty 블록을 디스크에 기록하면 그것을 디스크에서 읽어가는 방식을 사용. 이처럼 디스크를 거쳐 인스턴스간에 블록을 주고받는 과정을 '핑(ping)'이라고 함
	- OPS 환경에서 과도한 ping이 발생하는 문제를 해결하기 위해 커밋 클린아웃 방식이 도입됨
	- 트랜잭션이 갱신한 블록 개수가 [[버퍼 캐시 블록]] 개수의 1/10을 초과하지 않을 때는 커밋 시점에 곧바로 블록 클린아웃을 수행
	- 이 경우에도 커밋 시점에는 '불완전한 형태의 클린아웃'을 수행하며 해당 블록을 '갱신하는' 다음 트랜잭션에 의해 완전한 클린아웃이 이루어짐
	- 