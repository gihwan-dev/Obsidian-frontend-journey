## SQL 파싱과 최적화
- SQL은 **Structured** Query Language의 줄임말
- 기본적으로 구조적이고 집합적이고 선언적인 질의 언어
- 그렇기에 프로시저가 필요한데, 그런 피로시저를 만들어 내는 DBMS 내부 엔진이 바로 SQL 옵티마이저
- DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정을 SQL 최적화라고 함

### SQL 최적화
- 실행 과정
	1. SQL 파싱
		1. 파싱 트리 생성
		2. Syntax 체크
		3. Semantic 체크
	2. SQL 최적화
		1. 미리 수집한 시스템 및 통계정보를 바탕으로 다양한 실행경로를 생성해 비교한 후 가장 효율적인 하나를 선택
	3. 로우 소스 생성
		1. SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포매팅

### SQL 옵티마이저
- 최적화 단계
	1. 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아냄
	2. 데이터 딕셔너리에 미리 수집해 둔 오프젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정
	3. 최저 비용을 나타내는 실행계획을 선택

### 실행 계획가 비용
- SQL 옵티마이저는 자동차 내비게이션과 여러모로 흡사함
- DBMS에 'SQL 실행경로 미리보기' 기능이 있음. 실행계획(Execution Plan)이 바로 그것임
- SQL 옵티마이저가 생성한 처리절차를 사용자가 확인할 수 있게 트리 구조로 표현한 것이 실행계획
- Execution Plan 기능으로 자신이 작성한 SQL이 테이블을 스캔하는지, 인덱스를 스캔하는지, 인덱스를 스캔한다면 어떤 인덱스인지 확인할 수 있음
- Execution Plan의 비용(Cost)은 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 표현한 값

### 옵티마이저 힌트
- 통계정보에 담을 수 없는 데이터 또는 업무 특성을 활용해 개발자가 직접 더 효율적인 액세스 경로를 찾아낼 수도 있음. 이럴 때 옵티마이저 힌트를 이용해 데이터 액세스 경로를 바꿀 수 있음
- 주요 경로만 개발자가 정하고 나머지는 자동으로 선택하게 할 수도 있음

## SQL 공유 및 재사용
### 소프트 파싱 vs 하드 파싱
- SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 '라이브러리 캐시'라고 함
- 라이브러리 캐시는 SGA의 구성요소임
- SGA는 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간
- SQL을 전달하면 DBMS는 SQL을 파싱하고 해당 SQL이 라이브러리 캐시에 존재하는지 확인함
- 캐시에서 찾으면 바로 실행 단계로 넘어가지만, 찾지 못하면 최적화 단계를 거침
- SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것을 소프트 파싱이라고 하고, 실패해 최적화 및 로우 소스 생성 단계까지 모두 거치는 것을 하드 파싱이라고 함
- SQL 최적화 과정은 왜 하드할까?
	- SQL 최적화는 엄청나게 많은 비용이 듬
	- CPU를 많이 소비하는 몇 안 되는 작업 중 하나

### 바인드 변수의 중요성
- 사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 가짐
- 컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관됨
- 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용
- 반면, SQL은 이름이 따로 없으며 전체 SQL 텍스트가 이름 역할을 함
- 처음 실행할 때 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용
- 공유 가능한 SQL
	- `SELECST * FROM CUSTOMER WHERE LOGIN_ID = 'oraking'` 이 SQL은 아래의 프로시저로 변환됨
	- `create procedure LOGIN_ORAKING( ) {...}`
	- 아래 처럼 파라미터 Driven 방식으로 프로시저를 생성할 수 있음
	- `create procedure LOGIN (login_id in varchar2) { ... }`
	- 그리고 이러한 프로시저를 생성하는 방법이 바인드 변수임
	- 바인드 변수를 사용하면 하드파싱이 최초 한 번만 일어나고 캐싱된 SQL을 공유할 수 있음

## 데이터 저장 구조 및 I/O 메커니즘
### SQL이 느린 이유
- 십중팔구 I/O 때문
- I/O = 잠(sleep)이다. OS 또는 I/O 서브 시스템이 I/O를 처리하는 동안 프로세스는 잠을 자기 때문
- 프로세스는 "실행 중인 프로그램"이며 생성(new) 이후 종료(terminted) 전까지 준비(ready)와 실행(running)과 대기(waiting) 상태를 반복함
- 실행 중인 프로세스는 interrupt에 의해 수시로 실행 준비 상태(Runnable Queue)로 전환했다가 다시 실행 상태로 전환함
- I/O 속도는 기본적으로 느림. 그렇기에 SQL이 느림. 디스크 I/O가 SQL 성능을 좌우한다고 해도 과언이 아님

### 데이터베이스 저장 구조
- 데이터를 저장하려면 먼저 테이블스페이스를 생성해야 함. 테이블스페이스는 세그먼트를 담는 콘테이너로, 여러 개의 데이터파일로 구성
- 테이블스페이스를 생성하면 세그먼트(테이블)를 생성
	- 테이블, 인덱스 처럼 데이터 저장공간이 필요한 오브젝트
- 세그먼트는 여러 익스텐트로 구성
- 파티션 구조가 아니라면 테이블도, 인덱스도 하나의 세그먼트
- 테이블 또는 인덱스가 파티션 구조라면, 각 파티션이 하나의 세그먼트가 됨
- LOB 칼럼은 그 자체가 하나의 세그먼트를 구성
- 익스텐트는 공간을 확장하는 단위
- 테이블이나 인덱스에 데이터를 입력하다 공간이 부족하면 테이블 스페이스로 부터 익스텐트를 추가로 할당받음
- 익스텐트는 연속된 블록들의 집합이기도 함
- 즉, 익스텐트 단위로 공간을 확장
- 사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록
- DB2, SQL Server 같은 DBMS는 블록 대신 페이지(page)라는 용어를 사용함
- 한 블록은 하나의 테이블이 독점함. 한 블록에 저장된 레코드는 모두 같은 테이블 레코드
- 세그먼트 공간이 부족하면 테이블스페이스로부터 익스텐트를 추가로 할당받는데, 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수 있음
- 모든 데이터 블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값을 가지며 이를 DBA라고 부름
- 간단히 정리하면 다음과 같음:
	- 블록: 데이터를 읽고 쓰는 단위
	- 익스텐트: 공간을 확장하는 단위. 연속된 블록 집합
	- 세그먼트: 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
	- 테이블스페이스: 세그먼트를 담는 콘테이너
	- 데이터파일: 디스크 상의 물리적인 OS 파일