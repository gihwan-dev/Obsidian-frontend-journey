디자인 시스템은 디자이너와 개발자 간의 공유된 어휘를 달성하기 위해 노력합니다. 시각적 스타일과 UI 컴포넌트를 구축하면서, 우리는 기능이 어떻게 구성되고 설정되는지에 대해 많은 결정을 내립니다.

- 이름은 무엇인가?
- 각 요소는 계층 구조에서 어떻게 구성되고 이름이 지정되는가?
- 어떤 옵션이 구성될 수 있으며, 각각은 어느 수준에서 노출되는가?
- 작은 부분들은 어떻게 모듈화하여 다른 곳에서 재사용할 수 있는가?
- 이것은 그것을 호출하거나 포함하는 다른 것들과 어떻게 상호작용하는가?

답변들은 기능이 어떻게 작동하는지 제어하는 방법을 설정하기 위한 공식적인 애플리케이션 프로그래밍 인터페이스(API)로 이어집니다. 이러한 대화 중에 실무자들은 종종 "이름 짓기가 어렵다"고 한탄합니다. 비공개 메시지에는 😩, 🙄, 😤와 같은 이모티콘이 표현됩니다. 그럼에도 불구하고, 이러한 결정, 모델 및 규칙은 디자인 시스템이 작동하게 하는 중요한 부분입니다.

API는 오랫동안 개발자의 영역이었습니다. 그러나 디자인 시스템이 개발자와 디자이너를 위해 구축되고 문서화된 라이브러리 전반에 걸쳐 공유된 어휘를 제공한다면, API는 코드와 디자인 도구에서 가능한 한 유사해야 하지 않을까요? 팀원들이 서로 다른 정신적 모델과 그들을 다르게 구축하도록 (점점 덜?) 제약하는 각기 다른 매체를 가지고 있을 때 이는 어렵습니다.

디자인 도구는 오랫동안 코드와 다른 방식으로 컴포넌트의 구성과 설정을 가능하게 했습니다. 디자이너들은 API라고 부르지는 않았지만 수년간 디자인 도구에서 API를 조작해 왔습니다. 그들의 실무는 투박하고 단절되어 있었습니다. Sketch의 심볼 오버라이드가 떠오르는데, 코드가 작동하는 방식과 매우 다른 이상한 속성과 괴상한 레이어를 강제했습니다. 결과는 좋지 않았고, 멀리 가지 못했으며, 공유 언어를 개선하려는 시도를 회피하는 편리하고 게으른 변명을 가능하게 했습니다. "절반의 조치가 한 도구에서 다른 도구로 선택을 효율적으로 번역하는 데 도움이 되지 않는다면 왜 신경 써야 하나요?"라고 그들은 주장했습니다. 게으른 부분을 제외하고는 이해가 됩니다.

분위기가 바뀌고 있습니다. 디자인 시스템은 부분적으로 디자인 도구의 빠른 발전 덕분에 디자인과 개발 전반에 걸쳐 API를 공유하는 데 훨씬 나아지고 있습니다. 예를 들어, Figma의 Variants는 코드가 디자이너 도구에서 어떻게 작동하는지 구체적으로 반영하는 것에 대한 생각을 열었습니다. 공유 API를 실현하기 위해, 다학제적 팀은 **무엇을 포함할지**, **언제 API를 워크플로우에 맞출지**, **어디서 함께 작성할지**, 그리고 그 결과로 **행동이 어떻게 변화하는지**를 식별해야 합니다.

![[Pasted image 20250504143338.png]]
## 1. 구조(Anatomy)
구조는 웹 마크업, 객체 구성 및 Figma 레이어에 매핑되는 요소와 그룹의 계층 구조를 설정합니다. 구조는 또한 자체 속성이 필요한 하위 컴포넌트와 다른 더 원자적인 요소에 대한 의존성을 드러내야 합니다.

```
코드 마크업
-----------

<Card metadata="" title="">
  <CardMedia> (extends <Image>)
  <CardDescription>    
    (slot)
  </CardDescription>
  <CardActionsArea>
     (slot to add Button, IconButton, or TextLink)       
  </CardActionsArea>
</Card>
```

예를 들어, 모듈식 Card 컴포넌트를 스케치하는 개발자는 일부 요소(`title`과 같은)가 속성으로 처리되고 다른 요소(`CardActionsArea`와 같은)가 구성 가능한 구조를 대략적으로 작성할 수 있습니다.

```
FIGMA 레이어
------------

Card
  ]-[ .Card (as Base Figma component)
    CardImage (extends Image as subcomponent)
    [-] CardContent
      ]-[ TitleArea
        Subtitle
        Title
      Body
      ]-[ Actions
        Button
        Button
```

반면, Figma 레이어에 구조를 매핑하는 디자이너는 비슷하지만 다른 구조를 개략적으로 잡을 수 있습니다. 일부 의도는 Figma 특화된 것입니다. 예를 들어 "타이 파이터"(`]-[`) 또는 "인셋"(`[-]`)은 자동 레이아웃 간격을 예상하거나 기본 컴포넌트 또는 하위 컴포넌트에 `.`을 앞에 붙이는 것과 같습니다.

그러나 이러한 빠른 초안은 현실적이면서도 피할 수 있는 차이점을 노출합니다. 차이점에는 요소 이름(`metadata`와 `subtitle`, `body`와 `description`), 계층 구조(`actions`가 `content`에 포함되는지 또는 형제인지), 그리고 하위 컴포넌트(`CardMedia`와 `CardImage`)가 포함됩니다.

![[Pasted image 20250504145558.png]]

## 2. 속성(Properties)
개발자와 디자인 도구 모두 일관된 속성 이름, 옵션 이름 및 기본값을 불러일으켜야 합니다.

```
Figma only:
- State  
  - default  
  - hover? (recommend: include)  
  - focus? (recommend: include)  
  - error  
  - errorHover? (recommend: omit)  
  - disabled  
  - readOnly

Both Figma & code:- required (false - default, true)  
- inlineLabel (false - default, true)  
- helperTextPlacement (right, bottom - default)

Code only:
- ariaLabel  
- disabled (in Figma, use States)  
- error (in Figma, use States)  
- errorEvent  
- errorText (in Figma, update text shown when in State=Error)  
- helperText (in Figma, show/hide and update text)  
- id  
- label (use .Label element)  
- readOnly (false - default, true) (in Figma, use States)  
- width
```

예를 들어, 두 도구 모두 `inlineLabel`(불리언 토글)과 `helperTextPlacement`(`right` 또는 `bottom`이라는 두 가지 이름이 지정된 옵션)에 대한 동일한 Dropdown 속성을 불러일으킬 수 있습니다. 반면에, 코딩된 컴포넌트는 일부 상태는 속성을 통해 활성화하고 다른 상태는 상호작용을 통해서만 트리거될 수 있습니다. 이 경우, Figma에서 디자이너를 위해 속성 및 상호작용 트리거 상태를 단일 메뉴로 통합하면서 일관된 옵션 레이블을 유지하는 것이 바람직할 수 있습니다. 마지막으로, 코드가 `aria-label`과 `id`와 같은 (많은?) 추가 속성을 포함하는 것은 매우 일반적입니다.
## 3. 레이아웃(Layout)
구조와 속성보다 덜 실체적이지만, 이러한 선택들을 요소별 너비, 높이, 간격, 유동성 및 반응형 중단점과 연관짓는 것이 중요합니다.

```
Width  
- Desktop: 1440px  
- Desktop/Tablet: 1024px  
- Tablet: 768px  
- Mobile: 368px
```

솔직히 말해, 이러한 메모들은 덜 구조화되어 있고 컴포넌트마다 상당히 다릅니다. 이를 초안 작성하기 위한 템플릿을 확립하는 것은 어려웠습니다. 그러나 우리는 항상 구조를 요소별로, 그룹별로 검토하여 도구 전반에 걸쳐 다양한 조건에서 항목이 어떻게 포함되고 유동적으로 배치되는지에 대해 논의하고 메모하는 것이 유용하다고 느꼈습니다.

## 디자인 시스템 워크플로우에 API를 적용하는 시기
2016년부터 EightShapes는 두 가지 핵심 단계에서 시작하여 고객과 함께 기능을 제공하는 방법을 발전시켜왔습니다: 디자이너가 개발자에게 **디자인**을 전달하면 개발자는 이를 **코딩**합니다. 이 프로세스는 수년에 걸쳐 확장되어 **계획**, **명세**(승인된 디자인), **문서화**(디자인 지침), 다른 디자이너가 재사용하는 **디자인 에셋**(Figma variants와 같은) 제작, 그리고 기능 **출시**와 같은 단계와 세부 단계를 추가하고 개선해왔습니다.

![[Pasted image 20250504151225.png]]

몇 년 전, 우리는 일부 팀이 **"인계(The Handoff)"** 라고 부르는 과도기적 순간을 인식했습니다. 이 때 "디자인"의 선형 경로가 다양한 것들을 생산하기 위해 분기됩니다. 이 순간은 디자이너와 개발자가 서로 다른 도구에서, 때로는 여러 플랫폼(웹, iOS, Android 등)에 걸쳐 점점 더 고립된 작업을 진행하게 합니다. 현재 제가 이끄는 디자인 시스템에서는 디자이너가 동일한 디자인 명세서를 _다섯 명의 서로 다른 사람들_에게 인계하며, 이들은 각기 다른 곳에서 결과물을 생산합니다! 따라서 개인이 제작 단계에 너무 깊이 들어가기 전에 API를 표준화하는 것이 매우 중요합니다.

## 소규모 팀을 위한: 작업 내 활동
일부 소규모 팀의 경우, API 표준화는 협업하는 한 명의 디자이너와 한 명의 개발자가 제작 초기 단계에서 동기화하는 과정으로 수행될 수 있습니다. 우리는 개발자에게 제안서 초안을 작성하는 작업을 할당하고, 전체 팀이 비평하며, 담당 디자이너가 디자인 도구와 문서에 미치는 영향에 대해 이야기하는 방식으로 성공을 거두었습니다.

![[Pasted image 20250504151455.png]]

## 많은 제작자 및/또는 결과물을 위한: 전담 공식 작업
반면에, 2명 이상의 개발자나 디자이너에게 인계할 때는 제작 전에 공식적인 **API 단계**를 선행해야 합니다. 이 작업은 오래 걸리지 않으며, "제작자들이 공유된 우려사항을 논의하고 결과물 전반에 걸쳐 잠정적인 API 방향에 동의했을 때" 완료됩니다. 물론, 일부 디자이너나 개발자들은 API 작업이 완료되기 전에 시작하고 싶어할 수 있습니다. 그런 경우, 각자는 API에 대한 합의가 초점을 맞추게 되면 리팩토링이 필요할 수 있다는 점을 인정해야 합니다.

![[Pasted image 20250504152620.png]]

## 기존 요소에서 시작하기: 계획 단계에서 평가
Material UI와 같은 기존 카탈로그에서 시작하는 것이 상당히 중요한 주제가 되었습니다(말장난 의도!). 기능 작업을 **계획**할 때 기존 API를 평가하는 것이 필수적입니다. 여기서 대화는 개발자와 디자이너의 결과물을 정렬하는 것뿐만 아니라, 채택된 라이브러리에서 팀이 준수해야 하거나 벗어나야 할 제약 사항을 식별하는 것이기도 합니다.

![[Pasted image 20250504152901.png]]

비슷하게, Sketch에서 Figma로 마이그레이션하는 또 다른 팀은 기존 디자인 명세서, 기존 Sketch 심볼, 그리고 — 가장 중요하게도 — 이미 존재하는 코드를 평가하기 위해 **Figma API** 단계를 사용했습니다. 이 단계를 삽입함으로써 각 디자이너가 개발자들을 참여시켜 구축 전에 검토하고 확인할 수 있게 했습니다. 이 과정이 힘들었나요? 처음에는 그렇게 느껴졌지만, 팀이 카탈로그를 조사하면서 상당한 시간을 절약하고 정렬을 개선했습니다.

![[Pasted image 20250504152946.png]]

![[Pasted image 20250504153455.png]]

**...템플릿에서 시작해야 합니다.** 친숙한 구조를 포함하고, 규칙(예: 속성 옵션을 나열하는 방법)을 암시하며, 힌트를 포함합니다.

![[Pasted image 20250504153801.png]]

**...그룹으로 비평해야 합니다.** 초안이 작성되면, 다학제적 팀으로서 API를 비평하는 것이 건강합니다. 대화는 복잡성에 따라 컴포넌트당 15분에서 1시간까지 지속됩니다. 팀원들이 요령을 터득하기 전에 몇 차례의 세션을 거칠 것으로 예상하세요.

**...비동기 검토를 위해 이용 가능해야 합니다.** 모든 사람이 모든 논의에 참석하지는 않지만, 모든 후속 담당자는 제안된 API에 의견을 제시할 기회를 가져야 합니다. 광범위한 공유 요구를 충족하는 기능의 경우, 핵심 팀은 종종 Slack이나 Teams를 통한 의견 요청을 통해 디자인 및/또는 개발 커뮤니티를 검토에 초대할 수도 있습니다.
## 에필로그: API 작성이 행동을 변화시키는 방법
이 접근 방식을 사용하는 팀들은 점차 함께 API를 구성하는 데 적응합니다. 팀이 만들면서 배우는 과정에서 차이점이 발생하기도 합니다. 결과물 전반에 걸쳐 API를 효과적으로 정렬하는 팀들은 다음과 같은 행동을 보입니다:

1. **개발자들이 디자이너를 초대하여** 속성과 구조에 대해 협업합니다. 역사적으로 자신들의 영역이었던 것을 독점하지 않습니다.
2. **디자인 명세서가 API 구조로 수렴됩니다**. 구조와 "변형"(일부 속성 구성) 섹션이 인계의 기반을 형성합니다.
3. **개발자와 디자이너가 자연스럽게 연결됩니다** 결과물이 발전함에 따라. 코딩은 기술적 제약을 드러냅니다. 디자인 명세서의 부족함이 드러납니다. Figma에서 작업하는 디자이너들은 코드가 작동하는 방식을 완전히 모방할 수 없는 한계에 부딪힙니다. 이에 대해 이야기해 봅시다.

이는 초기에 API를 초안 작성하는 것이 단순히 차이를 최소화하기 위한 것만은 아니라는 현실을 강화합니다. 또한 공유된 출발점을 통해 디자이너와 개발자 간의 협력적 기대와 행동을 고정시키는 것이기도 합니다. 멋진 교차 기능 팀 여러분, API 작업을 즐겁게 하세요!