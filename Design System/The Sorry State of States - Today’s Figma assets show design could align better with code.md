> [원문](https://medium.com/@nathanacurtis/the-sorry-state-of-states-89dd4668737e)

몇 년 전, 저는 "Crafting component API together"라는 글을 작성했습니다. Figma는 당시 지배적인 디자인 도구가 되었고 지금도 그 위치를 유지하고 있으며, 유용하고 사용하기 쉬운 API로 컴포넌트를 구성하는 기능은 계속 강화되고 있습니다. 라이브러리들도 더 깊게 자리를 잡았습니다.

그러나 최고의 시스템 디자이너들조차도 코드가 실제로 작동하는 방식을 모방할 기회를 놓치고 있습니다. 이는 텍스트 입력(text input), 텍스트 영역(text area), 드롭다운(dropdown), 체크박스(checkbox), 라디오 버튼(radio button)과 같은 상호작용 요소들의 `state` 속성의 좋지 않은 상태에서 더욱 명확하게 드러납니다.

이 글에서는 디자인 시스템이 Figma 에셋에서 코드 작동 방식과 일치하지 않게 `states`를 구성하는 방식을 살펴봅니다. 텍스트 입력은 **부분적인 옵션 조합 세트(partial sets)**, **상호 의존적인 속성(interdependent props)**, **불리언 대 열거형 옵션(booleans versus enumerated)**, 그리고 Figma 에셋을 순수하게 모델링하기 위해 어디까지 나아가야 하는지(또는 나아가지 말아야 하는지)에 대한 교훈을 제공합니다.

## 오늘날 상태(States)의 현황
'States'는 디자이너와 개발자들이 다양한 상황에 적용하는 일반적인 용어입니다. Eric Bailey가 작성한 사용자 대면 상태(user facing states)의 긴 목록은 이를 잘 보여줍니다. 총 38개의 상태가 있으며, `rest`(기본), `hover`(호버), `active`(활성) 부터 `disabled`(비활성화), `readonly`(읽기 전용), `selected`(선택됨), `deselected`(선택 해제)까지, 그리고 `loading`(로딩 중), `ghost origin`(고스트 원본), `dirty`(변경됨)와 같은 덜 일반적인 상태들까지 포함됩니다.

![[Pasted image 20250504122428.png]]

호기심 많은 Chrome 사용자들은 텍스트 입력을 선택하고, 마우스 오른쪽 버튼을 클릭해 '검사(Inspect)'를 선택하면 다양한 요소 상태(`:active`, `:hover`, `:focus`, ...)를 발견할 수 있습니다. 여기에는 프론트엔드 개발자가 CSS 조합을 통해 활용할 수 있는 HTML 폼 유효성 검사 후크(`:disabled`, `:valid`, `:invalid`, ...)의 강력한 세트도 포함되어 있습니다.

![[Pasted image 20250504122457.png]]

문제는 '상태(states)'라는 용어가 지나치게 일반적이라는 점입니다. 모든 가능한 상태들이 단순히 대안적인 관계가 아닙니다. 대신, 사용 가능한 상태들은 종종 논리적 관계를 갖고 조합해서 사용되는 상호 의존적인 개념들이 뒤섞인 형태입니다.

그러나 디자인 검토 토론, 디자인 명세서 섹션 헤더, 특히 Figma 에셋 속성에서 사용될 때: `state`는 충분히 모델링되지 않은 아이디어들을 모두 담는 포괄적인 용어가 되어버립니다.

![[Pasted image 20250504122525.png]]

텍스트 입력의 경우, 당연히 `hover`(호버)와 `active`(활성) 상태를 보여줄 것입니다. 이를 고려할 때, 첫 번째 상태를 `base`(기본)(이렇게 하지 마세요), `default`(기본값)(괜찮음), `enabled`(활성화됨)나 `initial`(초기)(더 나음) 또는 `rest`(정지)(가장 좋을까요?)라고 부를지 고민하게 됩니다. 아니, 그냥 `resting`(휴지)으로 정하죠. 우리의 본능은 이 문제를 빨리 넘어가는 것입니다.

![[Pasted image 20250504123437.png]]

그러다 복잡한 상황이 발생합니다. `disabled`(비활성화됨)는 어떨까요? 물론, 필요합니다. 그리고 `readonly`(읽기 전용)는요? 아, 이건 생각하지 못했네요. 분명히 `error`(오류) 상태는 필수입니다. `states` 세트는 점차 늘어나다가 충분히 다뤘다고 만족할 때 안정화됩니다. 디자이너들이 "Eric Bailey의 모든 상태"를 다 해결하지 못한다고 해서 비난받을 일은 아닙니다. 저도 그런 적 없습니다. 그 목록은 정말 길거든요!

## Figma 에셋에서의 현재 상태(States)

저는 Figma 커뮤니티에 게시된 다음 디자인 시스템들의 `Text input` / `Input` / 기타 Figma 컴포넌트들을 조사했습니다:
- Material 3 Design Kit
- Material UI for Figma (및 MUI X)
- Salesforce Components for Web | Lightning Design System v1
- Github Primer Web
- IBM Carbon Design System
- Atlassian ADS Components
- Oracle Redwood
- Newskit Component Library
- Shopify Polaris Components

![[Pasted image 20250504123949.png]]

`state` 속성 패턴은 제가 컨설팅하는 팀들에서 관찰한 것과 일치했습니다:

- **Hover**: 10개 중 6개는 `state`:`hover`(또는 `state`:`hovered`) 옵션을 지원합니다.
- **Active**: 2개는 `state`:`active` 옵션을 지원합니다.
- **Focus**: 10개 중 8개는 `state`:`focus`를 지원하며, 별도의 불리언 속성으로 `focus`를 제공하는 경우는 없었습니다.
- **Disabled**: 10개 중 9개는 `state`:`disabled`를 지원하며, 오직 하나(Atlassian)만이 `isDisabled`를 별도의 불리언 속성으로 구분했습니다.
- **Read only**: 10개 중 6개는 `state`:`readonly`를 지원하며, 불리언 속성으로 `readonly`를 제공하는 경우는 없었습니다.
- **Error**와 **Success**: 10개 중 8개는 `state`:`error`(또는 유사하게 명명된 유효성 검사) 옵션을 지원하며, 하나(Atlassian)만이 `error`를 별도의 불리언 속성으로 제공했습니다.

컴포넌트들은 때때로 `warning`, `skeleton`, `typing`과 같은 다른 `state` 옵션들을 포함했습니다. 한 컴포넌트는 심지어 `filled`를 포함했는데, 이는 여기서 다루지 않는 `value`와 `placeholder` 속성의 인접 상태 문제로 흘러갑니다.

어떤 Figma 에셋도 `readonly` + `focus` 또는 `hover` + `error`와 같은 타당한 상태 조합을 지원하지 않았습니다.
## 코드 라이브러리에서의 현재 상태(States)
해당 라이브러리들의 `Text input` 컴포넌트 코드를 비슷하게 검토한 결과, 다른 주요 모델이 발견되었습니다:

- **Hover**와 **Active**: 대부분의 코드 라이브러리는 이러한 상태들을 사용자 상호작용에 반응하는 암시적 상태로 구현합니다.
- **Disabled**와 **Read only**: 거의 모든 코드 라이브러리가 이러한 props를 구현하며, 두 props 모두 관례적으로 여겨질 만큼 충분히 일반적입니다.
- **Error**와 **Success**: 많은 코드 라이브러리는 오류 표시를 위해 `error`(또는 `inInvalid`, `hasError` 등) 불리언 prop을 구현합니다. GitHub Primer는 이진(binary)에서 열거형(enumerated)으로 확장된 `validationStatus` prop을 통해 `error`와 `success`를 구분합니다. 일부 코드 라이브러리는 오류 텍스트를 위한 `error` prop을 구현합니다.

Shopify Polaris의 React 컴포넌트는 컴포넌트 전반에 걸친 의도적인 관례임을 시사하는 `disabled`와 `readonly`에 대한 Typescript 인터페이스를 구현합니다. 이 라이브러리는 또한 강제 적용 가능한 `focused`를 구현합니다.

![[Pasted image 20250504130037.png]]

## 디자인과 코드가 다르다. 그래서 뭐?
증거는 명확합니다. `hover`와 `active` 같은 상호작용 상태를 넘어서, Figma 에셋과 코드 컴포넌트는 서로 다른 API 시그니처를 제공합니다. 사실, 더 정확히 말하자면: _제품 디자이너의 재사용을 위해 게시된_ 디자인 _에셋_은 제품 개발자가 사용하는 코드 에셋과 다릅니다.

시스템 디자이너가 시스템 개발자에게 전달한 디자인 솔루션이 코드에서 구현된 것과 완벽하게 일치할 수도 있습니다. 아니요. 제 경험에 따르면 그렇지 않습니다. 디자인 반복 작업과 명세서(종종 EightShapes Specs 플러그인으로 자동화됨)는 거의 항상 동일한 "모든 것을 담은 States" 접근 방식을 보여줍니다. 우리가 왜 신경 써야 할까요?

### 효율성, 사용성 및 만족도에 끼치는 부식적 영향
최소한, 대부분의 디자이너는 부정확하거나 불완전한 디자인 전달의 일반적인 함정을 알고 있습니다. 이는 다음과 같은 문제로 이어집니다:

1. **전달 과정의 마찰**은 제품 디자이너가 코드와 다른 모델을 사용하는 게시된 Figma 에셋을 통해 제품 개발자에게 전달할 때 발생합니다.
2. **Figma 에셋에서 부실하게 조직된 props**는 사용하기 더 어렵고, 실제로는 독립적인 다양한 선택지들을 하나 또는 몇 개의 props에 뒤섞어 놓습니다.
3. **개발자들의 지속적인 불신**과 **존중 부족**은 디자이너들이 컴포넌트 props를 효과적으로 모델링하기에 부족하거나 부적절하게 준비되었다고 보는 관점에서 비롯됩니다.

마지막 항목은 특히 아픕니다. 이는 일부 개발자들이 지속적으로 갖고 있는 "내 것에 손대지 마" 태도를 영속시키는데, 우리가 함께 컴포넌트 API를 만들기 위해 노력할 수 있는데도 말입니다. 이는 다른 날 다룰 주제입니다.

### 자동화에 미치는 제한적 영향
일부에게는 덜 가시적이지만 제가 현재 협업하는 많은 사람들에게 훨씬 더 중요한 것은, Figma API를 활용하여 시스템 표면의 점점 더 많은 영역을 자동화하고 정리하는 데 부정적인 영향을 미친다는 점입니다. 부실하게 모델링된 속성들은:

1. **자동화 기회를 제한**하여 디자인과 코드 라이브러리 간의 일치를 감사하고 보고하는 데 어려움을 줍니다.
2. **에셋을 데이터로 사용하는 능력을 제한**하여 정보 제공, 신뢰할 수 있는 출처로서의 역할, 심지어 코드 개발 자동화 기능까지 제한합니다.
3. **매핑 비용을 증가**시켜 Figma의 Code Connect와 같은 도구에서 복잡하고 (취약한?) 변환 작업이 필요하게 됩니다. 이는 피할 수 있었던 것입니다.

디자인을 포함한 라이브러리 전반에 걸친 API 일치에 대한 제 믿음은 2021년에 제가 이에 대해 글을 쓴 이후로 더욱 강화되었습니다. 많은 존경받는 디자인 시스템들이 불필요하게 코드와 다르게 발전하는 것을 볼 때(제가 작업하는 시스템들도 마찬가지로), 우리 모두가 더 나아지길 바랍니다. 이 특정 문제는 그리 어렵지 않습니다.

## 속성 조합 및 상호작용 모델링

그럼 단계별로 상태 속성들과 그 작동 방식을 살펴보겠습니다. 먼저 라디오 버튼과 체크박스에서 볼 수 있는 깔끔하게 결합된 `selected`와 `state`의 특성부터 시작하겠습니다. 이어서 텍스트 입력의 `disabled`, `readonly`, 유효성 검사 상태를 사용하여 속성들이 어떻게 결합되고 서로 상호작용하는지 알아보겠습니다.
### 조합의 완전한 세트
일부 유형의 상태는 관련 조합의 완전한 세트를 형성하기 위해 결합됩니다. 예를 들어, `Checkbox`와 `Radio button`은 상호작용 `state`(`rest`, `hover`, `active`, `focus`)와 `selected` 상태(`not selected`, `selected`)를 8가지 조합으로 결합합니다.

다음 표는 `state`와 `selected`의 모든 조합에 대해 해당 조합이 존재하며(✅로 표시됨) 별도의 시각적 디자인이 필요할 수 있음을 보여줍니다.

![[Pasted image 20250504131543.png]]

