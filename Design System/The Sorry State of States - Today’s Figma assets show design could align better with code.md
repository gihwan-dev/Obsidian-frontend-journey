> [원문](https://medium.com/@nathanacurtis/the-sorry-state-of-states-89dd4668737e)

몇 년 전, 저는 "Crafting component API together"라는 글을 작성했습니다. Figma는 당시 지배적인 디자인 도구가 되었고 지금도 그 위치를 유지하고 있으며, 유용하고 사용하기 쉬운 API로 컴포넌트를 구성하는 기능은 계속 강화되고 있습니다. 라이브러리들도 더 깊게 자리를 잡았습니다.

그러나 최고의 시스템 디자이너들조차도 코드가 실제로 작동하는 방식을 모방할 기회를 놓치고 있습니다. 이는 텍스트 입력(text input), 텍스트 영역(text area), 드롭다운(dropdown), 체크박스(checkbox), 라디오 버튼(radio button)과 같은 상호작용 요소들의 `state` 속성의 좋지 않은 상태에서 더욱 명확하게 드러납니다.

이 글에서는 디자인 시스템이 Figma 에셋에서 코드 작동 방식과 일치하지 않게 `states`를 구성하는 방식을 살펴봅니다. 텍스트 입력은 **부분적인 옵션 조합 세트(partial sets)**, **상호 의존적인 속성(interdependent props)**, **불리언 대 열거형 옵션(booleans versus enumerated)**, 그리고 Figma 에셋을 순수하게 모델링하기 위해 어디까지 나아가야 하는지(또는 나아가지 말아야 하는지)에 대한 교훈을 제공합니다.

## 오늘날 상태(States)의 현황
'States'는 디자이너와 개발자들이 다양한 상황에 적용하는 일반적인 용어입니다. Eric Bailey가 작성한 사용자 대면 상태(user facing states)의 긴 목록은 이를 잘 보여줍니다. 총 38개의 상태가 있으며, `rest`(기본), `hover`(호버), `active`(활성) 부터 `disabled`(비활성화), `readonly`(읽기 전용), `selected`(선택됨), `deselected`(선택 해제)까지, 그리고 `loading`(로딩 중), `ghost origin`(고스트 원본), `dirty`(변경됨)와 같은 덜 일반적인 상태들까지 포함됩니다.

![[Pasted image 20250504122428.png]]

호기심 많은 Chrome 사용자들은 텍스트 입력을 선택하고, 마우스 오른쪽 버튼을 클릭해 '검사(Inspect)'를 선택하면 다양한 요소 상태(`:active`, `:hover`, `:focus`, ...)를 발견할 수 있습니다. 여기에는 프론트엔드 개발자가 CSS 조합을 통해 활용할 수 있는 HTML 폼 유효성 검사 후크(`:disabled`, `:valid`, `:invalid`, ...)의 강력한 세트도 포함되어 있습니다.

![[Pasted image 20250504122457.png]]

문제는 '상태(states)'라는 용어가 지나치게 일반적이라는 점입니다. 모든 가능한 상태들이 단순히 대안적인 관계가 아닙니다. 대신, 사용 가능한 상태들은 종종 논리적 관계를 갖고 조합해서 사용되는 상호 의존적인 개념들이 뒤섞인 형태입니다.

그러나 디자인 검토 토론, 디자인 명세서 섹션 헤더, 특히 Figma 에셋 속성에서 사용될 때: `state`는 충분히 모델링되지 않은 아이디어들을 모두 담는 포괄적인 용어가 되어버립니다.

![[Pasted image 20250504122525.png]]

텍스트 입력의 경우, 당연히 `hover`(호버)와 `active`(활성) 상태를 보여줄 것입니다. 이를 고려할 때, 첫 번째 상태를 `base`(기본)(이렇게 하지 마세요), `default`(기본값)(괜찮음), `enabled`(활성화됨)나 `initial`(초기)(더 나음) 또는 `rest`(정지)(가장 좋을까요?)라고 부를지 고민하게 됩니다. 아니, 그냥 `resting`(휴지)으로 정하죠. 우리의 본능은 이 문제를 빨리 넘어가는 것입니다.

![[Pasted image 20250504123437.png]]

그러다 복잡한 상황이 발생합니다. `disabled`(비활성화됨)는 어떨까요? 물론, 필요합니다. 그리고 `readonly`(읽기 전용)는요? 아, 이건 생각하지 못했네요. 분명히 `error`(오류) 상태는 필수입니다. `states` 세트는 점차 늘어나다가 충분히 다뤘다고 만족할 때 안정화됩니다. 디자이너들이 "Eric Bailey의 모든 상태"를 다 해결하지 못한다고 해서 비난받을 일은 아닙니다. 저도 그런 적 없습니다. 그 목록은 정말 길거든요!

## Figma 에셋에서의 현재 상태(States)

저는 Figma 커뮤니티에 게시된 다음 디자인 시스템들의 `Text input` / `Input` / 기타 Figma 컴포넌트들을 조사했습니다:
- Material 3 Design Kit
- Material UI for Figma (및 MUI X)
- Salesforce Components for Web | Lightning Design System v1
- Github Primer Web
- IBM Carbon Design System
- Atlassian ADS Components
- Oracle Redwood
- Newskit Component Library
- Shopify Polaris Components

![[Pasted image 20250504123949.png]]

`state` 속성 패턴은 제가 컨설팅하는 팀들에서 관찰한 것과 일치했습니다:

- **Hover**: 10개 중 6개는 `state`:`hover`(또는 `state`:`hovered`) 옵션을 지원합니다.
- **Active**: 2개는 `state`:`active` 옵션을 지원합니다.
- **Focus**: 10개 중 8개는 `state`:`focus`를 지원하며, 별도의 불리언 속성으로 `focus`를 제공하는 경우는 없었습니다.
- **Disabled**: 10개 중 9개는 `state`:`disabled`를 지원하며, 오직 하나(Atlassian)만이 `isDisabled`를 별도의 불리언 속성으로 구분했습니다.
- **Read only**: 10개 중 6개는 `state`:`readonly`를 지원하며, 불리언 속성으로 `readonly`를 제공하는 경우는 없었습니다.
- **Error**와 **Success**: 10개 중 8개는 `state`:`error`(또는 유사하게 명명된 유효성 검사) 옵션을 지원하며, 하나(Atlassian)만이 `error`를 별도의 불리언 속성으로 제공했습니다.

컴포넌트들은 때때로 `warning`, `skeleton`, `typing`과 같은 다른 `state` 옵션들을 포함했습니다. 한 컴포넌트는 심지어 `filled`를 포함했는데, 이는 여기서 다루지 않는 `value`와 `placeholder` 속성의 인접 상태 문제로 흘러갑니다.

어떤 Figma 에셋도 `readonly` + `focus` 또는 `hover` + `error`와 같은 타당한 상태 조합을 지원하지 않았습니다.
## 코드 라이브러리에서의 현재 상태(States)
해당 라이브러리들의 `Text input` 컴포넌트 코드를 비슷하게 검토한 결과, 다른 주요 모델이 발견되었습니다:

- **Hover**와 **Active**: 대부분의 코드 라이브러리는 이러한 상태들을 사용자 상호작용에 반응하는 암시적 상태로 구현합니다.
- **Disabled**와 **Read only**: 거의 모든 코드 라이브러리가 이러한 props를 구현하며, 두 props 모두 관례적으로 여겨질 만큼 충분히 일반적입니다.
- **Error**와 **Success**: 많은 코드 라이브러리는 오류 표시를 위해 `error`(또는 `inInvalid`, `hasError` 등) 불리언 prop을 구현합니다. GitHub Primer는 이진(binary)에서 열거형(enumerated)으로 확장된 `validationStatus` prop을 통해 `error`와 `success`를 구분합니다. 일부 코드 라이브러리는 오류 텍스트를 위한 `error` prop을 구현합니다.

Shopify Polaris의 React 컴포넌트는 컴포넌트 전반에 걸친 의도적인 관례임을 시사하는 `disabled`와 `readonly`에 대한 Typescript 인터페이스를 구현합니다. 이 라이브러리는 또한 강제 적용 가능한 `focused`를 구현합니다.

![[Pasted image 20250504130037.png]]

## 디자인과 코드가 다르다. 그래서 뭐?
증거는 명확합니다. `hover`와 `active` 같은 상호작용 상태를 넘어서, Figma 에셋과 코드 컴포넌트는 서로 다른 API 시그니처를 제공합니다. 사실, 더 정확히 말하자면: _제품 디자이너의 재사용을 위해 게시된_ 디자인 _에셋_은 제품 개발자가 사용하는 코드 에셋과 다릅니다.

시스템 디자이너가 시스템 개발자에게 전달한 디자인 솔루션이 코드에서 구현된 것과 완벽하게 일치할 수도 있습니다. 아니요. 제 경험에 따르면 그렇지 않습니다. 디자인 반복 작업과 명세서(종종 EightShapes Specs 플러그인으로 자동화됨)는 거의 항상 동일한 "모든 것을 담은 States" 접근 방식을 보여줍니다. 우리가 왜 신경 써야 할까요?

### 효율성, 사용성 및 만족도에 끼치는 부식적 영향
최소한, 대부분의 디자이너는 부정확하거나 불완전한 디자인 전달의 일반적인 함정을 알고 있습니다. 이는 다음과 같은 문제로 이어집니다:

1. **전달 과정의 마찰**은 제품 디자이너가 코드와 다른 모델을 사용하는 게시된 Figma 에셋을 통해 제품 개발자에게 전달할 때 발생합니다.
2. **Figma 에셋에서 부실하게 조직된 props**는 사용하기 더 어렵고, 실제로는 독립적인 다양한 선택지들을 하나 또는 몇 개의 props에 뒤섞어 놓습니다.
3. **개발자들의 지속적인 불신**과 **존중 부족**은 디자이너들이 컴포넌트 props를 효과적으로 모델링하기에 부족하거나 부적절하게 준비되었다고 보는 관점에서 비롯됩니다.

마지막 항목은 특히 아픕니다. 이는 일부 개발자들이 지속적으로 갖고 있는 "내 것에 손대지 마" 태도를 영속시키는데, 우리가 함께 컴포넌트 API를 만들기 위해 노력할 수 있는데도 말입니다. 이는 다른 날 다룰 주제입니다.

### 자동화에 미치는 제한적 영향
일부에게는 덜 가시적이지만 제가 현재 협업하는 많은 사람들에게 훨씬 더 중요한 것은, Figma API를 활용하여 시스템 표면의 점점 더 많은 영역을 자동화하고 정리하는 데 부정적인 영향을 미친다는 점입니다. 부실하게 모델링된 속성들은:

1. **자동화 기회를 제한**하여 디자인과 코드 라이브러리 간의 일치를 감사하고 보고하는 데 어려움을 줍니다.
2. **에셋을 데이터로 사용하는 능력을 제한**하여 정보 제공, 신뢰할 수 있는 출처로서의 역할, 심지어 코드 개발 자동화 기능까지 제한합니다.
3. **매핑 비용을 증가**시켜 Figma의 Code Connect와 같은 도구에서 복잡하고 (취약한?) 변환 작업이 필요하게 됩니다. 이는 피할 수 있었던 것입니다.

디자인을 포함한 라이브러리 전반에 걸친 API 일치에 대한 제 믿음은 2021년에 제가 이에 대해 글을 쓴 이후로 더욱 강화되었습니다. 많은 존경받는 디자인 시스템들이 불필요하게 코드와 다르게 발전하는 것을 볼 때(제가 작업하는 시스템들도 마찬가지로), 우리 모두가 더 나아지길 바랍니다. 이 특정 문제는 그리 어렵지 않습니다.

## 속성 조합 및 상호작용 모델링

그럼 단계별로 상태 속성들과 그 작동 방식을 살펴보겠습니다. 먼저 라디오 버튼과 체크박스에서 볼 수 있는 깔끔하게 결합된 `selected`와 `state`의 특성부터 시작하겠습니다. 이어서 텍스트 입력의 `disabled`, `readonly`, 유효성 검사 상태를 사용하여 속성들이 어떻게 결합되고 서로 상호작용하는지 알아보겠습니다.
### 조합의 완전한 세트
일부 유형의 상태는 관련 조합의 완전한 세트를 형성하기 위해 결합됩니다. 예를 들어, `Checkbox`와 `Radio button`은 상호작용 `state`(`rest`, `hover`, `active`, `focus`)와 `selected` 상태(`not selected`, `selected`)를 8가지 조합으로 결합합니다.

다음 표는 `state`와 `selected`의 모든 조합에 대해 해당 조합이 존재하며(✅로 표시됨) 별도의 시각적 디자인이 필요할 수 있음을 보여줍니다.

![[Pasted image 20250504131543.png]]

Figma 컴포넌트에서 `Radio button` 상태를 구현할 때, `hover`, `active`, `focus`, `selected` 옵션을 가진 `state` 속성을 포함할 수 있습니다. 그러나 이렇게 하면 `selected`와 `hover`가 동시에 발생하는 것과 같은 가능한 조합이 누락됩니다. 이러한 조합은 `hover selected`와 같은 추가 `state` 옵션으로 추가될 _수_ 있지만, 복합 옵션 이름을 통해 모든 조합을 제공하는 미끄러운 경사면으로 빠질 위험이 있습니다. 더 나은 방법은 `selected`에 대한 별개의 Figma 변형 속성(옵션이 `true`와 `false`라 해도 시각적 디자인은 달라집니다)과 `state`로 관심사를 분리하는 것입니다.

![[Pasted image 20250504132033.png]]

체크박스의 세 번째 `checked` 상태인 `indeterminate`(부분 선택) 가능성은 12개의 가능한 조합을 만들어 냄으로써, 복합 용어의 열거형 `state` 목록이 덜 바람직하게 됩니다. 또한, `checked` 속성은 이진 변형에서 `not checked`(기본값), `indeterminate`(부분 선택), `checked`(선택됨)라는 열거형 옵션을 드러내는 것으로 바뀌게 됩니다.

![[Pasted image 20250504132334.png]]

용감하게 Eric Bailey의 상태 목록을 자세히 검토한 분들은 `Deselected`(선택 해제됨)와 같은 더 많은 관련 고려 사항을 발견할 수 있을 것입니다. 대부분의 팀에게는 `Deselected`(`Selected`에서 변경된 상태)를 `Rest`(선택되지도 상호작용하지도 않은 상태)와 구분하여 포함하는 것은 비현실적입니다.

### 부분적인 조합 세트
`disabled` 속성은 다릅니다. 이는 `true` 또는 (기본적으로) `false`로 설정되는 변형입니다. 비활성화된(disabled) 컨트롤은 본질적으로 `rest` 상태에 있으며, 시각적으로 구분되고 `hover`, `active`, `focus` 상태는 관련이 없습니다.

![[Pasted image 20250504132715.png]]

결과적으로, 디자이너는 선택해야 합니다: `disabled`를 상호작용 `state`와 분리하거나, `disabled`를 `state`의 옵션으로 포함시킬 수 있습니다. Figma 에셋이 rest 상태가 아닌 disabled 상태를 구현하지 않는 한, 두 선택 모두 8개의 가능한 조합 중 5개의 부분 세트로 귀결됩니다.

![[Pasted image 20250504132745.png]]

`disabled` 옵션을 `state` 차원에 넣는 것이 편리할까요? 물론, 쉬워 보입니다. 하지만 코드는 그런 방식으로 작동하지 않습니다. 게다가, `disabled`를 `state`에 통합하면 모델의 명확성과 의미가 줄어들고, 곧 살펴볼 다른 관계들을 제대로 모델링할 수 없게 됩니다(의도된 말장난입니다).

### 상호 의존적인 속성들
`readonly` 속성으로 이야기가 더 복잡해집니다. 이 속성도 코드에서는 관례적으로 불리언 속성입니다. `disabled`처럼 `readonly`도 기본적으로 `false`입니다. 그러나 `disabled`와 달리, `readonly`는 `rest`_와_ `focus`를 지원하지만 일반적으로 `hover`와 `active`는 지원하지 않습니다.

![[Pasted image 20250504133018.png]]

또한, `disabled`와 `readonly`는 절대 동시에 발생하지 않습니다. `readonly`_와_ `disabled` 모두 `true`로 설정되면, `disabled`가 우선시되고 `readonly`는 무시됩니다. 이렇게 이 속성들은 상호 의존적입니다.

디자이너가 7개의 유효한 조합을 모두 구현한다면, Figma는 이 경우를 충분히 잘 처리합니다. 우선순위가 높으므로 `disabled`가 먼저 오고, 그 다음 `readonly`, 그 다음 `state` 순서가 되어야 합니다. 컴포넌트 사용자가 `disabled`를 false로 설정하면, 컴포넌트는 다른 모든 `state`를 `rest`로 되돌립니다.

![[Pasted image 20250504133037.png]]

`disabled`와 `readonly` 모두를 `state` 속성의 옵션으로 통합할 수 있을까요? 예, 가능합니다. 그러나 여러 차원을 하나의 속성으로 결합하고 복합 이름을 사용하는 속성은 코드와 일치하지 않으며 확장성이 좋지 않습니다.
### 열거형 또는 불리언 props 선택하기
Error와 success 유효성 검증 상태는 더 많은 질문을 불러일으킵니다. `disabled`와 `readonly` 모두 명확하게 이진적이며, `true`와 `false` 값으로 쉽게 표현할 수 있습니다(Figma variant 속성으로 구축되었더라도). 일부 디자인 시스템은 `error` 상태만 제공하는데, 이는 이미 익숙한 선택(및 권장사항)을 제시합니다. 즉, 기본값이 `false`이고 `true`로 설정할 수 있는 `error` variant 속성을 제공하는 것입니다.

![[Pasted image 20250504133225.png]]

아래 조합 테이블은 흥미로운 질문을 제기합니다: 입력 필드가 `error` : `true`와 함께 `readonly` : `true` 또는 `disabled` : `true` 상태로 동시에 설정될 수 있을까요? 순수주의적 관점에서 보면, 네, 아마도 가능할 것입니다.

![[Pasted image 20250504134002.png]]

하지만 `error`(HTML에서는 `invalid`?)와 `disabled` 또는 `readonly`의 이러한 조합은 다음과 같은 더 중요한 고려사항을 수반합니다:

- 경쟁하는 시각적 신호: 무엇이 `error` 상태인지 versus `disabled` 상태인지를 나타내는 신호는 무엇인가요?
- 충돌하는 해결 방식: 입력 필드가 `error` 상태라면, 사용자는 문제를 해결하기 위해 해당 필드와 상호작용할 수 있어야 합니다. 그러나 `disabled` 상태라면, 상호작용이 불가능합니다.

이는 API 설계 이슈라기보다는 사용자 경험 디자인 이슈입니다. 가이드라인에서는 필요하고 사용자에게 직관적인 경우가 아니라면 이러한 조합을 피하고 다른 UI 패턴을 권장할 수 있습니다. 그러나 Figma 컴포넌트와 이를 구현하는 개발자들에게 전달되는 문서에 있어서는, 두 속성이 모두 `true`로 설정된 경우 어떤 일이 발생하는지 명확히 하기 위한 논의나 명시적인 자료가 필요합니다.

입력 필드가 `success` 상태(주로 초록색과 체크마크 아이콘 결합)도 구현한다면 속성은 더욱 복잡해집니다. 이는 `error` 상태(빨간색과 X 아이콘 사용 가능)의 반대입니다.

![[Pasted image 20250504134856.png]]

이 경우, `error`(또는 `invalid`)는 `success`(또는 `valid`)와 상호 배타적이며, 시각화된 `success` 상태는 `error`의 빨간색이나 `success`의 초록색 어느 것도 표시하지 않는 것과는 다릅니다. 따라서 `none`(기본값), `error`, `success` 옵션을 갖는 열거형 `validation` variant 속성을 고려해 보세요.

### 독립적인 prop과 다른 prop의 옵션 비교
지금까지 `focus`는 `rest`, `hover`, `active`를 포함하는 세트에서 상호 배타적인 옵션으로 간주되었습니다. 그러나 실제로 요소는 `hover`+`focus` 또는 `active`+`focus` 상태를 동시에 가질 수 있습니다.

`focus`(`true`,`false`)가 상호작용 `state`(`rest`, `hover`, `active`)와 별개의 속성이어야 할까요?

![[Pasted image 20250504135209.png]]

앞서 언급된 섹션에서 순수주의자가 된 디자이너는 잘못된 방향으로 관심사를 더 분리하고 기본값이 `false`인 `focus` variant 속성을 추가하려 할 수 있습니다. 그러나 이는 아마도 지나친 접근일 것입니다.

실용적인 관점에서, `focus` 속성을 `state` 속성과 분리하는 것은 실질적으로 필요하지 않습니다. 이유는 다음과 같습니다:

- **Focus는 거의 항상 클라이언트 측에서 트리거되며, 개발자의 설정이 아닙니다**: `focus`는 `hover`처럼 사용자 상호작용에 기반한 인터랙티브 상태입니다. 일부 라이브러리에서 제공하긴 하지만, 대부분의 개발자들은 `disabled`, `readonly` 또는 `error`와 달리 prop을 사용해 `focus`를 강제로 설정할 필요를 느끼지 않습니다.
    
- **Focus는 보통 구분되는 시각적 속성에 영향을 줍니다**: `focus`는 일반적으로 컨테이너 그림자나 별도의 포커스 링 요소를 표시하는 등의 시각적 속성에 영향을 미치며, 이는 `hover`나 `active`가 영향을 미치는 것(주로 컨테이너의 배경이나 테두리 색상)과는 구분됩니다.
    
- **그 외의 경우, Focus는 동일한 시각적 속성을 재정의합니다**: `focus`가 `hover`처럼 컨테이너 테두리 두께와 색상에 영향을 미치더라도, 요소가 `focus` 상태가 되면 `hover`나 `active`와 관련된 더 약한 시각적 신호는 거의 또는 전혀 중요하지 않게 됩니다. `focus`는 `disabled`가 `readonly`보다 우선하는 것처럼 `hover`보다 우선하며, `focus` + `hover`에 대한 관련된 세 번째 구분된 모습은 없습니다.

![[Pasted image 20250504135717.png]]
- **관례적으로 세트로 관련됨**: 이 세 가지는 매우 밀접하게 관련된 CSS 의사 클래스들로, 보통 그들의 존재로 설명되고 추구됩니다. `focus`를 구분한다면, `hover`와 `active`도 구분해야 할 것입니다. 여기서 더 나아가, `focus-within`을 추가로 구분할 때가 되었을까요? 저는 아직 이를 코딩하는 개발자를 만난 적이 없으며, 이를 해결하는 디자이너는 더욱 만나지 못했습니다. 우리 모두 언젠가 위대함을 추구할 수 있을까요?

평가된 코드 예제 중 단 하나만이 `focused` 속성이 없었습니다. Shopify Polaris만이 포커스 상태를 강제하기 위한 `focused` 속성을 제공했습니다. 그 목적을 추측해보면: 아마도 입력 필드 내부에 슬롯된 요소와의 상호작용이 부모 컨테이너의 포커스 상태를 강제해야 할 수도 있습니다? 또한, Shopify Polaris의 `focused` 속성은 속성을 적용하지 않고도 트리거되는 `focus` 인터랙티브 상태에 추가적인 것입니다.

인터랙티브 `state`:`rest`, `hover`, `active`로부터 `focus`:`true`, `false`를 분리하는 것이 필요하다고 확신하지 못합니다. 즉, 협업이 실패하거나(그럴 일은 없겠지만) 라이브러리 간의 자동화가 이를 요구할 때까지는(언젠가는 그럴 수 있습니다) 분리할 필요가 없습니다.

여기서 끝내는 것은 유용한 설명이 됩니다: 완벽한 일치—그리고 우리 디자인을 설정하기 위한 완벽한 모델—을 추구하는 것은 완벽에 도달하기 전에 동력을 잃습니다. 3년 전의 블로그 포스트는 디자인과 코드 자산 간의 `state` 차이를 훨씬 편안하게 받아들였습니다.

오늘날, 그 기준점은 더 깊은 통합과 더 강한 일치를 향해 이동했습니다. 이는 시스템을 추구하는 많은 팀들이 수년에 걸쳐 경험하게 될 동일한 여정입니다. 아마도 언젠가는 그들이 수렴할 것입니다. 아마도 곧.