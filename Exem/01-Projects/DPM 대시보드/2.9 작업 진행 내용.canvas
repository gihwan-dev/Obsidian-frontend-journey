{
	"nodes":[
		{"id":"7053965eb0478467","type":"text","text":"## 내용\n- **좌:** 현 대시보드 Alert Log\n- **우:** MFO의 Alert Log\n\n\n### 작업할 내용\n- MFO 처럼 Alert에 대한 자세한 View를 얻고싶어 함\n- 기존 대시보드 Alort Log의 최소 높이도 지정할 필요가 있어 보임\n- 칼럼 추가\n\t- Instnace\n\t- Time\n\t- Name\n\t- Value\n\t- Level\n\t- Log\n\t- User Script\n- Log 클릭시 상세 로그 윈도우(우측 이미지 참고)\n\t- ","x":-300,"y":-240,"width":560,"height":540},
		{"id":"e31c3b9ca14af169","type":"file","file":"Next.js/Pasted image 20260130163636.png","x":320,"y":-110,"width":400,"height":281},
		{"id":"f90c4ab0f7625996","type":"file","file":"Next.js/Pasted image 20260130163620.png","x":-760,"y":-119,"width":400,"height":298},
		{"id":"85103d0e595348e3","type":"text","text":"# 위젯 리사이즈 무한 리렌더링 검증 리포트\n\n> 검증일: 2026-02-06 (1차), 2026-02-09 (2차 — 경로 E/F/G 추가), 2026-02-09 (3차 — 정밀 타이밍 + 조건 분리)\n> 환경: Playwright 1.54.2 + Chromium, MSW seeded mock (faker seed 12345)\n\n## 배경\n\n대시보드 위젯 리사이즈 시 `Maximum update depth exceeded` 에러가 간헐적으로 발생한다는 보고가 있었다. 코드 수정 없이 재현 경로를 찾기 위해 **7가지** 에러 경로를 분석하고, **32개** E2E 시나리오로 검증했다.\n\n---\n\n## 3차 검증 핵심 발견 요약\n\n### 확인된 재현 경로 3가지\n\n1. **경로 A (CSS width 진동)**: WidthProvider 컨테이너 폭이 지속적으로 변동하면 DOM mutation이 **4127~6063**까지 폭주 (Scenario 13, 28)\n2. **경로 A+D+E (연속 리사이즈 + 뷰포트/폴링)**: 연속 5회 리사이즈에 뷰포트 진동 또는 폴링 변동을 추가하면 onLayoutChange가 **54~70회** 연쇄 발화 (Scenario 20, 22, 23, 29)\n3. **경로 E (mouseup 타이밍 locationInfo)**: handleResizeStop 직후 locationInfo 응답이 도착하면 연쇄 발화가 **30% 증폭** (Scenario 29: 70 vs S20: 54)\n\n### 재현이 안 되는 이유 (MSW 환경)\n\n1. **React Query structuralSharing**: MSW가 동일한 locationInfo를 반환하면 React Query가 참조를 재사용하여 `useEffect([locationInfo])` 가 재실행되지 않음\n2. **CSS width 진동의 자연 발생 부재**: E2E 환경에서는 스크롤바 출현/소멸이 정확히 경계 조건에 맞지 않음\n3. **Maximum update depth 임계값 미달**: layoutChangeCount 54~70은 React 한계(약 50회 동기 업데이트)에 근접하지만 도달하지는 않음\n\n### 고객사 환경에서 재현되는 이유 추정\n\n1. **서버 데이터 미묘한 변동**: 실서버의 locationInfo 응답에 타임스탬프, 상태값 등이 변동 → structuralSharing 우회 → `setServicesInfo` 실행 → `state.services = {}` 전체 재설정\n2. **자연 width 진동**: 스크롤바, 사이드바 토글, DevTools, 창 크기 조정 등으로 WidthProvider 폭 미세 변동\n3. **네트워크 지연 변동**: 실 네트워크 환경에서 locationInfo 응답 타이밍이 handleResizeStop 직후와 겹칠 확률\n\n---\n\n## 분석된 에러 경로 7가지\n\n### 경로 A: isResizing 가드 레이스 컨디션\n\n**파일**: `DashboardGrid.tsx:97-103`\n\n```\nhandleResizeStop 호출\n  → isResizing.current = false (가드 해제)\n  → handleResize(layout) → setLayouts() → 리렌더\n  → cols={{ lg: colCount }} 새 객체 생성\n  → react-grid-layout이 cols 변경 감지 시 onLayoutChange 발화\n  → handleLayoutChange 실행 (isResizing가 이미 false) → setLayouts()\n  → 무한 루프\n```\n\n**발화 조건**: `colCount`가 변경되거나, `rowHeight`가 소수점 단위로 계속 변하여 layout 재계산이 일어날 때.\n\n**3차 검증 결과**:\n- ✅ **S13**: CSS 진동 50ms → mutation **4127** (hasMutationFlood=true)\n- ✅ **S28**: CSS 진동 30ms + locationInfo mouseup 타이밍 → mutation **6063**\n- WidthProvider가 width 변경을 감지하고 onLayoutChange를 반복 호출하는 것이 명확히 확인됨\n\n### 경로 B: useMeasure ResizeObserver 피드백 루프\n\n**파일**: `useMeasure.ts:25-44`\n\n```\nResizeObserver 발화 → setRect() → 리렌더\n  → rowHeight 재계산 (containerHeight 기반)\n  → DashboardGridLayout에 새 rowHeight 전달\n  → react-grid-layout이 아이템 위치 재계산 → DOM 변경\n  → ResizeObserver 다시 발화\n  → 무한 루프\n```\n\n**3차 검증 결과**: S3, S10에서 미재현. rowHeight 소수점이 실제 DOM pixel 변화를 유발하기 어려움.\n\n### 경로 C: 데이터 폴링 + 리사이즈 타이밍 충돌\n\n**파일**: `ServiceWidgetContainer.tsx:66-128`\n\n```\n리사이즈 중 React Query refetch 도착 (3~5초 간격)\n  → data 변경 → instances 재계산 → useEffect → alarm store 업데이트\n  → 부모 리렌더 → sizeTierRenderer 새 객체 생성\n  → DashboardWidgetRenderer useMemo 무효화 → 자식 전체 리렌더\n  → handleResizeStop 시점과 겹치면 경로 A 트리거\n```\n\n**3차 검증 결과**:\n- ✅ **S23**: 이중 폴링 + 연속 리사이즈만으로 layoutChangeCount=**54** (뷰포트 진동 없이!)\n- 폴링 데이터 변동이 독립적으로 onLayoutChange 연쇄 발화를 유발\n\n### 경로 D: DashboardGridLayout 내부 콜백 재생성\n\n**파일**: `DashboardGridLayout.tsx:56-58`\n\n```js\nconst handleLayoutChange = (currentLayout, allLayouts) => {  // useCallback 미적용\n  onLayoutChange?.(currentLayout, allLayouts);\n};\n```\n\n매 렌더마다 새 함수 생성 → `ResponsiveGridLayout`의 `onLayoutChange` prop 변경 → `componentDidUpdate` 감지 가능.\n\n### 경로 E: locationInfo 폴링 → useEffect setLayouts 가드 우회 ⚠️ 핵심\n\n**파일**: `HomePage.tsx:15-26`, `DashboardGrid.tsx:106-111`\n\n```\nlocationInfo 폴링 도착 (5초 간격)\n  → useEffect → setServicesInfo(locationInfo.services)\n  → immer produce: state.services = {} 후 재할당 (전체 참조 변경)\n  → DashboardGrid의 widgets useMemo 재실행 (Object.values 새 배열)\n  → useEffect([widgets]) 트리거 → setLayouts + layoutStorage.save\n  → ⚠️ isResizing 가드가 useEffect에는 적용되지 않음!\n  → onLayoutChange 발화 → handleLayoutChange → setLayouts → 루프\n```\n\n**3차 검증 결과**:\n- ✅ **S29**: mouseup 직후 locationInfo 도착 → layoutChangeCount=**70** (S20의 54 대비 **30% 증가**)\n- ✅ **S28**: CSS 진동 + mouseup locationInfo → mutation **6063** (S13의 4127 대비 **46% 증가**)\n- **handleResizeStop 직후의 타이밍 윈도우가 핵심**임을 확인\n\n**코드 수준 취약점**:\n```typescript\n// DashboardGrid.tsx:67-73 — 가드 있음\nconst handleLayoutChange = useCallback((currentLayout, allLayouts) => {\n  if (isResizing.current) { return; }  // ← 가드 있음\n  setLayouts(allLayouts);\n}, []);\n\n// DashboardGrid.tsx:106-111 — 가드 없음!\nuseEffect(() => {\n  const mergedLayouts = layoutStorage.merge(storedLayouts, widgets);\n  setLayouts(mergedLayouts);  // ← isResizing 가드 없음!\n}, [widgets]);\n```\n\n### 경로 F: sizeTierRenderer 객체 리터럴 매 렌더 재생성\n\n**파일**: `ServiceWidgetContainer.tsx:137-162`, `DashboardWidgetRenderer.tsx:31-33`\n\n단독으로는 루프를 유발하지 않으나 다른 경로의 증폭 역할.\n\n### 경로 G: handleResize의 currentBreakpoint 의존성\n\n**파일**: `DashboardGrid.tsx:79-91, 97-103`\n\n**3차 검증 결과**:\n- ✅ **S22**: 뷰포트 진동 + 연속 리사이즈만으로 layoutChangeCount=**54** (폴링 없이!)\n- 뷰포트 변경으로 breakpoint 전환 시 handleResize 콜백 재생성이 연쇄 발화에 기여\n\n---\n\n## 검증 시나리오 및 결과\n\n### 감지 메커니즘\n\n| 방법 | 설명 |\n|------|------|\n| console.error 모니터링 | `Maximum update depth exceeded` 문자열 포함 여부 |\n| DOM mutation 카운팅 | `.react-grid-layout`에 MutationObserver 부착, 5초간 500회 초과 시 폭주 판정 |\n| onLayoutChange 카운팅 | `.react-grid-item` style 변경 MutationObserver로 프록시 측정 |\n| 페이지 응답성 확인 | 리사이즈 후 5초 내 `page.evaluate()` 완료 여부 |\n\n### 1차 결과 (Scenario 1-7)\n\n| # | 시나리오 | 검증 경로 | 소요 시간 | 결과 |\n|---|----------|-----------|-----------|------|\n| 1 | 기본 SE 리사이즈 (1280x720, colSpan 2→4) | A | 7.7s | **Pass** |\n| 2 | 브레이크포인트 경계 리사이즈 (1200x800) | A+B | 12.3s | **Pass** |\n| 3 | 수직 리사이즈로 높이 경계 돌파 (1280x600, +400px) | B | 7.4s | **Pass** |\n| 4 | 리사이즈 4초 유지 후 해제 (폴링 주기 대기) | C | 11.5s | **Pass** |\n| 5 | 300ms 간격 연속 리사이즈 5회 | A+D | 9.9s | **Pass** |\n| 6 | 뷰포트 빠른 변경 (1280→1100→900→800→1280) | B | 8.0s | **Pass** |\n| 7 | 1920x1080에서 다중 위젯 폴링 중 리사이즈 | C 복합 | 17.3s | **Pass** |\n\n### 2차 결과 (Scenario 8-14)\n\n| # | 시나리오 | 검증 경로 | 소요 시간 | 결과 |\n|---|----------|-----------|-----------|------|\n| 8 | 뷰포트 리사이즈 + 위젯 리사이즈 동시 | A+B | 12.8s | **Pass** |\n| 9 | 변동 폴링 데이터 + 네트워크 지연 중 리사이즈 | C | 17.9s | **Pass** |\n| 10a | 뷰포트 1210px 수직 리사이즈 스크롤바 | A+B | 7.5s | **Pass** |\n| 10b | 뷰포트 1215px 수직 리사이즈 스크롤바 | A+B | 7.7s | **Pass** |\n| 10c | 뷰포트 1216px 수직 리사이즈 스크롤바 | A+B | 7.5s | **Pass** |\n| 10d | 뷰포트 1220px 수직 리사이즈 스크롤바 | A+B | 7.7s | **Pass** |\n| 11 | 리사이즈 후 onLayoutChange 연쇄 발화 카운팅 | A+D | 7.8s | **Pass** |\n| 12 | 복합 스트레스 (뷰포트 경계 + 변동 폴링 + 리사이즈) | A+B+C+D | 17.4s | **Pass** |\n| **13** | **CSS 주입 width 진동 (50ms) + 리사이즈** | **A** | 8.2s | **❌ FAIL: mutation=4127** |\n| 14 | Ultra-wide 뷰포트 colCount 변동 중 리사이즈 | A | 8.6s | **Pass** |\n\n### 2차 결과 (Scenario 15-25)\n\n| # | 시나리오 | 검증 경로 | 소요 시간 | 결과 |\n|---|----------|-----------|-----------|------|\n| 15 | locationInfo 변동 폴링 + 6초 리사이즈 유지 | E | 19.7s | **Pass** |\n| 16 | locationInfo 간헐적 500 에러 + 8초 리사이즈 | E 변형 | 22.1s | **Pass** |\n| 17 | locationInfo + instanceOverview 동시 변동 + 8초 리사이즈 | E+C | 21.6s | **Pass** |\n| 18 | 위젯 수 동적 변경 + 10초 리사이즈 | E 극단 | 33.9s | **Pass** |\n| 19 | 브레이크포인트 전환 + locationInfo 변동 + 리사이즈 | E+G | 13.7s | **Pass** |\n| **20** | **전체 경로 복합 (이중 폴링 + 뷰포트 진동 + 연속 5회 리사이즈)** | **A+C+D+E+G** | 21.7s | **❌ FAIL: layoutChange=54** |\n| **21** | **S20 강화 (뷰포트 진동 6회 + 연속 7회 리사이즈 2초)** | **A+C+D+E+G** | 32.5s | **❌ FAIL: mutation=523** |\n| **22** | **조건 분리: 뷰포트 진동 + 연속 리사이즈 (폴링 없음)** | **A+G** | 18.8s | **❌ FAIL: layoutChange=54** |\n| **23** | **조건 분리: 이중 폴링 + 연속 리사이즈 (뷰포트 진동 없음)** | **C+E** | 20.8s | **❌ FAIL: layoutChange=54** |\n| 24 | baseline: 연속 리사이즈 5회 (1초 유지) | - | 17.6s | **Pass** |\n| 25 | baseline: 연속 리사이즈 5회 (holdMs 없음) | - | 13.3s | **Pass** |\n\n### 3차 결과 — 정밀 타이밍 (Scenario 26-32)\n\n| # | 시나리오 | 검증 경로 | 소요 시간 | 결과 |\n|---|----------|-----------|-----------|------|\n| 26 | mouseup 직후 50ms locationInfo 도착 (단일 리사이즈) | E 정밀 | 18.8s | **Pass** |\n| 27 | 스크롤바 자연 발생 + locationInfo 변동 (1215px, h600) | A+E | 20.6s | **Pass** |\n| **28** | **CSS width 진동 (30ms) + mouseup locationInfo 타이밍** | **A+E** | 18.9s | **❌ FAIL: mutation=6063** |\n| **29** | **연속 5회 리사이즈 + 매 mouseup마다 locationInfo 도착** | **A+D+E** | 33.2s | **❌ FAIL: layoutChange=70** |\n| 30 | 스크롤바 경계 + 이중 폴링 + mouseup 타이밍 (1215x600) | A+C+E | 21.6s | **Pass** |\n| 31 | CSS width 진동 20ms + 이중 폴링 (Maximum update depth 도달 시도) | A+C+E | 18.4s | **Pass** (assertion 넓음) |\n| 32 | 페이지 로드 직후 즉시 리사이즈 (500ms 대기) | E | 14.6s | **Pass** |\n\n---\n\n## 결과 분석\n\n### 실패 패턴 종합 (8개 시나리오)\n\n| 시나리오 | 실패 지표 | 경로 | 핵심 조건 |\n|---------|----------|------|----------|\n| S13 | mutation=4127 | A | CSS width 진동 50ms |\n| S20 | layoutChange=54 | A+C+D+E+G | 이중 폴링 + 뷰포트 진동 + 연속 5회 리사이즈 |\n| S21 | mutation=523 | A+C+D+E+G | S20 강화 (더 길고 빈번한 조건) |\n| S22 | layoutChange=54 | A+G | 뷰포트 진동 + 연속 5회 리사이즈 (폴링 없이) |\n| S23 | layoutChange=54 | C+E | 이중 폴링 + 연속 5회 리사이즈 (뷰포트 진동 없이) |\n| S28 | mutation=6063 | A+E | CSS 진동 30ms + mouseup locationInfo |\n| S29 | layoutChange=70 | A+D+E | 연속 5회 리사이즈 + mouseup locationInfo |\n\n### 핵심 발견 1: 두 독립 경로가 동일한 증상 유발\n\n**경로 A+G (뷰포트 진동)** 와 **경로 C+E (폴링 변동)** 가 **독립적으로** layoutChangeCount=54를 유발한다 (S22 vs S23).\n\n공통 필수 조건: **연속 리사이즈 5회 (각 1초 유지)**\n\n| | 연속 리사이즈만 | + 뷰포트 진동 | + 폴링 변동 | + 둘 다 |\n|--|---------------|-------------|------------|---------|\n| layoutChange | <30 (S24) | **54** (S22) | **54** (S23) | **54** (S20) |\n\n→ 뷰포트 진동과 폴링 변동은 각각 독립적으로 약 +24회의 추가 onLayoutChange를 유발\n\n### 핵심 발견 2: mouseup 타이밍이 연쇄 발화를 30% 증폭\n\n| | 임의 시점 폴링 (S20) | mouseup 직후 폴링 (S29) |\n|--|-------------------|----------------------|\n| layoutChange | 54 | **70** (+30%) |\n\n→ handleResizeStop → `isResizing.current = false` 직후의 타이밍 윈도우에서 locationInfo가 도착하면 useEffect([widgets]) → setLayouts가 가드 우회로 실행되어 연쇄가 심화\n\n### 핵심 발견 3: width 진동 + locationInfo 타이밍이 mutation을 46% 증가\n\n| | CSS 진동만 (S13) | CSS 진동 + mouseup locationInfo (S28) |\n|--|---------------|--------------------------------------|\n| mutation | 4127 | **6063** (+46%) |\n\n→ 두 경로(A+E)의 시너지 효과가 명확. width 진동이 DOM mutation을 유발하고, 동시에 locationInfo가 useEffect setLayouts를 가드 우회로 실행하면 mutation이 가속됨\n\n### 핵심 발견 4: 자연스러운 스크롤바 + locationInfo로는 아직 미재현\n\nS27(스크롤바 자연 발생 + locationInfo)과 S30(스크롤바 + 이중 폴링 + mouseup)은 통과.\n→ E2E 환경에서 스크롤바 출현/소멸이 **정확히** 경계 조건에 맞지 않음\n→ 고객사 환경에서는 다음이 추가 요인일 수 있음:\n  - 폰트 렌더링 차이에 의한 미세 높이 변동\n  - 브라우저 확대/축소\n  - OS 스크롤바 너비 차이 (Windows: 17px, macOS: 0-15px)\n\n---\n\n## 재현 경로 정리\n\n### 확정된 재현 조건 (E2E에서 증명됨)\n\n**필수 조건**:\n1. 연속 빠른 리사이즈 (3회 이상, 각 0.5초 이상 유지)\n\n**+ 다음 중 하나**:\n- a) WidthProvider 컨테이너 폭 변동 (CSS 진동, 뷰포트 변경, 스크롤바 등)\n- b) 폴링 데이터 변동 (locationInfo 또는 instanceOverview 응답 변경)\n\n**증폭 조건** (선택):\n- locationInfo 응답이 handleResizeStop 직후(~100ms 이내)에 도착 → +30% 증폭\n- (a)와 (b) 동시 활성화 → +46% 증폭\n\n### 고객사 환경에서의 추정 재현 시나리오\n\n```\n사용자가 대시보드에서 위젯을 리사이즈한다 (SE corner 드래그)\n  → 리사이즈 중 locationInfo 5초 폴링 응답 도착\n  → 서버 데이터에 미묘한 변동 (타임스탬프, 상태값 등)\n  → React Query structuralSharing 우회 → data 참조 변경\n  → setServicesInfo → state.services = {} → 전체 재설정\n  → widgets useMemo 재실행 → 새 배열\n  → useEffect([widgets]) → setLayouts (isResizing 가드 없음!)\n  → cols={{ lg: colCount }} 새 객체 → onLayoutChange\n  → handleLayoutChange (isResizing=false) → setLayouts → 연쇄\n  → 동시에 스크롤바 출현/소멸로 width 진동 발생\n  → WidthProvider width 변경 → 추가 onLayoutChange\n  → 연쇄가 React 렌더링 한계를 초과\n  → \"Maximum update depth exceeded\" 에러\n  → 에러 경계 → 에러 페이지\n```\n\n---\n\n## 경로별 위험도 평가 (3차 업데이트)\n\n| 경로 | 위험도 | 3차 검증 결과 | 이유 |\n|------|--------|-------------|------|\n| **A** | **🔴 높음** | S13: mutation=4127, S28: mutation=6063 | WidthProvider width 변동 시 DOM mutation 폭주 확인. CSS 진동으로 재현됨. |\n| **E** | **🔴 높음** | S29: layoutChange=70 (mouseup 타이밍 시 30% 증폭) | `useEffect([widgets])`의 `isResizing` 가드 부재. mouseup 직후 타이밍에서 증폭 확인. |\n| **C** | **🟠 중-높** | S23: layoutChange=54 (독립 재현) | 폴링 변동만으로 연쇄 발화. 뷰포트 진동 없이도 layoutChange 54. |\n| **G** | **🟠 중-높** | S22: layoutChange=54 (독립 재현) | 뷰포트 진동만으로 연쇄 발화. 폴링 없이도 layoutChange 54. |\n| **D** | **🟡 중간** | 간접 기여 | useCallback 미적용이 다른 경로의 증폭 요인. |\n| B | 🟢 낮음 | S3, S10: 미재현 | rowHeight 소수점이 실제 DOM pixel 변화를 유발하기 어려움. |\n| F | 🟢 낮음 | 단독 미재현 | sizeTierRenderer 매 렌더 재생성은 증폭 역할만. |\n\n---\n\n## 실행 방법\n\n```bash\n# Playwright + Chromium 설치 (최초 1회)\npnpm add -D @playwright/test@1.54.2\npnpm exec playwright install chromium\n\n# 전체 실행\npnpm exec playwright test --config e2e/playwright.config.ts\n\n# 개별 파일 실행\npnpm exec playwright test --config e2e/playwright.config.ts e2e/tests/widget-resize-loop.spec.ts\npnpm exec playwright test --config e2e/playwright.config.ts e2e/tests/widget-resize-loop-extended.spec.ts\npnpm exec playwright test --config e2e/playwright.config.ts e2e/tests/widget-resize-loop-path-efg.spec.ts\npnpm exec playwright test --config e2e/playwright.config.ts e2e/tests/widget-resize-loop-precision.spec.ts\n\n# 브라우저 띄워서 시각 확인\npnpm exec playwright test --config e2e/playwright.config.ts --headed\n\n# HTML 리포트 열기\npnpm exec playwright show-report\n```\n\n## 파일 구조\n\n```\ne2e/\n├── playwright.config.ts                            # Playwright 설정\n├── helpers/\n│   └── render-detector.ts                          # 렌더 루프 감지 + 드래그 유틸 + 폴링 인터셉트\n└── tests/\n    ├── widget-resize-loop.spec.ts                  # Scenario 1-7 (경로 A-D)\n    ├── widget-resize-loop-extended.spec.ts         # Scenario 8-14 (확장)\n    ├── widget-resize-loop-path-efg.spec.ts         # Scenario 15-25 (경로 E/F/G + 조건 분리)\n    └── widget-resize-loop-precision.spec.ts        # Scenario 26-32 (정밀 타이밍) ← 3차 신규\n```\n\n---\n\n## 다음 단계 (코드 수정이 목표일 때)\n\n### 즉시 수정 권장 (경로 E)\n```typescript\n// DashboardGrid.tsx:106-111\nuseEffect(() => {\n  if (isResizing.current) return;  // ← 가드 추가\n  const storedLayouts = layoutStorage.load();\n  const mergedLayouts = layoutStorage.merge(storedLayouts, widgets);\n  setLayouts(mergedLayouts);\n  layoutStorage.save(mergedLayouts);\n}, [widgets]);\n```\n\n### 단기 수정 권장 (경로 A)\n```typescript\n// DashboardGrid.tsx:123\nconst cols = useMemo(() => ({ lg: colCount }), [colCount]);\n// ...\n<DashboardGridLayout cols={cols} ... />\n```\n\n### 중기 수정 권장 (경로 D)\n```typescript\n// DashboardGridLayout.tsx:56-58\nconst handleLayoutChange = useCallback(\n  (currentLayout: Layout[], allLayouts: Layouts) => {\n    onLayoutChange?.(currentLayout, allLayouts);\n  },\n  [onLayoutChange]\n);\n```\n","x":-820,"y":400,"width":780,"height":1000},
		{"id":"707a1e4d11cb8024","type":"text","text":"cat ALERTLOG_POPUP_SPEC.md\n# Alert Log 팝업 창 (scriptWindow) 스펙 문서\n\n> 분석 일자: 2026-02-09\n> 대상: Alert Log History 그리드에서 Log/User Script 컬럼 클릭 시 표시되는 팝업 창\n\n---\n\n## 목차\n\n1. [개요](#1-개요)\n2. [트리거 조건](#2-트리거-조건)\n3. [창 구조 및 레이아웃](#3-창-구조-및-레이아웃)\n4. [창 생성 로직 (createLogWindow)](#4-창-생성-로직-createlogwindow)\n5. [창 열기 로직 (openScriptWindow)](#5-창-열기-로직-openscriptwindow)\n6. [컴포넌트 상세](#6-컴포넌트-상세)\n7. [테마별 스타일](#7-테마별-스타일)\n8. [DEADLOCK 특수 처리](#8-deadlock-특수-처리)\n9. [Full vs Light 버전 차이](#9-full-vs-light-버전-차이)\n10. [관련 파일 목록](#10-관련-파일-목록)\n\n---\n\n## 1. 개요\n\n이 팝업 창은 RTM의 **Alert Log History** 프레임 내 그리드에서 **Log** 또는 **User Script** 컬럼을 클릭하면 나타나는 `Exem.XMWindow`이다. 내부적으로 `scriptWindow`라는 이름의 프로퍼티로 관리된다.\n\n**역할**: 선택한 Alert의 상세 로그 내용을 Instance, DateTime, Status(Level) 정보와 함께 코드 에디터(SyntaxEditor)로 표시한다.\n\n**스크린샷 상의 모습**:\n```\n┌─────────────────────────────────────────────────┐\n│  Alert Log                          ⊕  ⊟  ✕    │\n├─────────────────────────────────────────────────┤\n│ Instance : ODIDODB1   DateTime : 2026-01-30     │\n│ 15:50:39   Status : [Warning]                   │\n├─────────────────────────────────────────────────┤\n│ 1  Tablespace Warning!                          │\n│ 2      Name   : DOID01_8K4M                     │\n│ 3      Status : ONLINE                          │\n│ 4      Usage  : 98.0 %                          │\n│ 5      Free   : 111086464 KB                    │\n│                                                 │\n│                                                 │\n└─────────────────────────────────────────────────┘\n```\n\n---\n\n## 2. 트리거 조건\n\n### 2.1 그리드 컬럼 클릭 → `cellclick` 이벤트\n\n`AlertLogHistoryFrame.js:508` / `AlertLogHistoryFrameLight.js` 에 정의된 `cellclick` 핸들러에서 클릭한 컬럼의 `dataIndex`를 판별한다.\n\n```\ncellclick 이벤트 발생\n     │\n     ├─ dataIndex === 'log'        → openScriptWindow('log', record)\n     ├─ dataIndex === 'userScript' → openScriptWindow('userScript', record)\n     └─ dataIndex === 'alertName'  → 다양한 분기 처리 (아래 참고)\n```\n\n### 2.2 alertName 컬럼 클릭 시 간접 트리거\n\n`alertName` 컬럼 클릭 시, Alert Type에 따라 다양한 팝업으로 분기되지만, **default** 케이스에서는 `log` 또는 `userScript`가 있으면 이 팝업을 연다:\n\n```javascript\n// AlertLogHistoryFrame.js:594-599\ndefault:\n    if (log) {\n        this.openScriptWindow('log', record);\n    } else if (userScript) {\n        this.openScriptWindow('userScript', record);\n    }\n    break;\n```\n\n### 2.3 Log/User Script 컬럼 renderer\n\nLog, User Script 컬럼에는 `columnStyleRender`가 적용되어 클릭 가능한 UI를 제공한다:\n\n```javascript\n// AlertLogHistoryFrame.js:1548-1554\ncolumnStyleRender: function(value, meta, record) {\n    if (value == undefined || value == '') { return; }\n    meta.style = 'cursor: pointer';\n    return value;\n}\n```\n\n- 값이 있을 때만 텍스트를 표시하고 `cursor: pointer` 스타일을 적용\n- Name(`alertName`) 컬럼에도 동일한 renderer 적용\n\n### 2.4 그리드 컬럼 정의\n\n| Header | dataIndex | Width | Type | Visible |\n|--------|-----------|-------|------|---------|\n| Instance (또는 Business) | `instanceName` | 70 | String | O |\n| Time | `time` | 80 | DateTime | O |\n| Name | `alertName` | 90 | String | O |\n| Value | `value` | 70 | Float | O |\n| Level | `level` | 70 | String | O |\n| **Log** | **`log`** | **70** | **String** | **O** |\n| **User Script** | **`userScript`** | **88** | **String** | **O** |\n| Alert Type | `alertType` | 80 | String | X (hidden) |\n| Resource Name | `resourceName` | 80 | String | X (hidden) |\n| Description | `description` | 80 | String | X (hidden) |\n| Origin Value | `originValue` | 80 | Float | X (hidden) |\n| Name | `originAlertName` | 90 | String | X (hidden) |\n| Alert Type | `originAlertType` | 80 | String | X (hidden) |\n\n---\n\n## 3. 창 구조 및 레이아웃\n\n```\nscriptWindow (Exem.XMWindow)\n│  width: 720, height: 520\n│  minWidth: 439, minHeight: 180\n│  layout: 'vbox'\n│  closeAction: 'hide'\n│\n├─ labelArea (Ext.container.Container)\n│  │  width: '100%', height: 30\n│  │  layout: { type: 'hbox', align: 'middle' }\n│  │  padding: '2 5 0 5'\n│  │  cls: 'frame-AlertLogHistoryFrame-UserScript-labelArea'\n│  │\n│  ├─ insTanceTEXT (Ext.form.Label)\n│  │     height: 15, margin: '0 20 0 0'\n│  │     예) \"Instance : ODIDODB1\"\n│  │\n│  ├─ dateLabelTEXT (Ext.form.Label)\n│  │     height: 15, margin: '0 20 0 0'\n│  │     예) \"DateTime : 2026-01-30 15:50:39\"\n│  │\n│  ├─ statusLabel (Ext.form.Label)\n│  │     width: 48, height: 15\n│  │     고정 텍스트: \"Status : \"\n│  │\n│  ├─ statusLabelTEXT (Ext.container.Container)\n│  │     width: 70, height: 15, margin: '0 15 0 0'\n│  │     동적 HTML로 Level 배지 표시\n│  │\n│  └─ [objectNameTEXT] (Ext.form.Label) ← DEADLOCK인 경우에만 추가\n│        height: 15\n│        예) \"Object Name : ...\"\n│\n└─ textArea (Ext.container.Container)\n   │  width: '100%', flex: 1\n   │  layout: 'fit'\n   │  padding: '5 5 5 5'\n   │  cls: 'frame-AlertLogHistoryFrame-UserScript-textArea'\n   │\n   └─ editor (Exem.SyntaxEditor)\n         width: '100%', height: '100%'\n         editTheme: 테마에 따라 결정\n```\n\n---\n\n## 4. 창 생성 로직 (createLogWindow)\n\n**위치**: `AlertLogHistoryFrame.js:2530` / `AlertLogHistoryFrameLight.js:1285`\n\n### 호출 시점\n\n1. **인스턴스 변경 시** (`AlertLogHistoryFrame.js:2939`): `setInstance()` 함수 내에서 `this.createLogWindow()` 호출\n2. **그리드 cellclick 시** (`AlertLogHistoryFrame.js:531`): `this.createLogWindow(alertName)` 호출\n\n> 매 cellclick마다 `createLogWindow`를 호출하여 scriptWindow를 재생성한다. 이는 DEADLOCK Alert일 때 `objectNameTEXT` 라벨을 조건부로 추가하기 위해서이다.\n\n### XMWindow 설정\n\n```javascript\nthis.scriptWindow = Ext.create('Exem.XMWindow', {\n    width      : 720,       // 기본 너비\n    height     : 520,       // 기본 높이\n    minWidth   : 439,       // 최소 너비\n    minHeight  : 180,       // 최소 높이\n    layout     : 'vbox',    // 수직 레이아웃\n    title      : common.Util.TR('USER SCRIPT'),  // 기본 타이틀 (열 때 변경됨)\n    closeAction: 'hide',    // 닫기 시 숨김 처리 (destroy가 아님)\n    listeners  : {\n        scope: this,\n        close: function() {\n            this.initialzeLogWindow();  // 에디터 텍스트 초기화\n        }\n    }\n});\n```\n\n### 에디터 테마 결정\n\n```javascript\nvar editTheme = 'ace/theme/eclipse';    // 기본 (밝은 테마)\n\nif (window.maxgaugeType == window.Maxgauge.RTM\n    && (Comm.themeType == ThemeType.Black || Comm.themeType == ThemeType.Gray)) {\n    editTheme = 'ace/theme/dark_imx';   // RTM + Black/Gray 테마일 때 다크 테마\n}\n```\n\n### Label 영역 구성\n\n| 컴포넌트 | 타입 | 크기 | margin | 초기값 |\n|----------|------|------|--------|--------|\n| `insTanceTEXT` | `Ext.form.Label` | h:15 | `0 20 0 0` | `this.instanceLabel` (\"Instance\" 또는 \"Business\") |\n| `dateLabelTEXT` | `Ext.form.Label` | h:15 | `0 20 0 0` | `this.dateTimeLabel` (\"DateTime : \") |\n| `statusLabel` | `Ext.form.Label` | w:48, h:15 | - | `this.statusLabelTitle` (\"Status : \") |\n| `statusLabelTEXT` | `Ext.container.Container` | w:70, h:15 | `0 15 0 0` | 빈 HTML |\n\n---\n\n## 5. 창 열기 로직 (openScriptWindow)\n\n**위치**: `AlertLogHistoryFrame.js:1399` / `AlertLogHistoryFrameLight.js:1139`\n\n### 파라미터\n\n| 파라미터 | 타입 | 설명 |\n|----------|------|------|\n| `columnDataIdx` | `string` | 클릭한 컬럼의 dataIndex (`'log'` 또는 `'userScript'`) |\n| `record` | `Ext.data.Model` | 그리드에서 선택한 row의 레코드 |\n\n### 처리 흐름\n\n```\nopenScriptWindow(columnDataIdx, record)\n│\n├─ 1. recordData[columnDataIdx] 값이 없으면 return (빈 값이면 팝업 안 열림)\n│\n├─ 2. record.data에서 destructuring:\n│     { instanceName, time, level, log, userScript }\n│\n├─ 3. columnDataIdx에 따라 Title과 에디터 텍스트 결정:\n│     ├─ 'log'        → title: 'Alert Log',    editorText: log\n│     └─ 'userScript' → title: 'User Script',  editorText: userScript\n│\n├─ 4. scriptWindow.setTitle(windowTitle)\n│\n├─ 5. Label 영역 업데이트:\n│     ├─ insTanceTEXT.setText(\"Instance : {instanceName}\")\n│     ├─ dateLabelTEXT.setText(\"DateTime : {formatted time}\")\n│     └─ statusLabelTEXT.update(Level 배지 HTML)\n│\n├─ 6. Level에 따른 배지 색상 결정:\n│     ├─ 'Warning'  → #DB8930 (주황색)\n│     └─ 'Critical' → #D92E2E (빨간색)\n│\n├─ 7. DEADLOCK인 경우 Object Name 표시:\n│     └─ objectNameTEXT.setText(\"Object Name : {editorText에서 파싱}\")\n│\n├─ 8. editor.setText(editorText)  // SyntaxEditor에 로그 내용 표시\n│\n└─ 9. scriptWindow.show()        // 팝업 표시\n```\n\n### Status 배지 렌더링 (Level)\n\n```javascript\nthis.statusLabelTEXT.update(`\n    <div style=\"\n        background: ${levelColor};     // Warning: #DB8930, Critical: #D92E2E\n        color: white;\n        border-radius: 8px;\n        text-align: center;\n        margin-left: 4px;\n        margin-right: 4px;\n        height: 15px;\n    \">\n        ${level}\n    </div>\n`);\n```\n\n| Level | 배지 색상 | 텍스트 |\n|-------|-----------|--------|\n| Warning | `#DB8930` (주황) | \"Warning\" |\n| Critical | `#D92E2E` (빨강) | \"Critical\" |\n\n### 창 닫기 시 (initialzeLogWindow)\n\n```javascript\ninitialzeLogWindow: function() {\n    this.editor.setText(null);  // SyntaxEditor 텍스트 초기화\n}\n```\n\n---\n\n## 6. 컴포넌트 상세\n\n### 6.1 Exem.XMWindow (scriptWindow)\n\n- ExtJS Window를 확장한 커스텀 윈도우\n- 드래그 이동 가능 (스크린샷의 ⊕ 아이콘)\n- 최소화(⊟), 닫기(✕) 버튼\n- 리사이징 가능 (minWidth: 439, minHeight: 180)\n- `closeAction: 'hide'`로 닫기 시 DOM에서 제거하지 않고 숨김 처리\n\n### 6.2 Exem.SyntaxEditor (editor)\n\n- ACE Editor 기반의 코드/로그 뷰어\n- 줄 번호(line number) 표시\n- 읽기 전용 텍스트 뷰어로 사용\n- 테마:\n  - 기본(밝은 테마): `ace/theme/eclipse`\n  - RTM Black/Gray 테마: `ace/theme/dark_imx`\n\n### 6.3 Label 영역\n\n| 영역 | 실제 표시 예시 |\n|------|---------------|\n| Instance | `Instance : ODIDODB1` |\n| DateTime | `DateTime : 2026-01-30 15:50:39` |\n| Status | `Status :` + 배지(`Warning` 또는 `Critical`) |\n| Object Name (DEADLOCK만) | `Object Name : {object_name}` |\n\n- `instanceLabel`은 Business Name 모드(`this.businessFlag`)일 때 \"Business\"로 변경\n- DateTime은 `common.Util.getDate(time)` 함수로 포맷팅\n\n---\n\n## 7. 테마별 스타일\n\n### 7.1 Label 영역 (`.frame-AlertLogHistoryFrame-UserScript-labelArea`)\n\n| 테마 | 배경색 | 텍스트 색상 |\n|------|--------|------------|\n| Default (White) | `#FFFFFF` | 기본값 (검정) |\n| Black | `#30333A` | `#FFFFFF` (흰색) |\n| Gray | `#30333A` | `#ABAEB5` (회색) |\n\n### 7.2 Text 영역 (`.frame-AlertLogHistoryFrame-UserScript-textArea`)\n\n| 테마 | 테두리 |\n|------|--------|\n| Default (White) | `1px solid #DDDDDD` |\n| Black | `1px solid #464A54` |\n| Gray | `1px solid #464A54` |\n\n### 7.3 CSS 파일 위치\n\n| 테마 | 파일 |\n|------|------|\n| Default | `RTM/styles/theme_v1.css:2466-2474` |\n| Black | `RTM/styles/theme_black_v1.css:2680-2687` |\n| Gray | `RTM/styles/theme_gray_v1.css:2729-2736` |\n\n---\n\n## 8. DEADLOCK 특수 처리\n\nAlert 이름이 `'DEADLOCK'`일 때 Label 영역에 **Object Name** 라벨이 추가된다.\n\n### createLogWindow에서의 처리\n\n```javascript\nif (alertName === 'DEADLOCK') {\n    const objectNameTEXT = Ext.create('Ext.form.Label', {\n        height: 15,\n        style: { whiteSpace: 'nowrap' },\n        text: common.Util.TR('Object Name')\n    });\n    labelArea.add(objectNameTEXT);\n    this.objectNameTEXT = objectNameTEXT;\n}\n```\n\n### openScriptWindow에서의 처리\n\n```javascript\nif (this.objectNameTEXT) {\n    const objectName = editorText.split('|')[1] || '';\n    this.objectNameTEXT.setText(`${common.Util.TR('Object Name')} : ${objectName}`);\n}\n```\n\n- `editorText`(로그 내용)에서 `|` 구분자로 분리하여 두 번째 부분을 Object Name으로 표시\n- `objectNameTEXT`가 존재하지 않으면 (DEADLOCK이 아니면) 건너뜀\n\n---\n\n## 9. Full vs Light 버전 차이\n\n| 항목 | Full (`AlertLogHistoryFrame.js`) | Light (`AlertLogHistoryFrameLight.js`) |\n|------|------|------|\n| `createLogWindow` 위치 | line 2530 | line 1285 |\n| `openScriptWindow` 위치 | line 1399 | line 1139 |\n| 창 설정 | 동일 (720×520) | 동일 (720×520) |\n| setTitle에 TR 적용 | `common.Util.TR(windowTitle)` | `windowTitle` 직접 사용 (TR 미적용) |\n| 나머지 로직 | 동일 | 동일 |\n\n> Light 버전은 Full 버전의 경량화된 복사본으로, `openScriptWindow`에서 `setTitle` 호출 시 `common.Util.TR()` 다국어 래핑 여부만 미세하게 다르다. 나머지 구조와 동작은 동일하다.\n\n---\n\n## 10. 관련 파일 목록\n\n| 파일 | 역할 |\n|------|------|\n| `RTM/Frame/AlertLogHistoryFrame.js` | Full 버전 - `createLogWindow()`, `openScriptWindow()`, `initialzeLogWindow()`, `cellclick` 핸들러 |\n| `RTM/Frame/AlertLogHistoryFrameLight.js` | Light 버전 - 동일 구조의 경량 버전 |\n| `RTM/styles/theme_v1.css` | 기본 테마 스타일 |\n| `RTM/styles/theme_black_v1.css` | Black 테마 스타일 |\n| `RTM/styles/theme_gray_v1.css` | Gray 테마 스타일 |\n\n---\n\n## 부록: alertName 클릭 시 분기 전체 맵\n\n`alertName` 컬럼 클릭 시 Alert Type에 따라 다양한 팝업으로 분기된다. 이 팝업(scriptWindow)은 **default** 케이스에서 열린다:\n\n| alertType / alertName | 동작 |\n|----------------------|------|\n| `SQL PLAN CHANGE` | `Frame.SQLProfileDetail` 생성 |\n| `TEMP TABLESPACE` | `ShowTempTablespaceUsageWin` 팝업 |\n| `PLAN CHANGE` | `ShowPlanDiffRTM` 팝업 |\n| `ACK FOR A BROADCASTED RES FROM A REMOTE INSTANCE` | `ShowTopGrid` (EVENT 타입) |\n| `CPU`, `FREE MEMORY`, `TOTAL MEMORY` | `ShowTopGrid` (OS 타입) |\n| `ACTIVE SESSIONS`, `WAITING SESSIONS`, `DEDICATED SESSIONS`, `LOCK WAITING SESSIONS` | `openWindowSessionManager` |\n| `LOCK`, `ENQ` | `ShowLockTree` |\n| `Alert log` | 무동작 (break) |\n| **그 외 전부** | **`openScriptWindow('log', record)` → 이 팝업 열림** |","x":-20,"y":400,"width":800,"height":1000},
		{"id":"9e7c36716e294cfd","x":880,"y":-360,"width":780,"height":980,"type":"text","text":"## 리렌더링 개선기\n\n- 프로파일링 기반으로 리렌더링 원인 분석\n- open 메서드의 참조 안정성이 유지되지 않고 있었음\n- 메모이제이션으로 개선\n\n**대시보드 드래그 리렌더링 측정 결과** (위젯 5개, 드래그 30틱)\n\n| | Before | After |\n|---|---|---|\n| 드래그 중 렌더 | 150회 (5 × 30) | 0회 |\n| 완료 후 렌더 | — | 5회 (5 × 1) |\n| **총 렌더** | **150회** | **5회** |\n| **절감율** | — | **96.7%** |\n\n### Befor\n![[화면_기록_2026-02-06_오후_4.16.56.gif]]\n\n### After\n![[화면_기록_2026-02-06_오후_4.18.41.gif]]"},
		{"id":"72f93adcce229814","x":2000,"y":740,"width":940,"height":1084,"type":"text","text":"## Live Metrics 분석\n\n### 현 상태\n![[Pasted image 20260209124002.png]]\n\n\n### 1. DOM Nodes: 23,315개 (매우 심각)\n\n가장 먼저 눈에 들어오는 수치입니다.\n\n- **상태:** 보통 구글에서는 권장 DOM 노드 수를 1,500개 미만, 많아도 3,000개 정도로 봅니다. 그런데 지금 **23,000개**가 넘습니다.\n    \n- **원인 추정:** 로그에 `react-grid-layout`, `react-resizable`이 보이는 것으로 보아, 대량의 데이터를 그리드나 테이블로 한 번에 렌더링하고 계신 것 같습니다.\n    \n- **문제점:** DOM이 이렇게 많으면 브라우저가 레이아웃을 계산(`Layouts / sec`)하고 스타일을 입히는(`Style recalcs / sec`) 데 엄청난 CPU 자원을 씁니다. 그래서 그래프가 톱니바퀴처럼 튀고 있는 것입니다.\n    \n\n### 2. JS Event Listeners: 12,679개 (메모리 누수 의심)\n\n- **상태:** 이벤트 리스너가 1만 2천 개가 넘습니다.\n    \n- **원인 추정:** 그리드의 각 셀(Cell)이나 리사이징 핸들마다 개별적으로 `onClick`, `onMouseDown` 같은 이벤트를 붙이신 것 같습니다.\n    \n- **문제점:** 메모리(`JS heap size`)를 많이 잡아먹고, 가비지 컬렉터(GC)가 빈번하게 돌아가게 만들어 끊김(Jank) 현상을 유발합니다.\n    \n\n### 3. INP (Interaction to Next Paint): 280ms (개선 필요)\n\n- **상태:** 상단 패널에 **280ms (needs improvement)**라고 떴습니다. 사용자가 클릭하거나 드래그했을 때 화면이 반응하기까지 0.28초가 걸린다는 뜻입니다.\n    \n- **체감:** 사용자는 \"버벅거린다\", \"드래그가 손을 못 따라온다\"라고 느끼게 됩니다.\n    \n- **로그 분석:** `pointer` 이벤트에서 `react-resizable-handle`을 조작할 때 176ms, 280ms씩 걸리고 있습니다. 리사이징할 때마다 거대한 DOM 트리를 다시 계산(Reflow)하느라 브라우저가 비명을 지르고 있는 상황입니다.\n    \n\n---\n\n### 💡 해결을 위한 액션 플랜 (Frontend Architecture 관점)\n\n기환님은 React와 아키텍처에 관심이 많으시니, 다음 기술적 도입을 강력 추천합니다.\n\n1. **가상화 (Virtualization) 도입 [필수]:**\n    \n    - 화면에 보이지 않는 2만 개의 DOM을 다 그릴 필요가 없습니다.\n        \n    - **`TanStack Virtual`** (구 react-virtual)을 도입해서 스크롤된 영역만 렌더링하세요. DOM 노드 수를 23,000개 → 100~200개 수준으로 줄일 수 있습니다. 이것만 해도 성능이 10배 이상 좋아질 겁니다.\n        \n2. **이벤트 위임 (Event Delegation):**\n    \n    - 12,000개의 리스너를 각 요소에 붙이지 말고, 부모 컨테이너 하나에 붙여서 이벤트를 처리하세요. (React 17+부터는 루트에 위임되지만, `react-grid-layout` 같은 라이브러리 사용 시 개별 컴포넌트 내부 구현을 확인해봐야 합니다.)\n        \n3. **렌더링 최적화:**\n    \n    - 리사이징 중에는 레이아웃 계산을 최소화하기 위해 **Debounce**나 **Throttle**을 적용하거나, 리사이징 중에는 '고스트(잔상)'만 보여주고 드롭했을 때 실제 데이터를 갱신하는 UX 패턴을 고려해보세요.\n        \n    - `React.memo`를 사용하여 불필요한 리렌더링을 막아야 합니다.\n        \n\n**결론:** 대시보드 UI 자체는 멋지게 만드셨을 것 같지만, 지금 상태로는 데이터가 조금만 더 늘어나도 브라우저가 멈출(Freezing) 위험이 있습니다. **DOM 개수 줄이기**가 최우선 과제입니다!\n\n혹시 `TanStack Table`이나 `Grid` 라이브러리를 어떻게 쓰고 계신지 코드 구조를 살짝 알려주시면 더 구체적인 최적화 팁을 드릴 수 있습니다."},
		{"id":"a67f5565086b6e40","x":3020,"y":740,"width":940,"height":1084,"type":"text","text":"## Performance 분석 - 폴링\n\n### 현 상태\n![[Pasted image 20260209123941.png]]\n\n### 1. CPU 사용률 49% & 레이아웃/스타일 재계산 (매우 높음)\n\n- **현상:** 폴링 중인데 CPU가 50% 가까이 치솟고 있고, `Layouts / sec`가 **61.4회**, `Style recalcs / sec`가 **83.4회**입니다.\n    \n- **의미:** 브라우저가 **1초에 60~80번씩 화면 구조를 다시 계산**하고 있습니다. 이는 60fps 게임을 돌리는 수준의 부하입니다.\n    \n- **진단:**\n    \n    - 혹시 폴링 주기가 너무 짧지 않은가요? (예: `requestAnimationFrame`이나 100ms 단위)\n        \n    - 데이터를 받아올 때마다 거대한 **DOM 트리(23,315개) 전체 혹은 상당 부분에 리렌더링(Re-render)**이 전파되고 있는 것으로 보입니다.\n        \n    - React DevTools의 \"Highlight updates when components render\"를 켜보면, 아마 데이터가 들어올 때마다 화면 전체가 번쩍거리고 있을 확률이 높습니다.\n        \n\n### 2. JS Heap 메모리의 톱니바퀴 패턴 (GC Thrashing)\n\n- **현상:** 보라색 그래프(JS Heap)를 보시면 **상승했다가 뚝 떨어지는 톱니 모양**이 아주 빈번하게 반복되고 있습니다.\n    \n- **의미:** 짧은 시간 동안 엄청난 양의 객체가 생성되었다가 가비지 컬렉터(GC)에 의해 삭제되고 있습니다.\n    \n- **진단:**\n    \n    - 폴링으로 받아오는 데이터(JSON)의 크기가 너무 크거나,\n        \n    - 데이터를 받아온 후 `setState`를 할 때, 기존 객체를 재활용하지 않고 매번 **거대한 배열/객체를 새로 복사(Deep Clone 등)**하고 있을 가능성이 큽니다.\n        \n    - 이 과정이 23,000개의 DOM 노드와 맞물려 메모리 누수 혹은 급격한 메모리 할당을 유발합니다.\n        \n\n### 3. DOM Nodes 23,315개의 영향\n\n- **진단:** 폴링 자체는 죄가 없지만, **23,000개의 DOM이 있는 상태에서 폴링을 하는 것**이 문제입니다.\n    \n- 데이터가 업데이트될 때마다 React는 가상 DOM(Virtual DOM)을 비교(Diffing)해야 하는데, 노드가 2만 개면 비교 연산 비용만으로도 CPU를 잡아먹습니다. 여기서 스타일 재계산까지 겹치니 280ms의 INP 지연이 발생하는 것입니다.\n    \n\n---\n\n### 🚀 기환님을 위한 긴급 처방 (React 관점)\n\n**1. 폴링 컴포넌트 격리 (State Colocation)**\n\n대시보드 전체를 감싸는 상위 컴포넌트에서 폴링 데이터를 관리하고 있나요?\n\n- **AS-IS:** 상위(Page)에서 fetch -> Props로 하위(Grid)에 전달 -> **Grid 전체 리렌더링**\n    \n- **TO-BE:** 데이터가 변하는 **작은 컴포넌트 내부에서만** 폴링하거나, 상태 관리 라이브러리(Zustand, Jotai 등)의 **Selector**를 사용하여, 데이터가 변경된 **해당 셀(Cell)만** 리렌더링되게 해야 합니다.\n    \n\n**2. `React.memo`로 방어벽 세우기**\n\n- 23,000개의 DOM을 가진 거대한 Grid 컴포넌트를 `React.memo`로 감싸세요.\n    \n- 폴링 데이터가 들어왔을 때, Grid의 Props가 바뀌지 않는다면(혹은 바뀌는 부분만 제외하고) 렌더링을 건너뛰도록 막아야 합니다.\n    \n\n**3. 개발자 도구 확인**\n\n지금 당장 **React DevTools Profiler**를 켜고 폴링이 한 번 일어날 때 **\"어떤 컴포넌트가 렌더링되는지\"** 확인해보세요. 의도치 않게 `Table`이나 `Grid` 전체가 렌더링되고 있다면 그것부터 끊어야 합니다.\n\n**요약:** 지금 그래프는 **\"데이터가 들어올 때마다 2만 개의 DOM이 반응하고 있음\"**을 보여줍니다. 이 연결고리를 끊는 것이 핵심입니다."},
		{"id":"9f590ee4ae96cad0","x":2000,"y":1880,"width":940,"height":1060,"type":"text","text":"## Performance 분석 - 리사이징\n### 1. \"보라색 벽\"의 정체: 끊임없는 스타일 재계산 (Recalculate Style)\n\n타임라인 중간에 빽빽하게 들어찬 보라색 블록들이 보이시나요?\n\n- **현상:** `border-bottom-color`, `width`, `height`, `transform` 등의 CSS 속성이 아주 짧은 간격으로 수백, 수천 번 변경되고 있습니다.\n    \n- **의미:** 사용자가 마우스를 1픽셀 움직일 때마다(MouseMove), React가 스타일을 변경하고 → 브라우저는 23,000개 DOM의 스타일을 다시 계산하고 있습니다.\n    \n- **치명타:** 특히 `width`나 `height`를 변경하는 것은 **Reflow(Layout)** 를 유발합니다. 즉, 요소의 크기가 바뀌었으니 주변 요소들의 위치까지 전부 다시 계산해야 하는데, DOM이 너무 많아서 이 계산 비용이 엄청난 것입니다.\n    \n\n### 2. Scripting(3.6초) vs Rendering(0.9초)\n\n- **Scripting (노란색):** React가 상태를 업데이트하고 Diffing 하는 데 걸리는 시간입니다. 이것도 길지만,\n    \n- **Rendering (보라색):** 단순히 계산된 스타일을 브라우저에 적용하는 데만 1초 가까이 쓰고 있습니다.\n    \n- **결론:** JS 로직도 무겁지만, **DOM 자체가 너무 비대해서 브라우저 렌더링 엔진이 과부하** 걸린 상태입니다.\n    \n\n### 3. 프레임 드랍 (Long Tasks)\n\n- 상단의 빨간색 띠들이 **\"Long Task\"** 경고입니다. 브라우저 메인 스레드가 50ms 이상 묶여 있어서 사용자의 입력에 반응할 수 없는 상태입니다.\n    \n- 이 상태에서 리사이징을 하면 마우스 커서는 저만치 가 있는데, 박스는 뚝뚝 끊기며 뒤늦게 따라오는 현상이 발생합니다.\n    \n\n---\n\n### 💡 리사이징 성능을 구하기 위한 해결책 (난이도순)\n\n기환님이 현재 구조를 크게 뜯어고치지 않고 시도해볼 수 있는 순서대로 제안합니다.\n\n#### 1. CSS `content-visibility: auto` (즉시 적용 가능)\n\n가장 쉬운 방법입니다. 리스트나 그리드 컨테이너의 CSS에 이 속성을 추가해보세요.\n\nCSS\n\n```\n.my-grid-item {\n  content-visibility: auto;\n  contain-intrinsic-size: 100px 500px; /* 대략적인 크기 지정 */\n}\n```\n\n- **효과:** 화면 밖에 있는 요소들의 렌더링 계산을 브라우저가 건너뜁니다. 2만 개의 DOM 중 화면에 안 보이는 것들은 계산에서 제외되므로 리사이징 속도가 빨라질 수 있습니다.\n    \n\n#### 2. 리사이징 UX 변경: \"Ghost Resizing\" (강력 추천)\n\n현재는 드래그하는 **\"실시간\"**으로 `width/height`를 바꾸고 있습니다. 이를 변경해야 합니다.\n\n- **AS-IS:** 드래그 → `setState` → 컴포넌트 리사이징 (무거움) → 드래그 (반복)\n    \n- **TO-BE:**\n    \n    1. 드래그 시작 시, 실제 컴포넌트 위에 **가벼운 점선 박스(Ghost)**만 띄웁니다.\n        \n    2. 드래그 중에는 이 점선 박스의 `transform`만 변경합니다. (Reflow 없이 GPU만 사용하므로 매우 빠름)\n        \n    3. 마우스를 놓는 순간(`onDragEnd`), 실제 컴포넌트의 데이터를 업데이트합니다.\n        \n- **효과:** 리사이징 중에 2만 개 DOM의 Reflow가 발생하지 않습니다. 사용자는 훨씬 부드럽다고 느낍니다.\n    \n\n#### 3. Throttle / requestAnimationFrame 적용\n\n만약 실시간 리사이징을 포기할 수 없다면, 이벤트 호출 빈도를 줄여야 합니다.\n\n- `onResize` 콜백이 매 픽셀마다 실행되지 않도록 `requestAnimationFrame`으로 감싸거나, `lodash.throttle`을 사용하여 16ms(60fps) 또는 30ms 간격으로만 상태를 업데이트하세요.\n    \n\n#### 4. (근본적 해결) 역시나 Virtualization\n\n결국 다시 원점입니다. **TanStack Virtual** 등을 도입하여 DOM 개수 자체를 줄이지 않으면, 어떤 최적화를 해도 2만 개 앞에서는 한계가 있습니다.\n\n**요약:** 지금 당장 가장 효과적인 것은 **\"2. Ghost Resizing\"** 패턴으로 UX를 바꾸는 것입니다. 실제 무거운 렌더링은 드래그가 끝났을 때 딱 한 번만 수행하도록 변경해보세요!"},
		{"id":"eb48a75cbfc19f3f","x":880,"y":740,"width":884,"height":1084,"type":"text","text":"## 폴링으로 인한 메인 쓰레드 블로킹 개선\n\n- INF 개선 필요\n- CPU 사용량이 과도하게 높음"}
	],
	"edges":[
		{"id":"b04eab823ddd55ff","fromNode":"f90c4ab0f7625996","fromSide":"right","toNode":"7053965eb0478467","toSide":"left"},
		{"id":"f8af05452109d61d","fromNode":"7053965eb0478467","fromSide":"right","toNode":"e31c3b9ca14af169","toSide":"left"}
	]
}