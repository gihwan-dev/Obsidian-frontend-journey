{
	"nodes":[
		{"id":"caa993161e4bc694","type":"group","x":2000,"y":-460,"width":3020,"height":1920,"label":"성능 이슈 분석"},
		{"id":"027eb2c579d3729f","type":"file","file":"Exem/01-Projects/DPM 대시보드/성능 이슈/Live Metrics 분석.md","x":2387,"y":-69,"width":400,"height":400},
		{"id":"7053965eb0478467","type":"text","text":"## 내용\n- **좌:** 현 대시보드 Alert Log\n- **우:** MFO의 Alert Log\n\n\n### 작업할 내용\n- MFO 처럼 Alert에 대한 자세한 View를 얻고싶어 함\n- 기존 대시보드 Alort Log의 최소 높이도 지정할 필요가 있어 보임\n- 칼럼 추가\n\t- Instnace\n\t- Time\n\t- Name\n\t- Value\n\t- Level\n\t- Log\n\t- User Script\n- Log 클릭시 상세 로그 윈도우(우측 이미지 참고)\n\t- ","x":-300,"y":-240,"width":560,"height":540},
		{"id":"e31c3b9ca14af169","type":"file","file":"Next.js/Pasted image 20260130163636.png","x":320,"y":-110,"width":400,"height":281},
		{"id":"f90c4ab0f7625996","type":"file","file":"Next.js/Pasted image 20260130163620.png","x":-760,"y":-119,"width":400,"height":298},
		{"id":"9e7c36716e294cfd","type":"text","text":"## 리렌더링 개선기\n\n- 프로파일링 기반으로 리렌더링 원인 분석\n- open 메서드의 참조 안정성이 유지되지 않고 있었음\n- 메모이제이션으로 개선\n\n**대시보드 드래그 리렌더링 측정 결과** (위젯 5개, 드래그 30틱)\n\n| | Before | After |\n|---|---|---|\n| 드래그 중 렌더 | 150회 (5 × 30) | 0회 |\n| 완료 후 렌더 | — | 5회 (5 × 1) |\n| **총 렌더** | **150회** | **5회** |\n| **절감율** | — | **96.7%** |\n\n### Befor\n![[화면_기록_2026-02-06_오후_4.16.56.gif]]\n\n### After\n![[화면_기록_2026-02-06_오후_4.18.41.gif]]","x":880,"y":-360,"width":780,"height":980},
		{"id":"2e9c4e82675bb7e5","type":"file","file":"Exem/01-Projects/DPM 대시보드/성능 이슈/Performance 분석 - 리사이징.md","x":2980,"y":-360,"width":980,"height":940},
		{"id":"259ff819ee64b52d","type":"file","file":"Exem/01-Projects/DPM 대시보드/성능 이슈/Live Metrics 분석.md","x":2020,"y":-360,"width":900,"height":940},
		{"id":"85103d0e595348e3","type":"text","text":"# 위젯 리사이즈 무한 리렌더링 검증 리포트\n\n> 검증일: 2026-02-06 (1차), 2026-02-09 (2차 — 경로 E/F/G 추가), 2026-02-09 (3차 — 정밀 타이밍 + 조건 분리)\n> 환경: Playwright 1.54.2 + Chromium, MSW seeded mock (faker seed 12345)\n\n## 배경\n\n대시보드 위젯 리사이즈 시 `Maximum update depth exceeded` 에러가 간헐적으로 발생한다는 보고가 있었다. 코드 수정 없이 재현 경로를 찾기 위해 **7가지** 에러 경로를 분석하고, **32개** E2E 시나리오로 검증했다.\n\n---\n\n## 3차 검증 핵심 발견 요약\n\n### 확인된 재현 경로 3가지\n\n1. **경로 A (CSS width 진동)**: WidthProvider 컨테이너 폭이 지속적으로 변동하면 DOM mutation이 **4127~6063**까지 폭주 (Scenario 13, 28)\n2. **경로 A+D+E (연속 리사이즈 + 뷰포트/폴링)**: 연속 5회 리사이즈에 뷰포트 진동 또는 폴링 변동을 추가하면 onLayoutChange가 **54~70회** 연쇄 발화 (Scenario 20, 22, 23, 29)\n3. **경로 E (mouseup 타이밍 locationInfo)**: handleResizeStop 직후 locationInfo 응답이 도착하면 연쇄 발화가 **30% 증폭** (Scenario 29: 70 vs S20: 54)\n\n### 재현이 안 되는 이유 (MSW 환경)\n\n1. **React Query structuralSharing**: MSW가 동일한 locationInfo를 반환하면 React Query가 참조를 재사용하여 `useEffect([locationInfo])` 가 재실행되지 않음\n2. **CSS width 진동의 자연 발생 부재**: E2E 환경에서는 스크롤바 출현/소멸이 정확히 경계 조건에 맞지 않음\n3. **Maximum update depth 임계값 미달**: layoutChangeCount 54~70은 React 한계(약 50회 동기 업데이트)에 근접하지만 도달하지는 않음\n\n### 고객사 환경에서 재현되는 이유 추정\n\n1. **서버 데이터 미묘한 변동**: 실서버의 locationInfo 응답에 타임스탬프, 상태값 등이 변동 → structuralSharing 우회 → `setServicesInfo` 실행 → `state.services = {}` 전체 재설정\n2. **자연 width 진동**: 스크롤바, 사이드바 토글, DevTools, 창 크기 조정 등으로 WidthProvider 폭 미세 변동\n3. **네트워크 지연 변동**: 실 네트워크 환경에서 locationInfo 응답 타이밍이 handleResizeStop 직후와 겹칠 확률\n\n---\n\n## 분석된 에러 경로 7가지\n\n### 경로 A: isResizing 가드 레이스 컨디션\n\n**파일**: `DashboardGrid.tsx:97-103`\n\n```\nhandleResizeStop 호출\n  → isResizing.current = false (가드 해제)\n  → handleResize(layout) → setLayouts() → 리렌더\n  → cols={{ lg: colCount }} 새 객체 생성\n  → react-grid-layout이 cols 변경 감지 시 onLayoutChange 발화\n  → handleLayoutChange 실행 (isResizing가 이미 false) → setLayouts()\n  → 무한 루프\n```\n\n**발화 조건**: `colCount`가 변경되거나, `rowHeight`가 소수점 단위로 계속 변하여 layout 재계산이 일어날 때.\n\n**3차 검증 결과**:\n- ✅ **S13**: CSS 진동 50ms → mutation **4127** (hasMutationFlood=true)\n- ✅ **S28**: CSS 진동 30ms + locationInfo mouseup 타이밍 → mutation **6063**\n- WidthProvider가 width 변경을 감지하고 onLayoutChange를 반복 호출하는 것이 명확히 확인됨\n\n### 경로 B: useMeasure ResizeObserver 피드백 루프\n\n**파일**: `useMeasure.ts:25-44`\n\n```\nResizeObserver 발화 → setRect() → 리렌더\n  → rowHeight 재계산 (containerHeight 기반)\n  → DashboardGridLayout에 새 rowHeight 전달\n  → react-grid-layout이 아이템 위치 재계산 → DOM 변경\n  → ResizeObserver 다시 발화\n  → 무한 루프\n```\n\n**3차 검증 결과**: S3, S10에서 미재현. rowHeight 소수점이 실제 DOM pixel 변화를 유발하기 어려움.\n\n### 경로 C: 데이터 폴링 + 리사이즈 타이밍 충돌\n\n**파일**: `ServiceWidgetContainer.tsx:66-128`\n\n```\n리사이즈 중 React Query refetch 도착 (3~5초 간격)\n  → data 변경 → instances 재계산 → useEffect → alarm store 업데이트\n  → 부모 리렌더 → sizeTierRenderer 새 객체 생성\n  → DashboardWidgetRenderer useMemo 무효화 → 자식 전체 리렌더\n  → handleResizeStop 시점과 겹치면 경로 A 트리거\n```\n\n**3차 검증 결과**:\n- ✅ **S23**: 이중 폴링 + 연속 리사이즈만으로 layoutChangeCount=**54** (뷰포트 진동 없이!)\n- 폴링 데이터 변동이 독립적으로 onLayoutChange 연쇄 발화를 유발\n\n### 경로 D: DashboardGridLayout 내부 콜백 재생성\n\n**파일**: `DashboardGridLayout.tsx:56-58`\n\n```js\nconst handleLayoutChange = (currentLayout, allLayouts) => {  // useCallback 미적용\n  onLayoutChange?.(currentLayout, allLayouts);\n};\n```\n\n매 렌더마다 새 함수 생성 → `ResponsiveGridLayout`의 `onLayoutChange` prop 변경 → `componentDidUpdate` 감지 가능.\n\n### 경로 E: locationInfo 폴링 → useEffect setLayouts 가드 우회 ⚠️ 핵심\n\n**파일**: `HomePage.tsx:15-26`, `DashboardGrid.tsx:106-111`\n\n```\nlocationInfo 폴링 도착 (5초 간격)\n  → useEffect → setServicesInfo(locationInfo.services)\n  → immer produce: state.services = {} 후 재할당 (전체 참조 변경)\n  → DashboardGrid의 widgets useMemo 재실행 (Object.values 새 배열)\n  → useEffect([widgets]) 트리거 → setLayouts + layoutStorage.save\n  → ⚠️ isResizing 가드가 useEffect에는 적용되지 않음!\n  → onLayoutChange 발화 → handleLayoutChange → setLayouts → 루프\n```\n\n**3차 검증 결과**:\n- ✅ **S29**: mouseup 직후 locationInfo 도착 → layoutChangeCount=**70** (S20의 54 대비 **30% 증가**)\n- ✅ **S28**: CSS 진동 + mouseup locationInfo → mutation **6063** (S13의 4127 대비 **46% 증가**)\n- **handleResizeStop 직후의 타이밍 윈도우가 핵심**임을 확인\n\n**코드 수준 취약점**:\n```typescript\n// DashboardGrid.tsx:67-73 — 가드 있음\nconst handleLayoutChange = useCallback((currentLayout, allLayouts) => {\n  if (isResizing.current) { return; }  // ← 가드 있음\n  setLayouts(allLayouts);\n}, []);\n\n// DashboardGrid.tsx:106-111 — 가드 없음!\nuseEffect(() => {\n  const mergedLayouts = layoutStorage.merge(storedLayouts, widgets);\n  setLayouts(mergedLayouts);  // ← isResizing 가드 없음!\n}, [widgets]);\n```\n\n### 경로 F: sizeTierRenderer 객체 리터럴 매 렌더 재생성\n\n**파일**: `ServiceWidgetContainer.tsx:137-162`, `DashboardWidgetRenderer.tsx:31-33`\n\n단독으로는 루프를 유발하지 않으나 다른 경로의 증폭 역할.\n\n### 경로 G: handleResize의 currentBreakpoint 의존성\n\n**파일**: `DashboardGrid.tsx:79-91, 97-103`\n\n**3차 검증 결과**:\n- ✅ **S22**: 뷰포트 진동 + 연속 리사이즈만으로 layoutChangeCount=**54** (폴링 없이!)\n- 뷰포트 변경으로 breakpoint 전환 시 handleResize 콜백 재생성이 연쇄 발화에 기여\n\n---\n\n## 검증 시나리오 및 결과\n\n### 감지 메커니즘\n\n| 방법 | 설명 |\n|------|------|\n| console.error 모니터링 | `Maximum update depth exceeded` 문자열 포함 여부 |\n| DOM mutation 카운팅 | `.react-grid-layout`에 MutationObserver 부착, 5초간 500회 초과 시 폭주 판정 |\n| onLayoutChange 카운팅 | `.react-grid-item` style 변경 MutationObserver로 프록시 측정 |\n| 페이지 응답성 확인 | 리사이즈 후 5초 내 `page.evaluate()` 완료 여부 |\n\n### 1차 결과 (Scenario 1-7)\n\n| # | 시나리오 | 검증 경로 | 소요 시간 | 결과 |\n|---|----------|-----------|-----------|------|\n| 1 | 기본 SE 리사이즈 (1280x720, colSpan 2→4) | A | 7.7s | **Pass** |\n| 2 | 브레이크포인트 경계 리사이즈 (1200x800) | A+B | 12.3s | **Pass** |\n| 3 | 수직 리사이즈로 높이 경계 돌파 (1280x600, +400px) | B | 7.4s | **Pass** |\n| 4 | 리사이즈 4초 유지 후 해제 (폴링 주기 대기) | C | 11.5s | **Pass** |\n| 5 | 300ms 간격 연속 리사이즈 5회 | A+D | 9.9s | **Pass** |\n| 6 | 뷰포트 빠른 변경 (1280→1100→900→800→1280) | B | 8.0s | **Pass** |\n| 7 | 1920x1080에서 다중 위젯 폴링 중 리사이즈 | C 복합 | 17.3s | **Pass** |\n\n### 2차 결과 (Scenario 8-14)\n\n| # | 시나리오 | 검증 경로 | 소요 시간 | 결과 |\n|---|----------|-----------|-----------|------|\n| 8 | 뷰포트 리사이즈 + 위젯 리사이즈 동시 | A+B | 12.8s | **Pass** |\n| 9 | 변동 폴링 데이터 + 네트워크 지연 중 리사이즈 | C | 17.9s | **Pass** |\n| 10a | 뷰포트 1210px 수직 리사이즈 스크롤바 | A+B | 7.5s | **Pass** |\n| 10b | 뷰포트 1215px 수직 리사이즈 스크롤바 | A+B | 7.7s | **Pass** |\n| 10c | 뷰포트 1216px 수직 리사이즈 스크롤바 | A+B | 7.5s | **Pass** |\n| 10d | 뷰포트 1220px 수직 리사이즈 스크롤바 | A+B | 7.7s | **Pass** |\n| 11 | 리사이즈 후 onLayoutChange 연쇄 발화 카운팅 | A+D | 7.8s | **Pass** |\n| 12 | 복합 스트레스 (뷰포트 경계 + 변동 폴링 + 리사이즈) | A+B+C+D | 17.4s | **Pass** |\n| **13** | **CSS 주입 width 진동 (50ms) + 리사이즈** | **A** | 8.2s | **❌ FAIL: mutation=4127** |\n| 14 | Ultra-wide 뷰포트 colCount 변동 중 리사이즈 | A | 8.6s | **Pass** |\n\n### 2차 결과 (Scenario 15-25)\n\n| # | 시나리오 | 검증 경로 | 소요 시간 | 결과 |\n|---|----------|-----------|-----------|------|\n| 15 | locationInfo 변동 폴링 + 6초 리사이즈 유지 | E | 19.7s | **Pass** |\n| 16 | locationInfo 간헐적 500 에러 + 8초 리사이즈 | E 변형 | 22.1s | **Pass** |\n| 17 | locationInfo + instanceOverview 동시 변동 + 8초 리사이즈 | E+C | 21.6s | **Pass** |\n| 18 | 위젯 수 동적 변경 + 10초 리사이즈 | E 극단 | 33.9s | **Pass** |\n| 19 | 브레이크포인트 전환 + locationInfo 변동 + 리사이즈 | E+G | 13.7s | **Pass** |\n| **20** | **전체 경로 복합 (이중 폴링 + 뷰포트 진동 + 연속 5회 리사이즈)** | **A+C+D+E+G** | 21.7s | **❌ FAIL: layoutChange=54** |\n| **21** | **S20 강화 (뷰포트 진동 6회 + 연속 7회 리사이즈 2초)** | **A+C+D+E+G** | 32.5s | **❌ FAIL: mutation=523** |\n| **22** | **조건 분리: 뷰포트 진동 + 연속 리사이즈 (폴링 없음)** | **A+G** | 18.8s | **❌ FAIL: layoutChange=54** |\n| **23** | **조건 분리: 이중 폴링 + 연속 리사이즈 (뷰포트 진동 없음)** | **C+E** | 20.8s | **❌ FAIL: layoutChange=54** |\n| 24 | baseline: 연속 리사이즈 5회 (1초 유지) | - | 17.6s | **Pass** |\n| 25 | baseline: 연속 리사이즈 5회 (holdMs 없음) | - | 13.3s | **Pass** |\n\n### 3차 결과 — 정밀 타이밍 (Scenario 26-32)\n\n| # | 시나리오 | 검증 경로 | 소요 시간 | 결과 |\n|---|----------|-----------|-----------|------|\n| 26 | mouseup 직후 50ms locationInfo 도착 (단일 리사이즈) | E 정밀 | 18.8s | **Pass** |\n| 27 | 스크롤바 자연 발생 + locationInfo 변동 (1215px, h600) | A+E | 20.6s | **Pass** |\n| **28** | **CSS width 진동 (30ms) + mouseup locationInfo 타이밍** | **A+E** | 18.9s | **❌ FAIL: mutation=6063** |\n| **29** | **연속 5회 리사이즈 + 매 mouseup마다 locationInfo 도착** | **A+D+E** | 33.2s | **❌ FAIL: layoutChange=70** |\n| 30 | 스크롤바 경계 + 이중 폴링 + mouseup 타이밍 (1215x600) | A+C+E | 21.6s | **Pass** |\n| 31 | CSS width 진동 20ms + 이중 폴링 (Maximum update depth 도달 시도) | A+C+E | 18.4s | **Pass** (assertion 넓음) |\n| 32 | 페이지 로드 직후 즉시 리사이즈 (500ms 대기) | E | 14.6s | **Pass** |\n\n---\n\n## 결과 분석\n\n### 실패 패턴 종합 (8개 시나리오)\n\n| 시나리오 | 실패 지표 | 경로 | 핵심 조건 |\n|---------|----------|------|----------|\n| S13 | mutation=4127 | A | CSS width 진동 50ms |\n| S20 | layoutChange=54 | A+C+D+E+G | 이중 폴링 + 뷰포트 진동 + 연속 5회 리사이즈 |\n| S21 | mutation=523 | A+C+D+E+G | S20 강화 (더 길고 빈번한 조건) |\n| S22 | layoutChange=54 | A+G | 뷰포트 진동 + 연속 5회 리사이즈 (폴링 없이) |\n| S23 | layoutChange=54 | C+E | 이중 폴링 + 연속 5회 리사이즈 (뷰포트 진동 없이) |\n| S28 | mutation=6063 | A+E | CSS 진동 30ms + mouseup locationInfo |\n| S29 | layoutChange=70 | A+D+E | 연속 5회 리사이즈 + mouseup locationInfo |\n\n### 핵심 발견 1: 두 독립 경로가 동일한 증상 유발\n\n**경로 A+G (뷰포트 진동)** 와 **경로 C+E (폴링 변동)** 가 **독립적으로** layoutChangeCount=54를 유발한다 (S22 vs S23).\n\n공통 필수 조건: **연속 리사이즈 5회 (각 1초 유지)**\n\n| | 연속 리사이즈만 | + 뷰포트 진동 | + 폴링 변동 | + 둘 다 |\n|--|---------------|-------------|------------|---------|\n| layoutChange | <30 (S24) | **54** (S22) | **54** (S23) | **54** (S20) |\n\n→ 뷰포트 진동과 폴링 변동은 각각 독립적으로 약 +24회의 추가 onLayoutChange를 유발\n\n### 핵심 발견 2: mouseup 타이밍이 연쇄 발화를 30% 증폭\n\n| | 임의 시점 폴링 (S20) | mouseup 직후 폴링 (S29) |\n|--|-------------------|----------------------|\n| layoutChange | 54 | **70** (+30%) |\n\n→ handleResizeStop → `isResizing.current = false` 직후의 타이밍 윈도우에서 locationInfo가 도착하면 useEffect([widgets]) → setLayouts가 가드 우회로 실행되어 연쇄가 심화\n\n### 핵심 발견 3: width 진동 + locationInfo 타이밍이 mutation을 46% 증가\n\n| | CSS 진동만 (S13) | CSS 진동 + mouseup locationInfo (S28) |\n|--|---------------|--------------------------------------|\n| mutation | 4127 | **6063** (+46%) |\n\n→ 두 경로(A+E)의 시너지 효과가 명확. width 진동이 DOM mutation을 유발하고, 동시에 locationInfo가 useEffect setLayouts를 가드 우회로 실행하면 mutation이 가속됨\n\n### 핵심 발견 4: 자연스러운 스크롤바 + locationInfo로는 아직 미재현\n\nS27(스크롤바 자연 발생 + locationInfo)과 S30(스크롤바 + 이중 폴링 + mouseup)은 통과.\n→ E2E 환경에서 스크롤바 출현/소멸이 **정확히** 경계 조건에 맞지 않음\n→ 고객사 환경에서는 다음이 추가 요인일 수 있음:\n  - 폰트 렌더링 차이에 의한 미세 높이 변동\n  - 브라우저 확대/축소\n  - OS 스크롤바 너비 차이 (Windows: 17px, macOS: 0-15px)\n\n---\n\n## 재현 경로 정리\n\n### 확정된 재현 조건 (E2E에서 증명됨)\n\n**필수 조건**:\n1. 연속 빠른 리사이즈 (3회 이상, 각 0.5초 이상 유지)\n\n**+ 다음 중 하나**:\n- a) WidthProvider 컨테이너 폭 변동 (CSS 진동, 뷰포트 변경, 스크롤바 등)\n- b) 폴링 데이터 변동 (locationInfo 또는 instanceOverview 응답 변경)\n\n**증폭 조건** (선택):\n- locationInfo 응답이 handleResizeStop 직후(~100ms 이내)에 도착 → +30% 증폭\n- (a)와 (b) 동시 활성화 → +46% 증폭\n\n### 고객사 환경에서의 추정 재현 시나리오\n\n```\n사용자가 대시보드에서 위젯을 리사이즈한다 (SE corner 드래그)\n  → 리사이즈 중 locationInfo 5초 폴링 응답 도착\n  → 서버 데이터에 미묘한 변동 (타임스탬프, 상태값 등)\n  → React Query structuralSharing 우회 → data 참조 변경\n  → setServicesInfo → state.services = {} → 전체 재설정\n  → widgets useMemo 재실행 → 새 배열\n  → useEffect([widgets]) → setLayouts (isResizing 가드 없음!)\n  → cols={{ lg: colCount }} 새 객체 → onLayoutChange\n  → handleLayoutChange (isResizing=false) → setLayouts → 연쇄\n  → 동시에 스크롤바 출현/소멸로 width 진동 발생\n  → WidthProvider width 변경 → 추가 onLayoutChange\n  → 연쇄가 React 렌더링 한계를 초과\n  → \"Maximum update depth exceeded\" 에러\n  → 에러 경계 → 에러 페이지\n```\n\n---\n\n## 경로별 위험도 평가 (3차 업데이트)\n\n| 경로 | 위험도 | 3차 검증 결과 | 이유 |\n|------|--------|-------------|------|\n| **A** | **🔴 높음** | S13: mutation=4127, S28: mutation=6063 | WidthProvider width 변동 시 DOM mutation 폭주 확인. CSS 진동으로 재현됨. |\n| **E** | **🔴 높음** | S29: layoutChange=70 (mouseup 타이밍 시 30% 증폭) | `useEffect([widgets])`의 `isResizing` 가드 부재. mouseup 직후 타이밍에서 증폭 확인. |\n| **C** | **🟠 중-높** | S23: layoutChange=54 (독립 재현) | 폴링 변동만으로 연쇄 발화. 뷰포트 진동 없이도 layoutChange 54. |\n| **G** | **🟠 중-높** | S22: layoutChange=54 (독립 재현) | 뷰포트 진동만으로 연쇄 발화. 폴링 없이도 layoutChange 54. |\n| **D** | **🟡 중간** | 간접 기여 | useCallback 미적용이 다른 경로의 증폭 요인. |\n| B | 🟢 낮음 | S3, S10: 미재현 | rowHeight 소수점이 실제 DOM pixel 변화를 유발하기 어려움. |\n| F | 🟢 낮음 | 단독 미재현 | sizeTierRenderer 매 렌더 재생성은 증폭 역할만. |\n\n---\n\n## 실행 방법\n\n```bash\n# Playwright + Chromium 설치 (최초 1회)\npnpm add -D @playwright/test@1.54.2\npnpm exec playwright install chromium\n\n# 전체 실행\npnpm exec playwright test --config e2e/playwright.config.ts\n\n# 개별 파일 실행\npnpm exec playwright test --config e2e/playwright.config.ts e2e/tests/widget-resize-loop.spec.ts\npnpm exec playwright test --config e2e/playwright.config.ts e2e/tests/widget-resize-loop-extended.spec.ts\npnpm exec playwright test --config e2e/playwright.config.ts e2e/tests/widget-resize-loop-path-efg.spec.ts\npnpm exec playwright test --config e2e/playwright.config.ts e2e/tests/widget-resize-loop-precision.spec.ts\n\n# 브라우저 띄워서 시각 확인\npnpm exec playwright test --config e2e/playwright.config.ts --headed\n\n# HTML 리포트 열기\npnpm exec playwright show-report\n```\n\n## 파일 구조\n\n```\ne2e/\n├── playwright.config.ts                            # Playwright 설정\n├── helpers/\n│   └── render-detector.ts                          # 렌더 루프 감지 + 드래그 유틸 + 폴링 인터셉트\n└── tests/\n    ├── widget-resize-loop.spec.ts                  # Scenario 1-7 (경로 A-D)\n    ├── widget-resize-loop-extended.spec.ts         # Scenario 8-14 (확장)\n    ├── widget-resize-loop-path-efg.spec.ts         # Scenario 15-25 (경로 E/F/G + 조건 분리)\n    └── widget-resize-loop-precision.spec.ts        # Scenario 26-32 (정밀 타이밍) ← 3차 신규\n```\n\n---\n\n## 다음 단계 (코드 수정이 목표일 때)\n\n### 즉시 수정 권장 (경로 E)\n```typescript\n// DashboardGrid.tsx:106-111\nuseEffect(() => {\n  if (isResizing.current) return;  // ← 가드 추가\n  const storedLayouts = layoutStorage.load();\n  const mergedLayouts = layoutStorage.merge(storedLayouts, widgets);\n  setLayouts(mergedLayouts);\n  layoutStorage.save(mergedLayouts);\n}, [widgets]);\n```\n\n### 단기 수정 권장 (경로 A)\n```typescript\n// DashboardGrid.tsx:123\nconst cols = useMemo(() => ({ lg: colCount }), [colCount]);\n// ...\n<DashboardGridLayout cols={cols} ... />\n```\n\n### 중기 수정 권장 (경로 D)\n```typescript\n// DashboardGridLayout.tsx:56-58\nconst handleLayoutChange = useCallback(\n  (currentLayout: Layout[], allLayouts: Layouts) => {\n    onLayoutChange?.(currentLayout, allLayouts);\n  },\n  [onLayoutChange]\n);\n```\n","x":880,"y":780,"width":780,"height":1000},
		{"id":"707a1e4d11cb8024","type":"text","text":"# AlertLog 스펙\n\n1. 알람 데이터 수신\n2. 워커에서 알람 데이터 가공 후 등록된 모든 ALARM 프레임에 알림\n3. 알람 데이터 가공 상세\n    1. 알람 패킷 데이터\n        1. ex) \\[ time, server\\_type, server\\_id, 인스턴스명, 알람타입, 알람레벨, 알람명, 값, sms\\_flag, description \\]\n        2. \\[1770357120000, 2, 1, 'ORA12C', 'Index Unusable', 2, 'index unusable', 0, 0, 'IDX\\_IT\\_3\\_1(UNUSABLE)'\\]\n        3. ![](https://t25540965.p.clickup-attachments.com/t25540965/da8353cb-b394-4b17-85a3-233b1358f672/image.png)\n> Name : 알람명이 대문자로 치환되어 표현, Value: '', Log : description 원본 그대로 사용\n4.     1. 워커에서 가공되는 데이터\n        *   value 단위 변환 (TABLESPACE, DISK USAGE, DB WAIT 등)\n        *   log / descrip 정리 (CELL SERVER ALERT, FILE ALERT LOG 등)\n5.     1.  **alarmType 별 보정**\n        1. Tablespace, Tablespace Increase, Temp/Undo Tablespace, Disk Usage : **value** 값 화면에서 가공 ( value /= 100 )\n6.     1. 알람 **정보 저장 방식**\n        1. **일**반 알림\n            1. 같은 알람명이 들어오면 이전 기록을 덮어쓴다. → 항상 최신 1건만 남음.\n        2. EXA & Index Unusable 알림\n            1. 알람명 + descript 을 기준으로 저장하여 동일 알람명이라도 여러 건이 남을 수 있다.\n\n| alarmType | WS (Name / Value / Log) | Alert Log (Name / Value / Log) | Alert Log History (Name / Value / Log) |\n| ---| ---| ---| --- |\n| SERVER ALERT | Name: 원본 statName 유지Value: 음수면 `''`<br>Log: `''`로 강제 | Name: SERVER ALERT로 강제<br>Value: `''`<br>Log: `''` | Name: SERVER ALERT로 강제<br>Value: `''`<br>Log: `''` |\n| TABLESPACE | Name: `Tablespace:테이블스페이스명`으로 재구성Value: `/100` 적용<br>Log: 원본 유지 | Name: TABLESPACE로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 | Name: TABLESPACE로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 |\n| TEMP TABLESPACE | Name: 유지<br>Value: `/100` 적용<br>Log: 유지 | Name: TEMP TABLESPACE로 강제Value: WS 값 유지<br>Log: WS 값 유지 | Name: TEMP TABLESPACE로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 |\n| UNDO TABLESPACE | Name: 유지<br>Value: `/100` 적용<br>Log: 유지 | Name: UNDO TABLESPACE로 강제Value: WS 값 유지<br>Log: WS 값 유지 | Name: UNDO TABLESPACE로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 |\n| TABLESPACE INCREASE | Name: 유지<br>Value: `/100`<br>적용Log: 유지 | Name: TABLESPACE INCREASE로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 | Name: TABLESPACE INCREASE로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 |\n| DISK USAGE | Name: 비어있으면 `DISK USAGE`로 보정<br>Value: `/100` 적용<br>Log: 유지 | Name: DISK USAGE로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 | Name: DISK USAGE로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 |\n| DB WARNING | Name: 비어있으면 `DB WARNING`로 보정Value: 음수면 `''`Log: 유지 | Name: WS 값 그대로(대문자/공백 처리)<br>Value: WS 값 그대로<br>Log: WS 값 그대로 | Name: WS 값 그대로(대문자/공백 처리)<br>Value: WS 값 그대로<br>Log: WS 값 그대로 |\n| DB STAT | Name: 원본 유지<br>Value: 원본 유지<br>Log: 유지 | Name: WS 값 그대로(대문자 처리) Value: WS 값 그대로<br>Log: WS 값 그대로 | Name: WS 값 그대로(대문자 처리)<br>Value: WS 값 그대로<br>Log: WS 값 그대로 |\n| SGA FREE MEMORY | Name / Value / Log: 변경 없음 | Name: WS 값 그대로(대문자 처리) Value: WS 값 그대로<br>Log: WS 값 그대로 | Name: WS 값 그대로(대문자 처리)<br>Value: WS 값 그대로<br>Log: WS 값 그대로 |\n| DB WAIT | Name: 유지<br>Value: `(value / 100).toFixed(2)` 적용<br>Log: 유지 | Name: WS 값 그대로(대문자 처리) Value: WS 값 그대로<br>Log: WS 값 그대로 | Name: WS 값 그대로(대문자 처리)<br>Value: WS 값 그대로<br>Log: WS 값 그대로 |\n| ORACLE ALERT LOG | Name: 비어있으면 `ORACLE ALERT LOG`로 보정<br>Value: 음수면 `''`<br>Log: 유지 | Name: ORACLE ALERT LOG로 강제Value: WS 값 유지<br>Log: WS 값 유지 | Name: ORACLE ALERT LOG로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 |\n| USER ALERT LOG | Name: 비어있으면 `USER ALERT LOG`로 보정<br>Value: 음수면 `''`<br>Log: 유지 | Name: USER ALERT LOG로 강제Value: WS 값 유지<br>Log: WS 값 유지 | Name: USER ALERT LOG로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 |\n| FILE ALERT LOG | Name: 유지<br>Value: `''`로 강제<br>Log: 유지 | Name: FILE ALERT LOG로 강제<br>Value: WS 값 유지(`''`)<br>Log: WS 값 유지 | Name: FILE ALERT LOG로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 |\n| INDEX UNUSABLE | Name: 유지<br>Value: 유지<br>Log: 유지 | Name: INDEX UNUSABLE로 강제Value: `''`<br>Log: WS 값 유지 | Name: INDEX UNUSABLE로 강제<br>Value: `''`<br>Log: WS 값 유지 |\n| DEADLOCK | Name: 유지<br>Value: 유지<br>Log: 유지 | Name: DEADLOCK로 강제<br>Value: `''`<br>Log: WS 값 유지 | Name: DEADLOCK로 강제<br>Value: `''`<br>Log: WS 값 유지 |\n| PLAN CHANGE | Name: 유지<br>Value: 유지<br>Log: 유지 | Name: PLAN CHANGE로 강제<br>Value: `''`<br>Log: 파싱/가공된 log | Name: PLAN CHANGE로 강제<br>Value: `''`<br>Log: 파싱/가공된 log |\n| SQL PLAN CHANGE | Name: 유지<br>Value: 유지<br>Log: 유지 | Name: SQL PLAN CHANGE로 강제Value: WS 값 유지<br>Log: WS 값 유지 | Name: SQL PLAN CHANGE로 강제<br>Value: WS 값 유지<br>Log: WS 값 유지 |\n| CUSTOM ALERT | Name: 유지<br>Value: 유지<br>Log: 내부 수치 치환 | Name: WS 값 그대로(대문자 처리) Value: `''`<br>Log: WS 값 유지 | Name: WS 값 그대로(대문자 처리)<br>Value: `''`<br>Log: WS 값 유지 |\n| OS STAT | Name: 유지<br>Value: 유지<br>Log: 유지 | Name: WS 값 그대로(대문자 처리) Value: WS 값 그대로(MB면 `/1024`)<br>Log: WS 값 그대로 | Name: WS 값 그대로(대문자 처리)<br>Value: WS 값 그대로(MB면 `/1024`)<br>Log: WS 값 그대로 |\n| CELL OS STAT | Name: 유지<br>Value: 유지<br>Log: 유지 | Name: alias/IP + statName<br>Value: WS 값 유지(대문자 처리)<br>Log: `''` | Name: alias/IP + statName<br>Value: WS 값 유지(대문자 처리)<br>Log: `''` |\n| INFINIBAND | Name: 유지<br>Value: 유지<br>Log: 유지 | Name: alias/IP + statName<br>Value: WS 값 유지(대문자 처리)<br>Log: `''` | Name: alias/IP + statName<br>Value: WS 값 유지(대문자 처리)<br>Log: `''` |\n| ROCE | Name: 유지Value: `0 또는 (value/1000).toFixed(3)`Log: 유지 | Name: alias/IP + statName<br>Value: WS 값 유지(대문자 처리)<br>Log: `''` | Name: alias/IP + statName<br>Value: WS 값 유지(대문자 처리)<br>Log: `''` |\n| CELL SERVER ALERT | Name: 유지<br>Value: 유지<br>Log: 유지 | Name: alias/IP + statName<br>Value: `''`<br>Log : WS 값 그대로 | Name: alias/IP + statName<br>Value: `''`<br>Log: WS 값 유지 |\n| CELL SERVER STATUS | Name: 유지<br>Value: 유지<br>Log: 유지 | Name: `RUNNING → NOT RUNNING` 치환 가능<br>Value: WS 값 유지<br>Log: `''` | Name: `RUNNING → NOT RUNNING` 치환 가능<br>Value: WS 값 유지<br>Log: `''` |\n| ASM DISK GROUP | Name: 유지<br>Value: 유지<br>Log: 유지 | Name: WS 값 그대로(대문자 처리) Value: WS 값 그대로<br>Log: WS 값 그대로 | Name: WS 값 그대로(대문자 처리)<br>Value: WS 값 그대로<br>Log: WS 값 그대로 |\n| PDB STATUS | Name: 유지<br>Value: 유지<br>Log: 유지 | Name: WS 값 그대로(대문자 처리) Value: `''`<br>Log: WS 값 그대로 | Name: WS 값 그대로(대문자 처리)<br>Value: `''`<br>Log: WS 값 그대로 |\n\n참고)\nFIX 이슈사항 : Index Unusable 타입인 경우 Name 컬럼에 인덱스명으로 잘못 표현되고 있었음.\n[](https://app.clickup.com/t/86eqgt16x)해당 작업에서 fix 되어 Name 컬럼에 INDEX UNUSABLE 보이도록 수정.\n\n\\[AS-IS\\]\n![](https://t25540965.p.clickup-attachments.com/t25540965/774e9db8-d8b3-4d70-986b-9b40657c14ec/image.png)\n\n\\[TO-BE\\]\n![](https://t25540965.p.clickup-attachments.com/t25540965/e0b2480f-b569-4410-9eca-4fe23f3b8282/image.png)\n\n**OS STAT 알람명 전처리**\n*   `free mem size` → `free memory`\n*   `total mem size` → `total memory`\n*   `swap used size` → `used swap` (Free Swap → Used Swap 지표로 일괄 변경된 이력 있음)\n*   `swap total size` → `total swap`\n**2**\n> **25 릴리즈 기준으로 작성되었습니다.**","x":-150,"y":480,"width":820,"height":1000},
		{"id":"7456d4e6f3d7ee8e","type":"file","file":"Exem/01-Projects/DPM 대시보드/성능 이슈/Performance 분석 - 폴링.md","x":4020,"y":-360,"width":980,"height":940}
	],
	"edges":[
		{"id":"b04eab823ddd55ff","fromNode":"f90c4ab0f7625996","fromSide":"right","toNode":"7053965eb0478467","toSide":"left"},
		{"id":"f8af05452109d61d","fromNode":"7053965eb0478467","fromSide":"right","toNode":"e31c3b9ca14af169","toSide":"left"}
	]
}