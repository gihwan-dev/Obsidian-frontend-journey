### 1. "보라색 벽"의 정체: 끊임없는 스타일 재계산 (Recalculate Style)

타임라인 중간에 빽빽하게 들어찬 보라색 블록들이 보이시나요?

- **현상:** `border-bottom-color`, `width`, `height`, `transform` 등의 CSS 속성이 아주 짧은 간격으로 수백, 수천 번 변경되고 있습니다.
    
- **의미:** 사용자가 마우스를 1픽셀 움직일 때마다(MouseMove), React가 스타일을 변경하고 → 브라우저는 23,000개 DOM의 스타일을 다시 계산하고 있습니다.
    
- **치명타:** 특히 `width`나 `height`를 변경하는 것은 **Reflow(Layout)** 를 유발합니다. 즉, 요소의 크기가 바뀌었으니 주변 요소들의 위치까지 전부 다시 계산해야 하는데, DOM이 너무 많아서 이 계산 비용이 엄청난 것입니다.
    

### 2. Scripting(3.6초) vs Rendering(0.9초)

- **Scripting (노란색):** React가 상태를 업데이트하고 Diffing 하는 데 걸리는 시간입니다. 이것도 길지만,
    
- **Rendering (보라색):** 단순히 계산된 스타일을 브라우저에 적용하는 데만 1초 가까이 쓰고 있습니다.
    
- **결론:** JS 로직도 무겁지만, **DOM 자체가 너무 비대해서 브라우저 렌더링 엔진이 과부하** 걸린 상태입니다.
    

### 3. 프레임 드랍 (Long Tasks)

- 상단의 빨간색 띠들이 **"Long Task"** 경고입니다. 브라우저 메인 스레드가 50ms 이상 묶여 있어서 사용자의 입력에 반응할 수 없는 상태입니다.
    
- 이 상태에서 리사이징을 하면 마우스 커서는 저만치 가 있는데, 박스는 뚝뚝 끊기며 뒤늦게 따라오는 현상이 발생합니다.
    

---

### 💡 리사이징 성능을 구하기 위한 해결책 (난이도순)

기환님이 현재 구조를 크게 뜯어고치지 않고 시도해볼 수 있는 순서대로 제안합니다.

#### 1. CSS `content-visibility: auto` (즉시 적용 가능)

가장 쉬운 방법입니다. 리스트나 그리드 컨테이너의 CSS에 이 속성을 추가해보세요.

CSS

```
.my-grid-item {
  content-visibility: auto;
  contain-intrinsic-size: 100px 500px; /* 대략적인 크기 지정 */
}
```

- **효과:** 화면 밖에 있는 요소들의 렌더링 계산을 브라우저가 건너뜁니다. 2만 개의 DOM 중 화면에 안 보이는 것들은 계산에서 제외되므로 리사이징 속도가 빨라질 수 있습니다.
    

#### 2. 리사이징 UX 변경: "Ghost Resizing" (강력 추천)

현재는 드래그하는 **"실시간"**으로 `width/height`를 바꾸고 있습니다. 이를 변경해야 합니다.

- **AS-IS:** 드래그 → `setState` → 컴포넌트 리사이징 (무거움) → 드래그 (반복)
    
- **TO-BE:**
    
    1. 드래그 시작 시, 실제 컴포넌트 위에 **가벼운 점선 박스(Ghost)**만 띄웁니다.
        
    2. 드래그 중에는 이 점선 박스의 `transform`만 변경합니다. (Reflow 없이 GPU만 사용하므로 매우 빠름)
        
    3. 마우스를 놓는 순간(`onDragEnd`), 실제 컴포넌트의 데이터를 업데이트합니다.
        
- **효과:** 리사이징 중에 2만 개 DOM의 Reflow가 발생하지 않습니다. 사용자는 훨씬 부드럽다고 느낍니다.
    

#### 3. Throttle / requestAnimationFrame 적용

만약 실시간 리사이징을 포기할 수 없다면, 이벤트 호출 빈도를 줄여야 합니다.

- `onResize` 콜백이 매 픽셀마다 실행되지 않도록 `requestAnimationFrame`으로 감싸거나, `lodash.throttle`을 사용하여 16ms(60fps) 또는 30ms 간격으로만 상태를 업데이트하세요.
    

#### 4. (근본적 해결) 역시나 Virtualization

결국 다시 원점입니다. **TanStack Virtual** 등을 도입하여 DOM 개수 자체를 줄이지 않으면, 어떤 최적화를 해도 2만 개 앞에서는 한계가 있습니다.

**요약:** 지금 당장 가장 효과적인 것은 **"2. Ghost Resizing"** 패턴으로 UX를 바꾸는 것입니다. 실제 무거운 렌더링은 드래그가 끝났을 때 딱 한 번만 수행하도록 변경해보세요!