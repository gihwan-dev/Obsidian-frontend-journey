### 현 상태
![[Pasted image 20260209123941.png]]

### 1. CPU 사용률 49% & 레이아웃/스타일 재계산 (매우 높음)

- **현상:** 폴링 중인데 CPU가 50% 가까이 치솟고 있고, `Layouts / sec`가 **61.4회**, `Style recalcs / sec`가 **83.4회**입니다.
    
- **의미:** 브라우저가 **1초에 60~80번씩 화면 구조를 다시 계산**하고 있습니다. 이는 60fps 게임을 돌리는 수준의 부하입니다.
    
- **진단:**
    
    - 혹시 폴링 주기가 너무 짧지 않은가요? (예: `requestAnimationFrame`이나 100ms 단위)
        
    - 데이터를 받아올 때마다 거대한 **DOM 트리(23,315개) 전체 혹은 상당 부분에 리렌더링(Re-render)**이 전파되고 있는 것으로 보입니다.
        
    - React DevTools의 "Highlight updates when components render"를 켜보면, 아마 데이터가 들어올 때마다 화면 전체가 번쩍거리고 있을 확률이 높습니다.
        

### 2. JS Heap 메모리의 톱니바퀴 패턴 (GC Thrashing)

- **현상:** 보라색 그래프(JS Heap)를 보시면 **상승했다가 뚝 떨어지는 톱니 모양**이 아주 빈번하게 반복되고 있습니다.
    
- **의미:** 짧은 시간 동안 엄청난 양의 객체가 생성되었다가 가비지 컬렉터(GC)에 의해 삭제되고 있습니다.
    
- **진단:**
    
    - 폴링으로 받아오는 데이터(JSON)의 크기가 너무 크거나,
        
    - 데이터를 받아온 후 `setState`를 할 때, 기존 객체를 재활용하지 않고 매번 **거대한 배열/객체를 새로 복사(Deep Clone 등)**하고 있을 가능성이 큽니다.
        
    - 이 과정이 23,000개의 DOM 노드와 맞물려 메모리 누수 혹은 급격한 메모리 할당을 유발합니다.
        

### 3. DOM Nodes 23,315개의 영향

- **진단:** 폴링 자체는 죄가 없지만, **23,000개의 DOM이 있는 상태에서 폴링을 하는 것**이 문제입니다.
    
- 데이터가 업데이트될 때마다 React는 가상 DOM(Virtual DOM)을 비교(Diffing)해야 하는데, 노드가 2만 개면 비교 연산 비용만으로도 CPU를 잡아먹습니다. 여기서 스타일 재계산까지 겹치니 280ms의 INP 지연이 발생하는 것입니다.
    

---

### 🚀 기환님을 위한 긴급 처방 (React 관점)

**1. 폴링 컴포넌트 격리 (State Colocation)**

대시보드 전체를 감싸는 상위 컴포넌트에서 폴링 데이터를 관리하고 있나요?

- **AS-IS:** 상위(Page)에서 fetch -> Props로 하위(Grid)에 전달 -> **Grid 전체 리렌더링**
    
- **TO-BE:** 데이터가 변하는 **작은 컴포넌트 내부에서만** 폴링하거나, 상태 관리 라이브러리(Zustand, Jotai 등)의 **Selector**를 사용하여, 데이터가 변경된 **해당 셀(Cell)만** 리렌더링되게 해야 합니다.
    

**2. `React.memo`로 방어벽 세우기**

- 23,000개의 DOM을 가진 거대한 Grid 컴포넌트를 `React.memo`로 감싸세요.
    
- 폴링 데이터가 들어왔을 때, Grid의 Props가 바뀌지 않는다면(혹은 바뀌는 부분만 제외하고) 렌더링을 건너뛰도록 막아야 합니다.
    

**3. 개발자 도구 확인**

지금 당장 **React DevTools Profiler**를 켜고 폴링이 한 번 일어날 때 **"어떤 컴포넌트가 렌더링되는지"** 확인해보세요. 의도치 않게 `Table`이나 `Grid` 전체가 렌더링되고 있다면 그것부터 끊어야 합니다.

**요약:** 지금 그래프는 **"데이터가 들어올 때마다 2만 개의 DOM이 반응하고 있음"**을 보여줍니다. 이 연결고리를 끊는 것이 핵심입니다.