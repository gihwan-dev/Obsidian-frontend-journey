# Table 컴포넌트 구조 개선 - 마일스톤

> 기준 문서: `table-component-restructuring.md`
> 전략: 2개 PR로 분리 (PR 1 merge 후 PR 2 진행)
>
> Deep Think 검토 완료 (2026-02-06): 4개 독립 분석 경로로 교차 검증 수행.
> P1 4건 / P2 5건 / P3 5건 반영 완료. 상세 분석: `.deep-think/answer.md`

---

## Phase 0: 선행 작업

### 0-1. 기존 테스트 baseline 확인
- [ ] `pnpm typecheck` 통과 확인
- [ ] `pnpm test --filter @exem-fe/react` 통과 확인
- [ ] `pnpm test:browser` 통과 확인

### 0-2. stickyTree + Column Pinning 조합 현황 확인
- [ ] Storybook에서 stickyTree + column pinning 조합 수동 테스트
- [ ] `useStickyTreeCells.ts:27`과 `StickyTreeNode.tsx:46`의 `getCenterVisibleCells()` 하드코딩이 left/right 열에 미치는 영향 확인
- [ ] 현재 동작 기록 (의도적 미지원 vs 버그)

### 0-3. stickyTree + Column Pinning 대응 결정
- [ ] 의도적 미지원이면: 별도 이슈 생성 (API validation 차단 + 문서화)
- [ ] 버그이면: 별도 이슈로 분리 (리팩토링과 동시 수정하지 않음)

### 0-4. maxVisibleRows combinedRowCount 인터페이스 확정
- [ ] `TableCenterRowSection:24-26`의 `combinedRows` 사용처 확인 — 길이만 필요함을 검증
- [ ] `TableBodyArea`에서 `combinedRowCount = topRows.length + centerRows.length + bottomRows.length` 계산 후 props 전달 방식 확정

### 0-5. 교차 기능 시나리오 baseline 확인
- [ ] Row pinning + Column pinning 동시 사용 현재 동작 확인 (Storybook)
- [ ] maxVisibleRows + Row pinning 동시 사용 현재 동작 확인 (Storybook)
- [ ] stickyTree + 스크롤 동기화 현재 동작 확인 (Storybook)
- [ ] 빈 상태 표시 현재 동작 확인 (Storybook)
- [ ] 무한 스크롤 현재 동작 확인 (Storybook)
- [ ] 결과를 기록하여 Phase 1/2 완료 후 비교 baseline으로 사용

---

## Phase 1 (PR 1): Top/Bottom 통합 — `TablePinnedRowSection`

> 목표: `TableTopRowSection` + `TableBottomRowSection` → `TablePinnedRowSection` 통합

### 1-1. TablePinnedRowSection 컴포넌트 생성

**파일**: `packages/react/src/table/components/TablePinnedRowSection.tsx` (신규)

- [ ] Props 인터페이스 정의
  ```
  position: 'top' | 'bottom'
  ```
- [ ] context hooks 연결 (`useTableContext`, `useTableOptions`, `useTableRefs`, `useTableScrollSync`, `useTableContainerSize`)
- [ ] `splitRows(table)`에서 position에 따라 rows 선택
  - `position === 'top'` → `topRows`
  - `position === 'bottom'` → `bottomRows`
- [ ] 높이 계산: `rows.length * (options.rowHeight || 40)`
- [ ] shadow 클래스 분기
  - top: `tableStyles.shadowPinnedTop`
  - bottom: `tableStyles.shadowPinnedBottom`
- [ ] ref 분기
  - top: center 열에 `refs.topBodyRef`
  - bottom: center 열에 `refs.bottomBodyRef`
- [ ] scroll handler 분기
  - top: center 열에 `synchronizer.handleTopScroll`
  - bottom: center 열에 `synchronizer.handleBottomScroll`
- [ ] 초기 scrollLeft 동기화 `useLayoutEffect` 구현
  - top: `topBodyRef.scrollLeft = bodyScrollRef.scrollLeft`
  - bottom: `bottomBodyRef.scrollLeft = bodyScrollRef.scrollLeft`
- [ ] left/center/right 3-column 레이아웃 렌더링
  - left: `hasLeftColumns` 조건부, `shadowPinnedLeft`, `leftHandleScroll`
  - center: position별 ref + scroll handler
  - right: `hasRightColumns` 조건부, `shadowPinnedRight`, `rightHandleScroll`
- [ ] 각 영역에 `<TableBodySegment columnType={...} rowType={position} />` 배치

### 1-2. TableBodyArea 수정

**파일**: `packages/react/src/table/components/TableBodyArea.tsx`

- [ ] import 변경: `TableTopRowSection`, `TableBottomRowSection` → `TablePinnedRowSection`
- [ ] JSX 교체
  - `<TableTopRowSection />` → `<TablePinnedRowSection position="top" />`
  - `<TableBottomRowSection />` → `<TablePinnedRowSection position="bottom" />`

### 1-3. 기존 파일 삭제

- [ ] `TableTopRowSection.tsx` 삭제
- [ ] `TableBottomRowSection.tsx` 삭제
- [ ] 다른 파일에서 삭제된 파일을 import하는 곳이 없는지 확인

### 1-4. 품질 검증

- [ ] `pnpm typecheck` 통과
- [ ] `pnpm lint` 통과
- [ ] `pnpm test:browser` 전체 통과 (특히 RowPinning, ColumnPinning, Virtualization, InfiniteScroll)

---

## Phase 2 (PR 2): TableBodySegment 대체 + splitRows 중앙화

> 목표: `TableBodySegment` → `PinnedRowRenderer` / `VirtualRowRenderer`로 역할 분리, `splitRows` 1회 호출

### 권장 commit 경계

| Commit | 포함 step | 설명 |
|--------|----------|------|
| 1 | 2-1 + 2-2 | Renderer 생성 (기존 코드 미수정, 안전) |
| 2 | 2-3 + 2-4 | splitRows 중앙화 + PinnedRowSection 수정 (**동시 수행 필수**) |
| 3 | 2-5 + 2-6 + 2-7 + 2-8 | CenterRowSection 전면 수정 (**동시 수행 필수**) |
| 4 | 2-9 | rowHeight 버그 수정 (git blame 분리를 위해 독립 commit) |
| 5 | 2-10 ~ 2-13 | 검증 + 삭제 + cleanup |

### 2-0. Phase 2 시작 전 확인
- [ ] PR 1이 merge되고 안정적인 상태인지 확인 (regression 보고 없음)
- [ ] Phase 2 브랜치를 최신 main에 rebase
- [ ] `pnpm typecheck && pnpm test:browser` 재확인

### Step A: Renderer 컴포넌트 생성

#### 2-1. PinnedRowRenderer 컴포넌트 생성

**파일**: `packages/react/src/table/components/PinnedRowRenderer.tsx` (신규)

- [ ] Props 인터페이스 정의
  ```typescript
  interface PinnedRowRendererProps {
    rows: Row<TableRowData<T>>[]
    columnType: 'left' | 'center' | 'right'
    position: 'top' | 'bottom'
    className?: string
    style?: React.CSSProperties
  }
  ```
- [ ] columnType에 따른 cells 선택 (3줄 switch)
  - left: `row.getLeftVisibleCells()`
  - center: `row.getCenterVisibleCells()`
  - right: `row.getRightVisibleCells()`
- [ ] cell 가시성 필터링: `table.isCellHidden(row.id, cell.column.id)`
- [ ] `filteredCells.length === 0`이면 해당 row skip (null 반환)
- [ ] rows 직접 순회 → `<TableBody>` > `<TableRow>` + `<TableCell>` 렌더링
- [ ] `<TableBody>`에 `bodyClassName={cn('overflow-x-hidden', className)}` 적용
- [ ] key 패턴: `${columnType}-pinned-${row.id}`
- [ ] `TableRow`에 `isPinned={position}` prop 전달
- [ ] `table.getTotalSize()` 기반 width 설정
- [ ] `useTableRowVirtualizer()`는 호출하지 않는다 (PinnedRowRenderer는 가상화 불필요)

#### 2-2. VirtualRowRenderer 컴포넌트 생성

**파일**: `packages/react/src/table/components/VirtualRowRenderer.tsx` (신규)

- [ ] `React.forwardRef` 지원 (centerBodyRef 전달용)
- [ ] Props 인터페이스 정의
  ```typescript
  interface VirtualRowRendererProps {
    rows: Row<TableRowData<T>>[]
    columnType: 'left' | 'center' | 'right'
    className?: string
    style?: React.CSSProperties
  }
  ```
- [ ] `useTableRowVirtualizer()` context에서 virtualizer 획득
- [ ] columnType에 따른 cells 선택 (PinnedRowRenderer와 동일 패턴)
- [ ] cell 가시성 필터링
- [ ] `rowVirtualizer.getVirtualItems()` 순회 → `rows[virtualItem.index]` 매핑
- [ ] `<TableBody>` > `<TableRow>` + `<TableCell>` 렌더링
- [ ] `TableRow`에 `virtualItem`, `rowVirtualizer` props 전달
- [ ] key 패턴: `${columnType}-virtual-${row.id}`
- [ ] style: `width: table.getTotalSize()`, `height: rowVirtualizer.getTotalSize() === 0 ? '100%' : rowVirtualizer.getTotalSize()`

### Step B: splitRows 중앙화 + Props 전달 체계

> **주의**: 2-3과 2-4는 TypeScript type contract 유지를 위해 반드시 동시에 수행한다.
> 2-3에서 rows props를 전달하면 2-4에서 해당 props를 수신해야 type error가 해소된다.

#### 2-3. TableBodyArea 수정 — splitRows 1회 호출

**파일**: `packages/react/src/table/components/TableBodyArea.tsx`

- [ ] `splitRows(table)` 결과를 변수에 저장 (기존과 동일하지만 전체 destructuring)
  ```typescript
  const { topRows, centerRows, bottomRows } = splitRows(table);
  ```
- [ ] `combinedRowCount` 계산
  ```typescript
  const combinedRowCount = topRows.length + centerRows.length + bottomRows.length;
  ```
- [ ] `TablePinnedRowSection`에 `rows` props 전달
  - `<TablePinnedRowSection position="top" rows={topRows} />`
  - `<TablePinnedRowSection position="bottom" rows={bottomRows} />`
- [ ] `TableCenterRowSection`에 `rows`, `combinedRowCount` props 전달
  - `<TableCenterRowSection rows={centerRows} combinedRowCount={combinedRowCount} />`
- [ ] `hasTopRows` / `hasBottomRows` 조건은 전달된 rows에서 계산 (기존 로직 유지)

#### 2-4. TablePinnedRowSection 수정 — rows props 수신 + PinnedRowRenderer 사용

**파일**: `packages/react/src/table/components/TablePinnedRowSection.tsx`

- [ ] Props에 `rows` 추가
- [ ] 내부 `splitRows()` 호출 제거
- [ ] 높이 계산: `rows.length * (options.rowHeight || 40)` (rows는 props에서)
- [ ] `<TableBodySegment>` 제거, `<PinnedRowRenderer>` 배치
  - left: `<PinnedRowRenderer rows={rows} columnType="left" position={position} />`
  - center: `<PinnedRowRenderer rows={rows} columnType="center" position={position} />`
  - right: `<PinnedRowRenderer rows={rows} columnType="right" position={position} />`

### Step C: TableCenterRowSection 내부 구조 개선

> **주의**: 2-5~2-8은 동일 파일(TableCenterRowSection.tsx)의 동일한 JSX 위치를 수정하므로,
> 하나의 cohesive change로 구현한다. step 분리는 개념적 명확성을 위한 것이며,
> 별도 commit이나 별도 실행을 의미하지 않는다.

#### 2-5. TableCenterRowSection — props 인터페이스 추가

**파일**: `packages/react/src/table/components/TableCenterRowSection.tsx`

- [ ] Props 인터페이스 추가
  ```typescript
  interface TableCenterRowSectionProps {
    rows: Row<TableRowData<T>>[]
    combinedRowCount: number
  }
  ```
- [ ] `table.getCenterRows()` 호출 제거 → `props.rows` 사용
- [ ] `combinedRows` useMemo 제거 → `props.combinedRowCount` 사용
- [ ] `isEmpty` 판단: `props.rows.length === 0`

#### 2-6. TableCenterRowSection — isEmpty 처리 Section 레벨 통합

**파일**: `packages/react/src/table/components/TableCenterRowSection.tsx`

- [ ] isEmpty일 때 center 열의 `<TableBodySegment>` 대신 `<TableEmptyRow>` 직접 렌더링
- [ ] `TableEmptyRow` import 추가
- [ ] `useTableCustomStyles()` 추가 (emptyCellClassName용)
- [ ] isEmpty 시 ScrollArea 내부:
  ```tsx
  isEmpty ? (
    <TableEmptyRow
      emptyContent={options.emptyContent}
      emptyCellClassName={cn('h-14 text-center ...', customStyles.body?.empty)}
    />
  ) : (
    // 기존 VirtualRowRenderer 또는 StickyTreeRenderer
  )
  ```
- [ ] isEmpty 스타일링 유지: `isEmpty && '[&_[data-slot="scroll-area-viewport"]>div]:h-full'`

#### 2-7. TableCenterRowSection — stickyTree 분기 통합

**파일**: `packages/react/src/table/components/TableCenterRowSection.tsx`

- [ ] stickyTree 여부를 Section 레벨에서 일괄 결정
  ```typescript
  const isStickyTree = options.expandable?.use && options.expandable.stickyTree?.use;
  ```
- [ ] **주의**: 현재 left/right 열의 stickyTree 분기는 `TableCenterRowSection`에 없고
      `TableBodySegment` 내부(line 117)에서만 발생한다.
      이 task는 "기존 코드 이동"이 아니라 **Section 레벨에 새로운 조건부 JSX 구조를 생성**하는 것이다.
      left/center/right 각각에 `isStickyTree` ternary를 추가해야 한다.
- [ ] isEmpty 체크가 stickyTree 분기보다 우선한다:
      isEmpty이면 stickyTree 여부와 무관하게 `TableEmptyRow` 렌더링
- [ ] stickyTree 렌더링 파이프라인(`parseToStickyTree` → `buildRenderingMetadata` → `calculateTotalTreeHeight`)을
      JSX return 전에 계산. rows와 options에 의존하므로 적절한 메모이제이션 고려.
- [ ] stickyTree 모드일 때: left/center/right **모두** `StickyTreeRenderer` 배치
  - StickyTree 관련 import 추가 (`parseToStickyTree`, `buildRenderingMetadata`, `calculateTotalTreeHeight`, `StickyTreeRenderer`)
  - center 영역: `centerBodyRef` 할당 **안 함**, className/style도 stickyTree용으로 변경
- [ ] 비-stickyTree 모드일 때: left/center/right에 `VirtualRowRenderer` 배치
  - center 영역: `centerBodyRef` 할당, `rowVirtualizer.getTotalSize()` 기반 height
- [ ] `centerBodyRef` 조건부 할당 패턴 정확히 재현
  - 비-stickyTree center에만: `ref={refs.centerBodyRef}`
  - stickyTree: ref 없음, className/style 다름

> **Watch for**:
> - `centerBodyRef`는 stickyTree 모드에서 할당하지 않는다
> - `StickyTreeRenderer`는 내부적으로 `getCenterVisibleCells()`만 사용 (0-2/0-3 결과에 따라 대응)
> - className과 style이 stickyTree/non-stickyTree 모드에서 다르다

#### 2-8. TableCenterRowSection — VirtualRowRenderer 적용

**파일**: `packages/react/src/table/components/TableCenterRowSection.tsx`

- [ ] `<TableBodySegment>` 호출 전부 제거
- [ ] left 영역: `<VirtualRowRenderer rows={rows} columnType="left" />`
- [ ] center 영역: `<VirtualRowRenderer ref={refs.centerBodyRef} rows={rows} columnType="center" className={...} style={...} />`
- [ ] right 영역: `<VirtualRowRenderer rows={rows} columnType="right" />`
- [ ] left/right 영역에는 ref가 없음 확인 (leftBodyRef/rightBodyRef는 wrapper div에 할당)

> **Watch for**:
> - left/right 열에는 ref를 할당하지 않는다 (leftBodyRef/rightBodyRef는 wrapper div에 있음)
> - center 열의 ref는 VirtualRowRenderer에 forwardRef로 전달
> - `rowVirtualizer.getTotalSize() === 0`인 경우 height fallback `'100%'` 필요

#### 2-9. rowHeight 40px 하드코딩 수정 (기존 버그)

**파일**: `packages/react/src/table/components/TableCenterRowSection.tsx`

- [ ] `combinedRows.length * 40` → `combinedRowCount * (options.rowHeight || 40)` 변경
- [ ] `options.maxVisibleRows * 40` → `options.maxVisibleRows * (options.rowHeight || 40)` 변경

### Step D: 검증 + 정리

#### 2-10. 중간 품질 검증

- [ ] `pnpm typecheck` 통과
- [ ] `pnpm test:browser` 통과

#### 2-11. 교차 기능 시나리오 수동 검증 (TableBodySegment 삭제 전)

> TableBodySegment가 아직 존재하는 상태에서 검증하여, 문제 발생 시 기존 코드와 즉시 비교 가능

- [ ] Row pinning + Column pinning 동시 사용 (Storybook)
- [ ] maxVisibleRows + Row pinning 동시 사용 (Storybook)
- [ ] stickyTree + 스크롤 동기화 (Storybook)
- [ ] 빈 상태 표시 정상 동작 (Storybook)
- [ ] 무한 스크롤 정상 동작 (Storybook)
- [ ] `useEffect` (초기 무한 스크롤 로드)와 `onScroll` 핸들러 내 `handleInfiniteScroll` 호출 두 곳 모두 유지 확인
- [ ] Phase 0 baseline 결과와 비교하여 regression 없음 확인

#### 2-12. TableBodySegment 삭제

- [ ] `TableBodySegment.tsx` 삭제
- [ ] 모든 파일에서 `TableBodySegment` import가 없는지 확인

#### 2-13. 미사용 코드 정리 + 최종 검증

- [ ] 삭제된 컴포넌트의 barrel export 제거 (있다면)
- [ ] 미사용 import 정리
- [ ] `splitRows` import가 `TableBodyArea.tsx`에만 남는지 확인
- [ ] `pnpm typecheck` 통과
- [ ] `pnpm lint` 통과 (+ `pnpm lint:fix` 필요시)
- [ ] `pnpm test --filter @exem-fe/react` 통과
- [ ] `pnpm test:browser` 전체 통과

---

## 파일 변경 요약

| 파일 | Phase | 변경 |
|------|-------|------|
| `TablePinnedRowSection.tsx` | 1-1 신규 → 2-4 수정 | Top/Bottom 통합, 이후 rows props 수신 |
| `TableBodyArea.tsx` | 1-2 수정 → 2-3 수정 | import 교체, 이후 splitRows 중앙화 |
| `TableTopRowSection.tsx` | 1-3 | 삭제 |
| `TableBottomRowSection.tsx` | 1-3 | 삭제 |
| `PinnedRowRenderer.tsx` | 2-1 | 신규 |
| `VirtualRowRenderer.tsx` | 2-2 | 신규 |
| `TableCenterRowSection.tsx` | 2-5~2-9 | props 수신, isEmpty 통합, stickyTree 통합, rowHeight 수정 |
| `TableBodySegment.tsx` | 2-12 | 삭제 |
| `TableEmptyRow.tsx` | 2-6 | import 추가 (TableCenterRowSection에서 직접 사용) |
| `StickyTree/*` | 2-7 | import 추가 (TableCenterRowSection에서 직접 사용) |

---

## 검증 전략

각 Phase 완료 시:
1. `pnpm typecheck && pnpm lint` — 정적 분석
2. `pnpm test:browser` — 24개 browser test 파일, ~400개 개별 테스트 (핵심 안전망)
3. Storybook 수동 확인 — 교차 기능 시나리오 (Phase 0 baseline과 비교)
