# Table 컴포넌트 구조 개선 - 마일스톤

> 기준 문서: `table-component-restructuring.md`
> 전략: 2개 PR로 분리 (PR 1 merge 후 PR 2 진행)
>
> Deep Think 검토 완료 (2026-02-06): 4개 독립 분석 경로로 교차 검증 수행.
> P1 4건 / P2 5건 / P3 5건 반영 완료. 상세 분석: `.deep-think/answer.md`

---

## Phase 0: 선행 작업

### 0-1. 기존 테스트 baseline 확인
- [x] `pnpm typecheck` 통과 확인
- [x] `pnpm test --filter @exem-fe/react` 통과 확인 (※ 루트에서 `pnpm run test` 실행)
- [x] `pnpm test:browser` 통과 확인 (※ `pnpm run test`로 jsdom + browser + storybook 91파일 743테스트 전체 통과)

### 0-2. stickyTree + Column Pinning 조합 현황 확인
- [x] Storybook에서 stickyTree + column pinning 조합 수동 테스트 → 코드 분석으로 대체
- [x] `useStickyTreeCells.ts:27`과 `StickyTreeNode.tsx:46`의 `getCenterVisibleCells()` 하드코딩이 left/right 열에 미치는 영향 확인
- [x] 현재 동작 기록 (의도적 미지원 vs 버그) → **잠재 버그** (아래 세션 노트 참조)

### 0-3. stickyTree + Column Pinning 대응 결정
- [x] ~~의도적 미지원이면: 별도 이슈 생성 (API validation 차단 + 문서화)~~
- [x] 버그이면: 별도 이슈로 분리 (리팩토링과 동시 수정하지 않음) → **별도 이슈로 분리 결정**

### 0-4. maxVisibleRows combinedRowCount 인터페이스 확정
- [x] `TableCenterRowSection:24-26`의 `combinedRows` 사용처 확인 — **길이만 필요함 검증 완료**
- [x] `TableBodyArea`에서 `combinedRowCount = topRows.length + centerRows.length + bottomRows.length` 계산 후 props 전달 방식 확정

### 0-5. 교차 기능 시나리오 baseline 확인
- [x] Row pinning + Column pinning 동시 사용 현재 동작 확인 → 각각 browser test 통과로 baseline
- [x] maxVisibleRows + Row pinning 동시 사용 현재 동작 확인 → 기존 테스트 없음, 코드 분석으로 대체
- [x] stickyTree + 스크롤 동기화 현재 동작 확인 → Expanding.browser.test 9개 통과로 baseline
  - ⚠️ **테스트 커버리지 갭**: stickyTree 스토리가 composeStories에 포함되어 browser 테스트는 실행되지만, stickyTree + column pinning 조합 스토리가 없어 해당 조합의 regression은 자동 감지 불가. 리팩토링 시 StickyTreeRenderer 코드 경로가 실제로 커버되는지 추가 확인 필요
- [x] 빈 상태 표시 현재 동작 확인 → `TableBodySegment:43`에서 정상 작동 (코드 분석)
- [x] 무한 스크롤 현재 동작 확인 → InfiniteScroll.browser.test 4개 통과로 baseline
- [x] 결과를 기록하여 Phase 1/2 완료 후 비교 baseline으로 사용

### Phase 0 세션 노트 (2026-02-06)

1. **Baseline 테스트 결과**: `pnpm run test` — 91 파일, 743 테스트 전체 통과 (jsdom 18 + storybook 49 + browser 24)
2. **stickyTree + Column Pinning**: 잠재 버그 확인 → 별도 이슈로 분리
   - `useStickyTreeCells.ts:27`, `StickyTreeNode.tsx:46`에서 `getCenterVisibleCells()` 하드코딩
   - left/right 고정 열에서 StickyTreeRenderer 호출 시 center cells가 중복 렌더링되는 구조
   - Expanding 스토리에 column pinning 조합 스토리가 없어 실제 유스케이스가 드묾
   - **결정**: 리팩토링과 동시 수정하지 않음. Phase 2 완료 후 별도 이슈로 처리
3. **combinedRowCount**: `combinedRows` 배열은 `.length`만 사용됨 확정 → Phase 2-3에서 `combinedRowCount` number prop 전달
4. **rowHeight 40px 하드코딩**: `TableCenterRowSection.tsx:90-92`에서 `* 40` 하드코딩 → Phase 2 Step 2-9에서 `* (options.rowHeight || 40)` 수정

---

## Phase 1 (PR 1): Top/Bottom 통합 — `TablePinnedRowSection`

> 목표: `TableTopRowSection` + `TableBottomRowSection` → `TablePinnedRowSection` 통합

### 1-1. TablePinnedRowSection 컴포넌트 생성

**파일**: `packages/react/src/table/components/TablePinnedRowSection.tsx` (신규)

- [x] Props 인터페이스 정의
  ```
  position: 'top' | 'bottom'
  ```
- [x] context hooks 연결 (`useTableContext`, `useTableOptions`, `useTableRefs`, `useTableScrollSync`, `useTableContainerSize`)
- [x] `splitRows(table)`에서 position에 따라 rows 선택
  - `position === 'top'` → `topRows`
  - `position === 'bottom'` → `bottomRows`
- [x] 높이 계산: `rows.length * (options.rowHeight || 40)`
- [x] shadow 클래스 분기
  - top: `tableStyles.shadowPinnedTop`
  - bottom: `tableStyles.shadowPinnedBottom`
- [x] ref 분기
  - top: center 열에 `refs.topBodyRef`
  - bottom: center 열에 `refs.bottomBodyRef`
- [x] scroll handler 분기
  - top: center 열에 `synchronizer.handleTopScroll`
  - bottom: center 열에 `synchronizer.handleBottomScroll`
- [x] 초기 scrollLeft 동기화 `useLayoutEffect` 구현
  - top: `topBodyRef.scrollLeft = bodyScrollRef.scrollLeft`
  - bottom: `bottomBodyRef.scrollLeft = bodyScrollRef.scrollLeft`
- [x] left/center/right 3-column 레이아웃 렌더링
  - left: `hasLeftColumns` 조건부, `shadowPinnedLeft`, `leftHandleScroll`
  - center: position별 ref + scroll handler
  - right: `hasRightColumns` 조건부, `shadowPinnedRight`, `rightHandleScroll`
- [x] 각 영역에 `<TableBodySegment columnType={...} rowType={position} />` 배치

### 1-2. TableBodyArea 수정

**파일**: `packages/react/src/table/components/TableBodyArea.tsx`

- [x] import 변경: `TableTopRowSection`, `TableBottomRowSection` → `TablePinnedRowSection`
- [x] JSX 교체
  - `<TableTopRowSection />` → `<TablePinnedRowSection position="top" />`
  - `<TableBottomRowSection />` → `<TablePinnedRowSection position="bottom" />`

### 1-3. 기존 파일 삭제

- [x] `TableTopRowSection.tsx` 삭제
- [x] `TableBottomRowSection.tsx` 삭제
- [x] 다른 파일에서 삭제된 파일을 import하는 곳이 없는지 확인

### 1-4. 품질 검증

- [x] `pnpm typecheck` 통과
- [x] `pnpm lint` 통과
- [x] `pnpm test:browser` 전체 통과 (특히 RowPinning, ColumnPinning, Virtualization, InfiniteScroll)

### Phase 1 세션 노트 (2026-02-06)

1. **구현 방식**: `pinnedConfig` 객체로 position별 분기 (shadow, ref, scroll handler, rows 선택)를 config-driven으로 처리
2. **검증 결과**: typecheck 통과, lint 통과 (경고는 모두 기존 코드), `pnpm run test` 91 suites 743 tests 전체 통과
3. **발견된 이슈**: 없음
4. **아키텍처 결정**: `pinnedConfig` 상수 객체에 getter 함수로 position별 차이를 캡슐화. 조건 분기 없이 config lookup으로 처리
5. **다음 Phase 영향**: Phase 2-4에서 `TablePinnedRowSection`에 `rows` props 추가 시, `pinnedConfig`에서 `getRows` 제거하고 props로 대체 필요

---

## Phase 2 (PR 2): TableBodySegment 대체 + splitRows 중앙화

> 목표: `TableBodySegment` → `PinnedRowRenderer` / `VirtualRowRenderer`로 역할 분리, `splitRows` 1회 호출

### 권장 commit 경계

| Commit | 포함 step | 설명 |
|--------|----------|------|
| 1 | 2-1 + 2-2 | Renderer + 공통 유틸리티 생성 (기존 코드 미수정, 안전) |
| 2 | 2-3 + 2-4 | splitRows 중앙화 + PinnedRowSection 수정 (**동시 수행 필수**) |
| 3 | 2-5 + 2-6 + 2-7 + 2-8 + 2-9 | CenterRowSection 전면 수정 + rowHeight 버그 수정 (**동시 수행 필수**, CenterRowSection 수정과 rowHeight 수정이 같은 높이 계산 로직에 위치) |
| 4 | 2-10 ~ 2-13 | 검증 + 삭제 + cleanup |

**롤백 계획:**
- 개별 commit 문제: `git revert <commit>` (각 commit이 독립적으로 revert 가능하도록 설계)
- PR 전체 문제: `git revert --no-commit <commit4>..<commit1> && git commit`
- 문제 추적: `git bisect start HEAD <pr1-merge-commit>` → 4 commit 중 문제 지점 특정 (최대 2회 테스트)

### 2-0. Phase 2 시작 전 확인
- [x] PR 1이 merge되고 안정적인 상태인지 확인 (regression 보고 없음)
- [x] Phase 2 브랜치를 최신 main에 rebase
- [x] `pnpm typecheck && pnpm run test` 재확인

### Step A: Renderer 컴포넌트 생성

#### 2-1. PinnedRowRenderer 컴포넌트 생성

**파일**: `packages/react/src/table/components/PinnedRowRenderer.tsx` (신규)

- [x] `BaseRowRendererProps` 공통 인터페이스 정의 (PinnedRowRenderer / VirtualRowRenderer 공유)
  ```typescript
  interface BaseRowRendererProps {
    rows: Row<TableRowData<T>>[]
    columnType: 'left' | 'center' | 'right'
    className?: string
    style?: React.CSSProperties
  }
  ```
- [x] Props 인터페이스 정의
  ```typescript
  interface PinnedRowRendererProps extends BaseRowRendererProps {
    position: 'top' | 'bottom'
  }
  ```
- [x] 공통 유틸리티 함수 생성 (`getSectionCells`, `filterVisibleCells`)
  ```typescript
  // PinnedRowRenderer / VirtualRowRenderer에서 공유
  export function getSectionCells(row: Row<TableRowData>, columnType: 'left' | 'center' | 'right') {
    // columnType에 따른 cells 선택 (3줄 switch)
    // left: row.getLeftVisibleCells()
    // center: row.getCenterVisibleCells()
    // right: row.getRightVisibleCells()
  }
  export function filterVisibleCells(cells: Cell<TableRowData>[], table: Table<TableRowData>) {
    // table.isCellHidden(row.id, cell.column.id) 필터링
  }
  ```
- [x] `getSectionCells` + `filterVisibleCells` 사용하여 cells 선택 및 필터링
- [x] `filteredCells.length === 0`이면 해당 row skip (null 반환)
- [x] rows 직접 순회 → `<TableBody>` > `<TableRow>` + `<TableCell>` 렌더링
- [x] `<TableBody>`에 `bodyClassName={cn('overflow-x-hidden', className)}` 적용
- [x] key 패턴: `${columnType}-pinned-${row.id}`
- [x] `TableRow`에 `isPinned={position}` prop 전달
- [x] `table.getTotalSize()` 기반 width 설정
- [x] `useTableRowVirtualizer()`는 호출하지 않는다 (PinnedRowRenderer는 가상화 불필요)

#### 2-2. VirtualRowRenderer 컴포넌트 생성

**파일**: `packages/react/src/table/components/VirtualRowRenderer.tsx` (신규)

- [x] `React.forwardRef` 지원 (centerBodyRef 전달용)
- [x] Props 인터페이스 정의
  ```typescript
  interface VirtualRowRendererProps extends BaseRowRendererProps {
    // BaseRowRendererProps에서 rows, columnType, className, style 상속
  }
  ```
- [x] `useTableRowVirtualizer()` context에서 virtualizer 획득
- [x] `getSectionCells` + `filterVisibleCells` 공통 유틸리티 사용 (PinnedRowRenderer와 동일 패턴)
- [x] `rowVirtualizer.getVirtualItems()` 순회 → `rows[virtualItem.index]` 매핑
- [x] `<TableBody>` > `<TableRow>` + `<TableCell>` 렌더링
- [x] `TableRow`에 `virtualItem`, `rowVirtualizer` props 전달
- [x] key 패턴: `${columnType}-virtual-${row.id}`
- [x] style: `width: table.getTotalSize()`, `height: rowVirtualizer.getTotalSize() === 0 ? '100%' : rowVirtualizer.getTotalSize()`

### Step B: splitRows 중앙화 + Props 전달 체계

> **주의**: 2-3과 2-4는 TypeScript type contract 유지를 위해 반드시 동시에 수행한다.
> 2-3에서 rows props를 전달하면 2-4에서 해당 props를 수신해야 type error가 해소된다.

#### 2-3. TableBodyArea 수정 — splitRows 1회 호출

**파일**: `packages/react/src/table/components/TableBodyArea.tsx`

- [x] `splitRows(table)` 결과를 변수에 저장 (기존과 동일하지만 전체 destructuring)
  ```typescript
  const { topRows, centerRows, bottomRows } = splitRows(table);
  ```
- [x] `combinedRowCount` 계산
  ```typescript
  const combinedRowCount = topRows.length + centerRows.length + bottomRows.length;
  ```
- [x] `TablePinnedRowSection`에 `rows` props 전달
  - `<TablePinnedRowSection position="top" rows={topRows} />`
  - `<TablePinnedRowSection position="bottom" rows={bottomRows} />`
- [x] `TableCenterRowSection`에 `rows`, `combinedRowCount` props 전달
  - `<TableCenterRowSection rows={centerRows} combinedRowCount={combinedRowCount} />`
- [x] `hasTopRows` / `hasBottomRows` 조건은 전달된 rows에서 계산 (기존 로직 유지)

#### 2-4. TablePinnedRowSection 수정 — rows props 수신 + PinnedRowRenderer 사용

**파일**: `packages/react/src/table/components/TablePinnedRowSection.tsx`

- [x] Props에 `rows` 추가
- [x] 내부 `splitRows()` 호출 제거
- [x] 높이 계산: `rows.length * (options.rowHeight || 40)` (rows는 props에서)
- [x] `<TableBodySegment>` 제거, `<PinnedRowRenderer>` 배치
  - left: `<PinnedRowRenderer rows={rows} columnType="left" position={position} />`
  - center: `<PinnedRowRenderer rows={rows} columnType="center" position={position} />`
  - right: `<PinnedRowRenderer rows={rows} columnType="right" position={position} />`

### Step C: TableCenterRowSection 내부 구조 개선

> **주의**: 2-5~2-8은 동일 파일(TableCenterRowSection.tsx)의 동일한 JSX 위치를 수정하므로,
> 하나의 cohesive change로 구현한다. step 분리는 개념적 명확성을 위한 것이며,
> 별도 commit이나 별도 실행을 의미하지 않는다.

#### 2-5. TableCenterRowSection — props 인터페이스 추가

**파일**: `packages/react/src/table/components/TableCenterRowSection.tsx`

- [x] Props 인터페이스 추가
  ```typescript
  interface TableCenterRowSectionProps {
    rows: Row<TableRowData<T>>[]
    combinedRowCount: number
  }
  ```
- [x] `table.getCenterRows()` 호출 제거 → `props.rows` 사용
- [x] `combinedRows` useMemo 제거 → `props.combinedRowCount` 사용
- [x] `isEmpty` 판단: `props.rows.length === 0`

#### 2-6. TableCenterRowSection — isEmpty 처리 Section 레벨 통합

**파일**: `packages/react/src/table/components/TableCenterRowSection.tsx`

- [x] isEmpty일 때 **center 열** — ScrollArea 내부의 `<TableBodySegment>` 대신 `<TableEmptyRow>` 직접 렌더링
- [x] isEmpty일 때 **left/right 열** — 빈 wrapper div 유지 (고정 열 헤더와의 정렬 보존)
- [x] `TableEmptyRow` import 추가
- [x] `useTableCustomStyles()` 추가 (emptyCellClassName용)
- [x] isEmpty 시 ScrollArea 내부:
  ```tsx
  isEmpty ? (
    <TableEmptyRow
      emptyContent={options.emptyContent}
      emptyCellClassName={cn('h-14 text-center ...', customStyles.body?.empty)}
    />
  ) : (
    // 기존 VirtualRowRenderer 또는 StickyTreeRenderer
  )
  ```
- [x] isEmpty 스타일링 유지: `isEmpty && '[&_[data-slot="scroll-area-viewport"]>div]:h-full'`

#### 2-7. TableCenterRowSection — stickyTree 분기 통합

**파일**: `packages/react/src/table/components/TableCenterRowSection.tsx`

- [x] stickyTree 여부를 Section 레벨에서 일괄 결정
  ```typescript
  const isStickyTree = options.expandable?.use && options.expandable.stickyTree?.use;
  ```
- [x] **주의**: 현재 left/right 열의 stickyTree 분기는 `TableCenterRowSection`에 없고
      `TableBodySegment` 내부(line 117)에서만 발생한다.
      이 task는 "기존 코드 이동"이 아니라 **Section 레벨에 새로운 조건부 JSX 구조를 생성**하는 것이다.
      left/center/right 각각에 `isStickyTree` ternary를 추가해야 한다.
- [x] isEmpty 체크가 stickyTree 분기보다 우선한다:
      isEmpty이면 stickyTree 여부와 무관하게 `TableEmptyRow` 렌더링
- [x] stickyTree 렌더링 파이프라인(`parseToStickyTree` → `buildRenderingMetadata` → `calculateTotalTreeHeight`)을
      JSX return 전에 계산. rows와 options에 의존하므로 적절한 메모이제이션 고려.
- [x] stickyTree 모드일 때: left/center/right **모두** `StickyTreeRenderer` 배치
  - StickyTree 관련 import 추가 (`parseToStickyTree`, `buildRenderingMetadata`, `calculateTotalTreeHeight`, `StickyTreeRenderer`)
  - center 영역: `centerBodyRef` 할당 **안 함**, className/style도 stickyTree용으로 변경
  - **구조적 제약 코드 주석 필수 추가**: StickyTreeRenderer가 left/right에 배치되어도 내부적으로 `getCenterVisibleCells()`만 사용하므로 center cells만 렌더링됨. 이 제약을 StickyTreeRenderer 배치 코드에 주석으로 명시할 것:
    ```typescript
    // ⚠️ StickyTreeRenderer는 useStickyTreeCells에서 getCenterVisibleCells()를
    // 하드코딩하므로, left/right 배치 시에도 center cells만 렌더링됨.
    // stickyTree + column pinning 조합은 별도 이슈로 대응 예정.
    ```
- [x] 비-stickyTree 모드일 때: left/center/right에 `VirtualRowRenderer` 배치
  - center 영역: `centerBodyRef` 할당, `rowVirtualizer.getTotalSize()` 기반 height
- [x] `centerBodyRef` 조건부 할당 패턴 정확히 재현
  - 비-stickyTree center에만: `ref={refs.centerBodyRef}`
  - stickyTree: ref 없음, className/style 다름

> **Watch for**:
> - `centerBodyRef`는 stickyTree 모드에서 할당하지 않는다
> - `StickyTreeRenderer`는 내부적으로 `getCenterVisibleCells()`만 사용 (0-2/0-3 결과에 따라 대응)
> - className과 style이 stickyTree/non-stickyTree 모드에서 다르다

#### 2-8. TableCenterRowSection — VirtualRowRenderer 적용

**파일**: `packages/react/src/table/components/TableCenterRowSection.tsx`

- [x] `<TableBodySegment>` 호출 전부 제거
- [x] left 영역: `<VirtualRowRenderer rows={rows} columnType="left" />`
- [x] center 영역: `<VirtualRowRenderer ref={refs.centerBodyRef} rows={rows} columnType="center" className={...} style={...} />`
- [x] right 영역: `<VirtualRowRenderer rows={rows} columnType="right" />`
- [x] left/right 영역에는 ref가 없음 확인 (leftBodyRef/rightBodyRef는 wrapper div에 할당)

> **Watch for**:
> - left/right 열에는 ref를 할당하지 않는다 (leftBodyRef/rightBodyRef는 wrapper div에 있음)
> - center 열의 ref는 VirtualRowRenderer에 forwardRef로 전달
> - `rowVirtualizer.getTotalSize() === 0`인 경우 height fallback `'100%'` 필요
>
> **ref 전달 체인 검증 체크리스트** (C2 대응 — 가장 높은 단일 위험):
> - [x] 비-stickyTree center: `VirtualRowRenderer ref={refs.centerBodyRef}` 전달 확인
> - [x] 비-stickyTree center: `className`에 `overflow-x-hidden` 포함 확인
> - [x] 비-stickyTree center: `style`에 `width: table.getTotalSize()`, `height: rowVirtualizer.getTotalSize() || '100%'` 확인
> - [x] stickyTree center: `centerBodyRef` 할당 **안 됨** 확인
> - [x] stickyTree center: `className`이 stickyTree용으로 변경됨 확인 — N/A (StickyTreeRenderer가 자체 스타일 관리)
> - [x] stickyTree center: `style`이 stickyTree 높이 기반으로 변경됨 확인 — N/A (StickyTreeRenderer가 totalHeight 사용)
> - [x] left/right: ref 미할당 확인 (wrapper div에만 leftBodyRef/rightBodyRef)
> - [x] `bodyRef` + `bodyScrollRef` ScrollArea 연결 미변경 확인

#### 2-9. rowHeight 40px 하드코딩 수정 (기존 버그)

**파일**: `packages/react/src/table/components/TableCenterRowSection.tsx`

- [x] `combinedRows.length * 40` → `combinedRowCount * (options.rowHeight || 40)` 변경
- [x] `options.maxVisibleRows * 40` → `options.maxVisibleRows * (options.rowHeight || 40)` 변경

### Step D: 검증 + 정리

#### 2-10. 중간 품질 검증

- [x] `pnpm typecheck` 통과
- [x] `pnpm run test` 통과

#### 2-11. 교차 기능 시나리오 수동 검증 (TableBodySegment 삭제 전)

> TableBodySegment가 아직 존재하는 상태에서 검증하여, 문제 발생 시 기존 코드와 즉시 비교 가능

- [ ] Row pinning + Column pinning 동시 사용 (Storybook) — **수동 검증 필요**
- [ ] maxVisibleRows + Row pinning 동시 사용 (Storybook) — **수동 검증 필요**
- [ ] stickyTree + 스크롤 동기화 (Storybook) — **수동 검증 필요**
- [ ] 빈 상태 표시 정상 동작 (Storybook) — **수동 검증 필요**
- [ ] 무한 스크롤 정상 동작 (Storybook) — **수동 검증 필요**
- [x] `useEffect` (초기 무한 스크롤 로드)와 `onScroll` 핸들러 내 `handleInfiniteScroll` 호출 두 곳 모두 유지 확인
- [ ] Phase 0 baseline 결과와 비교하여 regression 없음 확인 — **수동 검증 필요**

#### 2-12. TableBodySegment 삭제

- [x] `TableBodySegment.tsx` 삭제
- [x] 모든 파일에서 `TableBodySegment` import가 없는지 확인

#### 2-13. 미사용 코드 정리 + 최종 검증

- [x] 삭제된 컴포넌트의 barrel export 제거 (있다면)
- [x] 미사용 import 정리
- [x] `splitRows` import가 `TableBodyArea.tsx`에만 남는지 확인
- [x] `pnpm typecheck` 통과
- [x] `pnpm lint` 통과 (+ `pnpm lint:fix` 필요시)
- [x] `pnpm run test` 전체 통과 (91 suites, 743 tests)

### Phase 2 세션 노트 (2026-02-06)

1. **구현 결과**: 4 commits로 Phase 2 완료
   - Commit 1: `rowRendererUtils.ts` + `PinnedRowRenderer.tsx` + `VirtualRowRenderer.tsx` 신규 생성
   - Commit 2: `splitRows` 중앙화 (TableBodyArea → props 전달) + `TablePinnedRowSection`에 `PinnedRowRenderer` 적용
   - Commit 3: `TableCenterRowSection` 전면 수정 (props 인터페이스, isEmpty, stickyTree, VirtualRowRenderer, rowHeight 버그 수정)
   - Commit 4: `TableBodySegment.tsx` 삭제 (176줄 제거) + lint 수정
2. **검증 결과**: `pnpm typecheck` 통과, `pnpm lint` 0 errors, `pnpm test` 91 suites / 743 tests 전체 통과
3. **아키텍처 결정**:
   - `BaseRowRendererProps` 공유 인터페이스 대신 각 Renderer에 독립 인터페이스 정의 (over-abstraction 방지)
   - `stickyTreeData`를 `useStickyTreeData` 훅으로 추출 (`StickyTree/hooks/`에 배치, useMemo로 메모이제이션)
   - `renderCenterContent`/`renderSideContent` → 단일 `renderContent(columnType)` 함수로 통합
   - `ColumnSection` 타입을 `table.types.ts`에 정의하여 4개 파일의 `'left' | 'center' | 'right'` 리터럴 중복 제거
   - `rowVirtualizer` import를 `TableCenterRowSection`에서 제거 (`VirtualRowRenderer` 내부로 이동)
4. **rowHeight 버그 수정**: `combinedRows.length * 40` → `combinedRowCount * rowHeight` (`options.rowHeight || 40`)
5. **Clean Code 적용** (Phase 2 후속):
   - `useStickyTreeData` 훅 추출 → `StickyTree/hooks/`에 배치 (응집도 향상)
   - `renderCenterContent` + `renderSideContent` → `renderContent` 통합 (53줄 → 15줄)
   - `ColumnSection` 타입 추출 → `rowRendererUtils`, `PinnedRowRenderer`, `VirtualRowRenderer`, `TableCenterRowSection` 적용
   - `tsup.config.ts`에 `injectStyle` 목적 주석 추가
   - `TableCenterRowSection`: 214줄 → 168줄, import 15 → 12개
6. **미완료**: Storybook 수동 검증 (2-11) — RowPinning, ColumnPinning, Expanding, InfiniteScroll, EmptyState, maxVisibleRows 조합 수동 확인 필요

---

## 파일 변경 요약

| 파일 | Phase | 변경 |
|------|-------|------|
| `TablePinnedRowSection.tsx` | 1-1 신규 → 2-4 수정 | Top/Bottom 통합, 이후 rows props 수신 |
| `TableBodyArea.tsx` | 1-2 수정 → 2-3 수정 | import 교체, 이후 splitRows 중앙화 |
| `TableTopRowSection.tsx` | 1-3 | 삭제 |
| `TableBottomRowSection.tsx` | 1-3 | 삭제 |
| `PinnedRowRenderer.tsx` | 2-1 | 신규 |
| `VirtualRowRenderer.tsx` | 2-2 | 신규 |
| `TableCenterRowSection.tsx` | 2-5~2-9 | props 수신, isEmpty 통합, stickyTree 통합, rowHeight 수정 |
| `TableBodySegment.tsx` | 2-12 | 삭제 |
| `TableEmptyRow.tsx` | 2-6 | import 추가 (TableCenterRowSection에서 직접 사용) |
| `StickyTree/*` | 2-7 | import 추가 (TableCenterRowSection에서 직접 사용) |
| `StickyTree/hooks/useStickyTreeData.ts` | CC | 신규 — stickyTree 데이터 계산 훅 (IIFE → useMemo 훅) |
| `StickyTree/index.ts` | CC | `useStickyTreeData` barrel export 추가 |
| `table.types.ts` | CC | `ColumnSection` 타입 추가 |
| `rowRendererUtils.ts` | 2-1 → CC 수정 | `ColumnSection` 타입 적용 |
| `tsup.config.ts` | CC | `injectStyle` 목적 주석 추가 |
| 공통 유틸리티 | 2-1 | `getSectionCells`, `filterVisibleCells` — Renderer 간 cell 선택/필터링 공유 |

---

## 검증 전략

각 Phase 완료 시:
1. `pnpm typecheck && pnpm lint` — 정적 분석
2. `pnpm run test` — 92 파일, 749 테스트 (jsdom + browser + storybook 통합) ※ rowRendererUtils 테스트 제거 시 91/743으로 복귀
3. Storybook 수동 확인 — 교차 기능 시나리오 (Phase 0 baseline과 비교)

**롤백 계획:**
- 각 commit 후 `pnpm run test` 실행 → 실패 시 즉시 `git revert` 가능
- Phase 2 전체 문제 발생 시: `git revert --no-commit` 으로 PR 2 전체 롤백
- `git bisect`로 4 commit 중 문제 지점 특정 (최대 2회 테스트로 범위 좁힘)
