# Table 컴포넌트 구조 개선 분석

> **문서 검증 완료 (2026-02-05)**: 실제 코드 분석을 통해 모든 문제점이 검증되었으며, 제안된 개선 방향이 타당함을 확인함.
>
> **비판적 분석 완료 (2026-02-05)**: 제안된 개선 방향에 대한 비판적 검토를 수행하여 trade-off와 대안을 추가함.
>
> **Deep Think 검토 완료 (2026-02-06)**: 4개 독립 분석 경로(First Principles / Pragmatic Engineer / Adversarial Reviewer / Creative Innovator)로 교차 검증 수행. 핵심 방향 유지, 3가지 설계 수정 반영(getCells→columnType, isEmpty Section 이동, 이름 유지), 필수 선행 작업 4건 확정.

## 현재 구조

```
TableRenderer
  └─ TableBodyArea
       ├─ TableTopRowSection
       │    └─ TableBodySegment(left/top)
       │    └─ TableBodySegment(center/top)
       │    └─ TableBodySegment(right/top)
       ├─ TableCenterRowSection
       │    └─ TableBodySegment(left/center)
       │    └─ TableBodySegment(center/center)
       │    └─ TableBodySegment(right/center)
       └─ TableBottomRowSection
            └─ TableBodySegment(left/bottom)
            └─ TableBodySegment(center/bottom)
            └─ TableBodySegment(right/bottom)
```

9개 세그먼트 모두 동일한 `TableBodySegment` 컴포넌트가 `columnType`과 `rowType` 문자열 조합으로 분기 처리한다.

---

## 문제점

### 1. TableBodySegment는 너무 많이 아는 디스패처

`TableBodySegment`는 `columnType` × `rowType` 조합으로 내부에서 9가지 다른 동작을 분기하는 멀티플렉서다. 디스패처 패턴 자체는 React에서 흔하지만(Routes, connect 등), 이 컴포넌트는 table context, rowVirtualizer context, options context를 모두 직접 읽으면서 디스패치 로직과 렌더링 로직이 엉켜 있다는 것이 문제다.

한 컴포넌트 안에서 담당하는 것:

- `rowType`으로 rows 선택 (`splitRows` → top / center / bottom)
- `columnType`으로 cells 선택 (`getLeftVisibleCells` / `getCenterVisibleCells` / `getRightVisibleCells`)
- `rowType`이 top/bottom이면 직접 렌더링, center면 가상화 렌더링
- stickyTree 옵션이 켜져 있으면 또 다른 렌더링 경로
- center-center 조합일 때만 빈 상태 처리

**핵심 문제: 결정의 이중화(decision duplication).** 부모가 이미 알고 있는 정보(어떤 rows인지, 어떤 렌더링 전략인지)를 자식이 문자열 prop으로 다시 받아 재계산하는 구조다. `TableTopRowSection`은 자기가 "top 영역"이라는 것을 알고 `splitRows()`로 topRows를 꺼내 높이를 계산하면서도, `<TableBodySegment rowType="top">`으로 문자열을 넘기면 `TableBodySegment`가 다시 `splitRows()`를 호출해서 topRows를 꺼낸다.

**반론 고려:** Context를 통해 table을 공유하고 각 컴포넌트가 자신에게 필요한 데이터를 직접 가져오는 패턴은 React에서 흔히 사용된다. props drilling을 피하고 자기완결성을 높이려는 의도적 선택일 수 있다. 그러나 "수정하기 좋은 코드" 관점에서 splitRows 로직이 변경되면 4곳 모두 영향받고, 데이터 흐름 추적이 어렵다는 점은 문제다.

rows와 columnType을 props로 받는 RowRenderer로 변경하면 rowType 분기가 소멸하고, columnType 분기는 3줄짜리 단순 매핑으로 축소된다.

> 참고: `TableBodySegment.tsx` 43행, 60-69행, 87-115행, 117-123행, 126-169행

### 2. 3-column 레이아웃의 부분적 중복

`TableTopRowSection`과 `TableBottomRowSection`은 거의 동일한 구조다. shadow 방향, ref 이름, scroll 핸들러만 다르고 나머지는 복사-붙여넣기 수준이다. 이 두 컴포넌트는 하나로 합칠 수 있다.

단, `TableCenterRowSection`은 구조적으로 상당히 다르다:

| | TopRowSection / BottomRowSection | CenterRowSection |
|---|---|---|
| **center 래퍼** | `<div>` | `<ScrollArea>` + 무한스크롤 + stickyTree 분기 + maxVisibleRows |
| **높이** | 고정 (`rows.length * rowHeight`) | 유동 (`size-full` or `maxVisibleRows`) |
| **ref** | 단일 (`topBodyRef` / `bottomBodyRef`) | 복합 (`bodyRef` + `bodyScrollRef` + `centerBodyRef`) |
| **부가 로직** | 초기 scrollLeft 동기화 | 무한 스크롤 useEffect |
| **isEmpty 스타일** | 없음 | `isEmpty && '[&_[data-slot="scroll-area-viewport"]>div]:h-full'` |
| **maxVisibleRows** | 없음 | 높이 계산 로직 (`combinedRows.length < maxVisibleRows ? ...`) |

left/right 고정 열 래퍼 패턴은 3곳에서 반복되므로 공유할 수 있지만, center 영역까지 하나의 추상화로 묶으면 render prop이나 조건부 로직이 추상화 안으로 이동할 뿐 복잡성이 줄지 않는다.

> 참고: `TableTopRowSection.tsx` 42-79행, `TableCenterRowSection.tsx` 50-127행, `TableBottomRowSection.tsx` 42-79행

### 3. splitRows() 중복 호출 — 데이터 source 분산

`splitRows(table)`이 **4군데**에서 호출된다:

| 위치 | 용도 |
|------|------|
| `TableBodyArea.tsx:13` | top/bottom rows 유무 확인 |
| `TableTopRowSection.tsx:15` | topRows 높이 계산 |
| `TableBottomRowSection.tsx:16` | bottomRows 높이 계산 |
| `TableBodySegment.tsx:39` | 실제 렌더링할 rows 선택 |

`splitRows` 자체는 가벼운 함수이고 TanStack Table의 `getTopRows()`/`getBottomRows()`는 내부적으로 메모이제이션되므로 **성능 문제는 아니다**. 본질은 데이터 source 분산 문제다. 부모가 이미 계산한 결과를 props로 내리지 않고, 자식이 context에서 table을 꺼내 동일한 계산을 독립적으로 수행한다. 정보가 위에서 아래로 흐르지 않고 각 레벨에서 재계산되는 구조다.

**Trade-off 인식:** props로 rows를 전달하면 1-2단계의 props drilling이 발생한다. 하지만 데이터 흐름이 명확해지고, splitRows 로직 변경 시 한 곳만 수정하면 되는 이점이 더 크다.

### 4. 렌더링 전략 결정이 두 레벨에 걸쳐 있음

stickyTree 렌더링 분기가 **두 컴포넌트에 나뉘어** 있다:

- `TableCenterRowSection.tsx:96-110` — stickyTree면 ref/style을 생략
- `TableBodySegment.tsx:117-123` — stickyTree면 `StickyTreeRenderer` 사용

한 가지 결정이 두 파일에 분산되어 있어서, stickyTree 관련 수정 시 항상 두 파일을 함께 봐야 한다.

---

## 개선 방향

### 원칙

> 컴포넌트 이름 = 그 컴포넌트가 렌더링하는 것

`TableBodySegment(columnType="left", rowType="top")`보다, 컴포넌트 트리 자체가 UI 구조를 설명하는 형태를 목표로 한다.

### 역할 분리

#### 1. RowSection 레벨

**`TablePinnedRowSection`** / **`TableCenterRowSection`**

- 역할: 행 그룹의 컨테이너. 높이, overflow, z-index, shadow 등 행 그룹 수준의 레이아웃만 담당
- `TablePinnedRowSection`은 top/bottom을 `position` prop으로 구분 (레이아웃만 다르므로 통합 가능)
- `TableCenterRowSection`은 내부 구조를 개선하되 이름을 유지 (위치 기반 이름 "Center"는 항상 참이므로 동작 기반 "Scrollable"보다 안정적)
- **rows 데이터를 props로 받아서** 자식에게 전달
- **빈 상태(isEmpty) 처리는 Section 레벨**에서 담당: `TableCenterRowSection`이 isEmpty 판단 후 center 열에 `TableEmptyRow`를 직접 렌더링
- 각 Section이 left/center/right 래퍼를 자체적으로 관리 (Top/Bottom 통합으로 3곳 → 2곳 중복 감소, 추가 추상화 불필요)

#### 2. RowRenderer 레벨

**`PinnedRowRenderer`** / **`VirtualRowRenderer`** (현재 TableBodySegment가 맡는 역할의 핵심)

- 역할: 주어진 rows를 `TableRow` + `TableCell`로 변환하는 순수한 매핑
- `PinnedRowRenderer`: rows를 직접 순회하여 렌더링 (top/bottom 고정 행용)
- `VirtualRowRenderer`: virtualItems를 통해 가상화 렌더링 (center 스크롤 행용). **rows props를 받되, 내부에서 rowVirtualizer context를 통해 virtualItems와 매핑. `React.forwardRef` 지원 필수** (centerBodyRef 전달용)
- stickyTree는 기존 `StickyTreeRenderer` 유지 (이미 잘 분리되어 있음, 완전히 다른 렌더링 시스템이므로 RowRenderer와 인터페이스 통일 불필요)
- `columnType: 'left' | 'center' | 'right'` prop으로 열 선택: 내부에서 3줄짜리 switch로 적절한 cells를 선택. TanStack Table API가 left/center/right 3분할로 고정되어 있어 콜백의 유연성이 불필요(YAGNI)

### 제안 구조

```
TableBodyArea
  ├─ splitRows() 1회 호출, combinedRowCount 계산
  │
  ├─ TablePinnedRowSection rows={topRows} position="top"
  │    ├─ left:   PinnedRowRenderer rows={topRows} columnType="left"
  │    ├─ center: PinnedRowRenderer rows={topRows} columnType="center"
  │    └─ right:  PinnedRowRenderer rows={topRows} columnType="right"
  │
  ├─ TableCenterRowSection rows={centerRows} combinedRowCount={...}
  │    ├─ (isEmpty면 center에 TableEmptyRow 직접 렌더링)
  │    ├─ left:   VirtualRowRenderer columnType="left" 또는 StickyTreeRenderer
  │    ├─ center: ScrollArea > (VirtualRowRenderer ref={centerBodyRef} columnType="center" 또는 StickyTreeRenderer)
  │    └─ right:  VirtualRowRenderer columnType="right" 또는 StickyTreeRenderer
  │
  └─ TablePinnedRowSection rows={bottomRows} position="bottom"
       ├─ left:   PinnedRowRenderer rows={bottomRows} columnType="left"
       ├─ center: PinnedRowRenderer rows={bottomRows} columnType="center"
       └─ right:  PinnedRowRenderer rows={bottomRows} columnType="right"
```

### 핵심 변경점 요약

| 현재 | 개선 후 |
|------|---------|
| `splitRows()` 4곳에서 호출 | 최상위 1회만 호출, 결과를 props로 전달 |
| Top/Bottom이 별도 컴포넌트 | TablePinnedRowSection으로 통합 (`position` prop) |
| TableCenterRowSection | 이름 유지, 내부 구조 개선 (stickyTree 분기 통합, isEmpty Section 레벨 처리) |
| left/right 래퍼 3곳 중복 | 2곳으로 감소 (통합에 의한 자연 해소) |
| stickyTree 결정이 2개 컴포넌트에 분산 | TableCenterRowSection에서 일괄 결정 |
| TableBodySegment가 9가지 경우 분기 | PinnedRowRenderer / VirtualRowRenderer로 역할 분리 (columnType prop 유지) |

### 파일 변경 계획

| 파일 | 변경 |
|------|------|
| `TableBodySegment.tsx` | **삭제** |
| `TableTopRowSection.tsx` | **삭제** |
| `TableBottomRowSection.tsx` | **삭제** |
| `TableCenterRowSection.tsx` | **내부 구조 개선** (stickyTree 분기 통합, isEmpty Section 레벨 처리, rows/combinedRowCount props 수신) |
| (신규) `PinnedRowRenderer.tsx` | 고정 행 렌더링. rows 직접 순회, columnType prop으로 열 선택 |
| (신규) `VirtualRowRenderer.tsx` | 가상화 행 렌더링. virtualItems → rows 접근, columnType prop, forwardRef 지원 |
| (신규) `TablePinnedRowSection.tsx` | Top/Bottom 통합. `position` prop으로 shadow/ref/scroll handler 분기 |
| `TableBodyArea.tsx` | splitRows 1회 호출, combinedRowCount 계산, 결과를 각 Section에 props로 전달 |

**실행 전략: 2개 PR로 분리**

**PR 1: Top/Bottom 통합 (독립적, 먼저 merge)**

1. `TablePinnedRowSection` 생성 (Top/Bottom 통합, `position` prop)
2. `TableBodyArea` 수정 (import 변경 + JSX 교체)
3. `TableTopRowSection.tsx`, `TableBottomRowSection.tsx` 삭제
4. browser 테스트 전체 통과 확인

**PR 2: TableBodySegment 대체 + splitRows 중앙화 (PR 1 merge 후)**

1. `PinnedRowRenderer` / `VirtualRowRenderer` 생성
2. `TableBodyArea` 수정: splitRows 1회 호출, combinedRowCount 계산, 결과를 Section에 props로 전달
3. `TablePinnedRowSection` 수정: rows를 props로 받아서 PinnedRowRenderer에 전달
4. `TableCenterRowSection` 수정: rows/combinedRowCount를 props로 받아서 VirtualRowRenderer/StickyTreeRenderer에 전달, stickyTree 분기 통합, isEmpty 처리 Section 레벨로 이동
5. `TableBodySegment.tsx` 삭제
6. browser 테스트 전체 통과 확인

---

## 채택하지 않은 대안

### 1. ThreeColumnLayout 공통 컴포넌트

left/center/right 3열 래퍼 패턴이 3곳에서 반복되므로 `ThreeColumnLayout` 같은 추상화를 고려할 수 있다.

**채택하지 않은 이유:**
- TablePinnedRowSection과 TableCenterRowSection의 center 영역이 구조적으로 상당히 다름
  - Pinned: 단순 `<div>`
  - Center: `<ScrollArea>` + 무한스크롤 + stickyTree 분기 + maxVisibleRows 높이 계산
- 공통 컴포넌트로 묶으면 render prop이나 조건부 로직이 추상화 내부로 이동할 뿐, 복잡성이 줄지 않음
- Top/Bottom 통합으로 3곳 → 2곳 중복 자연 감소, 추가 추상화 비용 > 이득

### 2. getCells 콜백으로 열 선택 외부 위임

columnType prop 대신 `getCells={(row) => row.getLeftVisibleCells()}` 콜백을 props로 받아 열 선택 로직을 RowRenderer 외부에 두는 방법.

**채택하지 않은 이유:**
- **YAGNI**: TanStack Table API가 left/center/right 3분할로 고정되어 있어 콜백의 유연성이 불필요. 불필요한 유연성은 "다른 종류의 getCells도 들어올 수 있다"는 잘못된 신호를 보냄
- **StickyTreeRenderer 인터페이스 불일치**: StickyTreeRenderer는 getCells를 사용하지 않으므로, 같은 위치에 배치되는 두 렌더러의 인터페이스가 불일치
- **isEmpty 판별 모순**: getCells로 열 선택을 외부화하면서 isEmpty에서는 다시 "center인지"를 알아야 하는 모순 발생
- **React key 생성 불리**: 현재 `${columnType}-${rowType}-${row.id}` 패턴에서 columnType 정보가 key 생성에 직접 활용됨
- **디버깅 불리**: React DevTools에서 `columnType="left"`는 즉시 의미가 파악되지만, 함수 내용은 열어봐야 함
- columnType의 3줄짜리 switch문은 "제거해야 할 복잡성"이 아니라 "3가지 고정값에 대한 단순 매핑"임

### 3. Context 패턴 완전 유지 (현재 구조 유지)

splitRows를 각 컴포넌트에서 독립적으로 호출하는 현재 패턴을 유지.

**채택하지 않은 이유:**
- "수정하기 좋은 코드" 관점에서 데이터 흐름 추적이 어려움
- splitRows 로직 변경 시 4곳 동시 검토 필요
- 테스트 시 모든 컴포넌트에서 table context 설정 필요

---

### 주의할 점

#### 렌더링 관련

- **빈 상태 처리**: `TableEmptyRow`는 **`TableCenterRowSection`(Section 레벨)**에서 조건부 렌더링. isEmpty일 때 center 열의 VirtualRowRenderer 대신 `TableEmptyRow`를 직접 렌더링한다. RowRenderer는 isEmpty에 대해 알 필요가 없어진다. isEmpty 스타일링(`isEmpty && '[&_[data-slot="scroll-area-viewport"]>div]:h-full'`)도 같은 Section 레벨에 있으므로, 렌더링 결정도 같은 레벨에 두는 것이 응집도 면에서 일관적이다.
- **cell 가시성**: `table.isCellHidden()` 필터링은 RowRenderer 내부에 유지. cell 가시성은 렌더링 시점의 관심사다.

#### stickyTree 관련

- **stickyTree 적용 범위**: stickyTree 모드에서는 **left/center/right 모든 열**에 `StickyTreeRenderer`가 사용된다. 현재 `TableBodySegment.tsx:117-123`에서 stickyTree 분기는 `columnType`과 무관하게 `rowType === 'center'`이면 발동되며, 이것이 의도된 동작이다. `TableCenterRowSection`에서 stickyTree 여부를 일괄 결정하고, stickyTree 모드면 left/center/right 세 영역 모두에 `StickyTreeRenderer`를 배치한다.
- **stickyTree의 cells 접근**: `StickyTreeRenderer`는 `table` context에서 직접 cells를 가져오며, VirtualRowRenderer와는 완전히 다른 렌더링 시스템(자체 파싱 파이프라인, CSS sticky 기반, 비가상화)이다. 인터페이스 통일을 강제하면 StickyTree의 내부 응집도가 깨지므로, 독자적 인터페이스를 존중한다.

#### stickyTree + Column Pinning 조합 (잠재적 이슈)

**발견된 문제:** `useStickyTreeCells.ts:27`에서 `row.getCenterVisibleCells()`를 하드코딩하고 있다. 이는 StickyTreeRenderer가 center 열만 렌더링한다는 의미다.

현재 동작 분석:
1. `TableCenterRowSection`의 left/right 영역에서 `TableBodySegment(left/right, center)` 호출
2. `TableBodySegment.tsx:117-123`에서 stickyTree 조건 충족 시 `StickyTreeRenderer` 반환
3. 하지만 `StickyTreeRenderer` 내부에서 `getCenterVisibleCells()`만 사용

**결과:** stickyTree + column pinning 조합 시 left/right 고정 열이 비어 보일 가능성이 있다.

**확인 필요:**
1. 이 조합이 실제로 사용되는 케이스가 있는지 (기존 테스트 케이스 검토)
2. 의도된 제약 사항인지, 버그인지
3. 제약 사항이라면 문서화, 버그라면 리팩토링 시 해결 필요

#### props 및 ref 관련

- **ref 전달 체인**: `centerBodyRef`, `bodyScrollRef` 등의 ref 연결이 깨지지 않도록 주의. 특히 `TableCenterRowSection`에서 `ScrollArea`에 걸리는 `bodyRef` + `bodyScrollRef` + `centerBodyRef` 3개의 ref가 올바르게 연결되어야 한다.
- **centerBodyRef 조건부 할당**: stickyTree 모드에서는 `centerBodyRef`를 **의도적으로 할당하지 않으며**, `className`과 `style`도 달라진다 (현재 `TableCenterRowSection:96-112`). 이 미묘한 조건부 ref 할당 패턴이 새 구조에서 정확히 재현되어야 한다. 비-stickyTree 모드에서만 center column의 VirtualRowRenderer에 centerBodyRef를 전달한다.
- **VirtualRowRenderer의 forwardRef 지원**: `React.forwardRef`를 반드시 지원해야 한다. centerBodyRef 전달을 위해 필요하며, 현재 `TableBodySegment`도 forwardRef를 사용한다.
- **VirtualRowRenderer의 rows 접근**: rows를 props로 받되, 내부에서 `rowVirtualizer.getVirtualItems()`로 virtualItems를 구하고 `rows[virtualItem.index]`로 접근하는 방식. PinnedRowRenderer와 다르게 rows를 직접 순회하지 않음.
- **left/right column의 ref 비대칭**: Top/Bottom Section의 left/right column에는 ref가 없고, Center Section에만 `leftBodyRef`/`rightBodyRef`가 할당된다. `TablePinnedRowSection` 구현 시 이 비대칭을 정확히 재현해야 한다.

#### CenterRowSection 고유 로직

`TableCenterRowSection`이 유지해야 할 고유 로직:

1. **무한 스크롤 useEffect**: `table.handleInfiniteScroll()` 호출 (초기 로드용 useEffect + onScroll 핸들러 내부 호출 두 곳 모두 유지)
2. **maxVisibleRows 높이 계산**: `combinedRowCount < maxVisibleRows` 분기. `combinedRowCount`는 `TableBodyArea`에서 `topRows.length + centerRows.length + bottomRows.length`로 계산하여 props로 전달 (실제 combinedRows 배열은 불필요, 길이만 필요)
3. **isEmpty 처리**: isEmpty 판단 + ScrollArea viewport 높이 확장 스타일링 + center 열에 `TableEmptyRow` 직접 렌더링 (모두 Section 레벨에서 통합 처리)
4. **복합 ref 관리**: `bodyRef`, `bodyScrollRef`, `centerBodyRef` 동시 처리 (stickyTree 모드에서 centerBodyRef 조건부 생략)
5. **rowHeight 40px 하드코딩 수정 (기존 버그)**: 현재 `combinedRows.length * 40`으로 하드코딩. `options.rowHeight`를 사용하도록 리팩토링 시 함께 수정

---

## 검증 결과 요약

### 코드 검증 완료 항목

| 문제점 | 문서 위치 | 코드 검증 |
|--------|----------|---------|
| splitRows 4곳 호출 | 63-75행 | ✅ TableBodyArea(13), TableTopRowSection(15), TableBottomRowSection(16), TableBodySegment(39) |
| TableBodySegment 9가지 분기 | 28-44행 | ✅ rowType(3) × columnType(3) = 9가지 조합 |
| Top/Bottom 중복 | 46-61행 | ✅ 약 80% 코드 동일, shadow/ref/handler만 다름 |
| stickyTree 분기 분산 | 76-83행 | ✅ TableCenterRowSection:96-110 + TableBodySegment:117-123 |
| 빈 상태 처리 center-center만 | 174행 | ✅ TableBodySegment:43에서 `columnType === 'center' && rowType === 'center'` 조건 |

### 제안 방향 검증 결과

| 제안 | 검증 결과 |
|------|-----------|
| PinnedRowRenderer / VirtualRowRenderer 분리 | ✅ 타당. rowType 분기 제거, columnType은 단순 매핑으로 축소 |
| TablePinnedRowSection으로 Top/Bottom 통합 | ✅ 타당. 80% 중복 코드 제거, position prop으로 shadow/ref/handler만 분기 |
| splitRows 1회 호출 후 props 전달 | ✅ 타당. 정보 흐름이 하향식으로 개선, props drilling은 1-2단계로 수용 가능 |
| left/right 래퍼 추가 추상화 불필요 | ✅ 타당. 통합으로 3곳 → 2곳 자연 감소, 과한 추상화 방지 |
| stickyTree 결정을 TableCenterRowSection에서 일괄 처리 | ✅ 타당. 응집도 향상, 두 파일 동시 수정 불필요 |

### 추가 발견 사항 (문서에 반영됨)

- isEmpty 처리를 Section 레벨로 통합 (렌더링 결정 + 스타일링 + EmptyRow 모두 같은 레벨)
- maxVisibleRows의 combinedRowCount props 전달 방식 확정
- VirtualRowRenderer의 rows 접근 방식 명시 (virtualItems → rows 매핑)
- VirtualRowRenderer의 forwardRef 지원 필수 (centerBodyRef 전달용)
- centerBodyRef 조건부 할당 패턴 명시 (stickyTree 모드에서 생략)
- left/right column ref 비대칭 명시 (Center Section에만 할당)
- StickyTreeRenderer는 독자적 인터페이스 유지 (인터페이스 통일 불필요)
- columnType prop 채택, getCells 콜백 불채택 (YAGNI, 인터페이스 일관성)
- rowHeight 40px 하드코딩 기존 버그 발견

---

## 필수 선행 작업 (리팩토링 착수 전 완료)

### 1. stickyTree + Column Pinning 조합 현황 확인 및 대응 결정

`useStickyTreeCells.ts:27`과 `StickyTreeNode.tsx:46`에서 `getCenterVisibleCells()`를 하드코딩하고 있어, stickyTree + column pinning 조합 시 left/right 고정 열에 center column의 cells가 중복 렌더링되는 기존 버그 가능성이 있다. 리팩토링과 버그 수정을 동시에 하지 않는 원칙을 따른다.

- [ ] Storybook에서 stickyTree + column pinning 조합 수동 테스트하여 현재 동작 확인
- [ ] 의도적 미지원이라면: API validation으로 차단 + 문서화 (별도 이슈)
- [ ] 지원이 필요하면: **리팩토링과 별도로** StickyTreeRenderer에 columnType prop 추가하여 먼저 수정

### 2. maxVisibleRows의 combinedRowCount 인터페이스 확정

현재 `TableCenterRowSection`에서 `combinedRows = [...table.getTopRows(), ...table.getCenterRows(), ...table.getBottomRows()]`로 ScrollArea 높이를 결정한다. 구조 변경 후 center rows만 props로 받으므로 top/bottom rows 정보도 필요하다.

- [ ] `combinedRowCount = topRows.length + centerRows.length + bottomRows.length`를 `TableBodyArea`에서 계산하여 props로 전달하는 방식 확정
- [ ] 실제 combinedRows 배열은 불필요하고 길이만 필요함을 확인

### 3. 교차 기능 시나리오 테스트 보강

리팩토링의 안전망으로 다음 조합에 대한 테스트를 추가한다:

- [ ] Row pinning + Column pinning 동시 사용
- [ ] maxVisibleRows + Row pinning 동시 사용
- [ ] stickyTree + 스크롤 동기화 명시적 검증
- [ ] 기존 browser 테스트 전체 통과 확인
