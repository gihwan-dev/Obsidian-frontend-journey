# Table 컴포넌트 구조 개선 분석

> **문서 검증 완료 (2026-02-05)**: 실제 코드 분석을 통해 모든 문제점이 검증되었으며, 제안된 개선 방향이 타당함을 확인함.
>
> **비판적 분석 완료 (2026-02-05)**: 제안된 개선 방향에 대한 비판적 검토를 수행하여 trade-off와 대안을 추가함.

## 현재 구조

```
TableRenderer
  └─ TableBodyArea
       ├─ TableTopRowSection
       │    └─ TableBodySegment(left/top)
       │    └─ TableBodySegment(center/top)
       │    └─ TableBodySegment(right/top)
       ├─ TableCenterRowSection
       │    └─ TableBodySegment(left/center)
       │    └─ TableBodySegment(center/center)
       │    └─ TableBodySegment(right/center)
       └─ TableBottomRowSection
            └─ TableBodySegment(left/bottom)
            └─ TableBodySegment(center/bottom)
            └─ TableBodySegment(right/bottom)
```

9개 세그먼트 모두 동일한 `TableBodySegment` 컴포넌트가 `columnType`과 `rowType` 문자열 조합으로 분기 처리한다.

---

## 문제점

### 1. TableBodySegment는 컴포넌트가 아니라 디스패처

`TableBodySegment`는 `columnType` × `rowType` 조합으로 내부에서 9가지 다른 동작을 분기하는 멀티플렉서다.

한 컴포넌트 안에서 담당하는 것:

- `rowType`으로 rows 선택 (`splitRows` → top / center / bottom)
- `columnType`으로 cells 선택 (`getLeftVisibleCells` / `getCenterVisibleCells` / `getRightVisibleCells`)
- `rowType`이 top/bottom이면 직접 렌더링, center면 가상화 렌더링
- stickyTree 옵션이 켜져 있으면 또 다른 렌더링 경로
- center-center 조합일 때만 빈 상태 처리

**핵심 문제: 데이터 source 분산.** 부모가 이미 알고 있는 정보(어떤 rows인지, 어떤 렌더링 전략인지)를 자식이 문자열 prop으로 다시 받아 재계산하는 구조다. `TableTopRowSection`은 자기가 "top 영역"이라는 것을 알고 `splitRows()`로 topRows를 꺼내 높이를 계산하면서도, `<TableBodySegment rowType="top">`으로 문자열을 넘기면 `TableBodySegment`가 다시 `splitRows()`를 호출해서 topRows를 꺼낸다.

**반론 고려:** Context를 통해 table을 공유하고 각 컴포넌트가 자신에게 필요한 데이터를 직접 가져오는 패턴은 React에서 흔히 사용된다. props drilling을 피하고 자기완결성을 높이려는 의도적 선택일 수 있다. 그러나 "수정하기 좋은 코드" 관점에서 splitRows 로직이 변경되면 4곳 모두 영향받고, 데이터 흐름 추적이 어렵다는 점은 문제다.

rows와 getCells를 props로 받는 RowRenderer로 변경하면 분기 자체가 소멸한다.

> 참고: `TableBodySegment.tsx` 43행, 60-69행, 87-115행, 117-123행, 126-169행

### 2. 3-column 레이아웃의 부분적 중복

`TableTopRowSection`과 `TableBottomRowSection`은 거의 동일한 구조다. shadow 방향, ref 이름, scroll 핸들러만 다르고 나머지는 복사-붙여넣기 수준이다. 이 두 컴포넌트는 하나로 합칠 수 있다.

단, `TableCenterRowSection`은 구조적으로 상당히 다르다:

| | TopRowSection / BottomRowSection | CenterRowSection |
|---|---|---|
| **center 래퍼** | `<div>` | `<ScrollArea>` + 무한스크롤 + stickyTree 분기 + maxVisibleRows |
| **높이** | 고정 (`rows.length * rowHeight`) | 유동 (`size-full` or `maxVisibleRows`) |
| **ref** | 단일 (`topBodyRef` / `bottomBodyRef`) | 복합 (`bodyRef` + `bodyScrollRef` + `centerBodyRef`) |
| **부가 로직** | 초기 scrollLeft 동기화 | 무한 스크롤 useEffect |
| **isEmpty 스타일** | 없음 | `isEmpty && '[&_[data-slot="scroll-area-viewport"]>div]:h-full'` |
| **maxVisibleRows** | 없음 | 높이 계산 로직 (`combinedRows.length < maxVisibleRows ? ...`) |

left/right 고정 열 래퍼 패턴은 3곳에서 반복되므로 공유할 수 있지만, center 영역까지 하나의 추상화로 묶으면 render prop이나 조건부 로직이 추상화 안으로 이동할 뿐 복잡성이 줄지 않는다.

> 참고: `TableTopRowSection.tsx` 42-79행, `TableCenterRowSection.tsx` 50-127행, `TableBottomRowSection.tsx` 42-79행

### 3. splitRows() 중복 호출 — 데이터 source 분산

`splitRows(table)`이 **4군데**에서 호출된다:

| 위치 | 용도 |
|------|------|
| `TableBodyArea.tsx:13` | top/bottom rows 유무 확인 |
| `TableTopRowSection.tsx:15` | topRows 높이 계산 |
| `TableBottomRowSection.tsx:16` | bottomRows 높이 계산 |
| `TableBodySegment.tsx:39` | 실제 렌더링할 rows 선택 |

`splitRows` 자체는 가벼운 함수이고 TanStack Table의 `getTopRows()`/`getBottomRows()`는 내부적으로 메모이제이션되므로 **성능 문제는 아니다**. 본질은 데이터 source 분산 문제다. 부모가 이미 계산한 결과를 props로 내리지 않고, 자식이 context에서 table을 꺼내 동일한 계산을 독립적으로 수행한다. 정보가 위에서 아래로 흐르지 않고 각 레벨에서 재계산되는 구조다.

**Trade-off 인식:** props로 rows를 전달하면 1-2단계의 props drilling이 발생한다. 하지만 데이터 흐름이 명확해지고, splitRows 로직 변경 시 한 곳만 수정하면 되는 이점이 더 크다.

### 4. 렌더링 전략 결정이 두 레벨에 걸쳐 있음

stickyTree 렌더링 분기가 **두 컴포넌트에 나뉘어** 있다:

- `TableCenterRowSection.tsx:96-110` — stickyTree면 ref/style을 생략
- `TableBodySegment.tsx:117-123` — stickyTree면 `StickyTreeRenderer` 사용

한 가지 결정이 두 파일에 분산되어 있어서, stickyTree 관련 수정 시 항상 두 파일을 함께 봐야 한다.

---

## 개선 방향

### 원칙

> 컴포넌트 이름 = 그 컴포넌트가 렌더링하는 것

`TableBodySegment(columnType="left", rowType="top")`보다, 컴포넌트 트리 자체가 UI 구조를 설명하는 형태를 목표로 한다.

### 역할 분리

#### 1. RowSection 레벨

**`TablePinnedRowSection`** / **`TableScrollableRowSection`**

- 역할: 행 그룹의 컨테이너. 높이, overflow, z-index, shadow 등 행 그룹 수준의 레이아웃만 담당
- `TablePinnedRowSection`은 top/bottom을 `position` prop으로 구분 (레이아웃만 다르므로 통합 가능)
- `TableScrollableRowSection`은 가상화 관련 높이와 무한스크롤 담당
- **rows 데이터를 props로 받아서** 자식에게 전달
- 각 Section이 left/center/right 래퍼를 자체적으로 관리 (Top/Bottom 통합으로 3곳 → 2곳 중복 감소, 추가 추상화 불필요)

#### 2. RowRenderer 레벨

**`PinnedRowRenderer`** / **`VirtualRowRenderer`** (현재 TableBodySegment가 맡는 역할의 핵심)

- 역할: 주어진 rows를 `TableRow` + `TableCell`로 변환하는 순수한 매핑
- `PinnedRowRenderer`: rows를 직접 순회하여 렌더링 (top/bottom 고정 행용)
- `VirtualRowRenderer`: virtualItems를 통해 가상화 렌더링 (center 스크롤 행용). **rows props를 받되, 내부에서 rowVirtualizer context를 통해 virtualItems와 매핑**
- stickyTree는 기존 `StickyTreeRenderer` 유지 (이미 잘 분리되어 있음). **주의: StickyTreeRenderer는 getCells props를 사용하지 않고 table context에서 직접 cells 접근**
- `getCells` 콜백을 props로 받아 열 선택을 외부에 위임: `getCells={(row) => row.getLeftVisibleCells()}`

**getCells 콜백 vs columnType prop 대안 비교:**

| | getCells 콜백 | columnType prop |
|---|---|---|
| **장점** | 열 선택 로직이 RowRenderer 외부에 위치, 더 유연함 | 인터페이스가 단순함, 기존 코드와 유사 |
| **단점** | 인라인 함수 전달 필요 (성능은 무관) | RowRenderer 내부에 switch문 필요, 분기 잔존 |
| **선택 이유** | rowType 분기를 컴포넌트 분리로 해결했으므로, columnType도 동일한 원칙 적용. 단, StickyTreeRenderer와의 인터페이스 불일치 감수 |

### 제안 구조

```
TableBodyArea
  ├─ splitRows() 1회 호출
  │
  ├─ TablePinnedRowSection rows={topRows} position="top"
  │    ├─ left:   PinnedRowRenderer rows={topRows} getCells={getLeftVisibleCells}
  │    ├─ center: PinnedRowRenderer rows={topRows} getCells={getCenterVisibleCells}
  │    └─ right:  PinnedRowRenderer rows={topRows} getCells={getRightVisibleCells}
  │
  ├─ TableScrollableRowSection rows={centerRows}
  │    ├─ left:   VirtualRowRenderer 또는 StickyTreeRenderer
  │    ├─ center: ScrollArea > (VirtualRowRenderer 또는 StickyTreeRenderer)
  │    └─ right:  VirtualRowRenderer 또는 StickyTreeRenderer
  │
  └─ TablePinnedRowSection rows={bottomRows} position="bottom"
       ├─ left:   PinnedRowRenderer rows={bottomRows} getCells={getLeftVisibleCells}
       ├─ center: PinnedRowRenderer rows={bottomRows} getCells={getCenterVisibleCells}
       └─ right:  PinnedRowRenderer rows={bottomRows} getCells={getRightVisibleCells}
```

### 핵심 변경점 요약

| 현재 | 개선 후 |
|------|---------|
| `splitRows()` 4곳에서 호출 | 최상위 1회만 호출, 결과를 props로 전달 |
| Top/Bottom이 별도 컴포넌트 | TablePinnedRowSection으로 통합 (`position` prop) |
| CenterRowSection (위치 기반 이름) | TableScrollableRowSection (동작 기반 이름) |
| left/right 래퍼 3곳 중복 | 2곳으로 감소 (통합에 의한 자연 해소) |
| stickyTree 결정이 2개 컴포넌트에 분산 | TableScrollableRowSection에서 일괄 결정 |
| TableBodySegment가 9가지 경우 분기 | PinnedRowRenderer / VirtualRowRenderer로 역할 분리 |

### 파일 변경 계획

| 파일 | 변경 |
|------|------|
| `TableBodySegment.tsx` | **삭제** |
| `TableTopRowSection.tsx` | **삭제** |
| `TableBottomRowSection.tsx` | **삭제** |
| `TableCenterRowSection.tsx` | **삭제** |
| (신규) `PinnedRowRenderer.tsx` | 고정 행 렌더링. rows 직접 순회, getCells 콜백으로 열 선택 |
| (신규) `VirtualRowRenderer.tsx` | 가상화 행 렌더링. virtualItems → rows 접근, getCells 콜백으로 열 선택 |
| (신규) `TablePinnedRowSection.tsx` | Top/Bottom 통합. `position` prop으로 shadow/ref/scroll handler 분기 |
| (신규) `TableScrollableRowSection.tsx` | CenterRowSection 계승. stickyTree 분기 통합, 빈 상태 처리 포함 |
| `TableBodyArea.tsx` | splitRows 1회 호출, 결과를 각 Section에 props로 전달 |

**변경 순서** (의존성 고려):

1. `PinnedRowRenderer` / `VirtualRowRenderer` 생성
2. `TablePinnedRowSection` 생성 (Top/Bottom 통합)
3. `TableScrollableRowSection` 생성 (CenterRowSection 계승 + stickyTree 통합 + 빈 상태 이동)
4. `TableBodyArea` 수정 (splitRows 1회 + props 전달)
5. 기존 4개 파일 삭제

---

## 채택하지 않은 대안

### 1. ThreeColumnLayout 공통 컴포넌트

left/center/right 3열 래퍼 패턴이 3곳에서 반복되므로 `ThreeColumnLayout` 같은 추상화를 고려할 수 있다.

**채택하지 않은 이유:**
- TablePinnedRowSection과 TableScrollableRowSection의 center 영역이 구조적으로 상당히 다름
  - Pinned: 단순 `<div>`
  - Scrollable: `<ScrollArea>` + 무한스크롤 + stickyTree 분기 + maxVisibleRows 높이 계산
- 공통 컴포넌트로 묶으면 render prop이나 조건부 로직이 추상화 내부로 이동할 뿐, 복잡성이 줄지 않음
- Top/Bottom 통합으로 3곳 → 2곳 중복 자연 감소, 추가 추상화 비용 > 이득

### 2. columnType prop 유지

getCells 콜백 대신 columnType prop을 유지하고 RowRenderer 내부에서 switch문으로 처리하는 방법.

**채택하지 않은 이유:**
- rowType 분기를 컴포넌트 분리(PinnedRowRenderer/VirtualRowRenderer)로 제거했는데, columnType만 분기로 남기면 일관성 없음
- getCells 콜백의 인라인 함수 생성 비용은 무시할 수 있음 (하위 컴포넌트로 전달하지 않음)
- 단, StickyTreeRenderer와의 인터페이스 불일치는 감수해야 함

### 3. Context 패턴 완전 유지 (현재 구조 유지)

splitRows를 각 컴포넌트에서 독립적으로 호출하는 현재 패턴을 유지.

**채택하지 않은 이유:**
- "수정하기 좋은 코드" 관점에서 데이터 흐름 추적이 어려움
- splitRows 로직 변경 시 4곳 동시 검토 필요
- 테스트 시 모든 컴포넌트에서 table context 설정 필요

---

### 주의할 점

#### 렌더링 관련

- **빈 상태 처리**: `TableEmptyRow`는 `VirtualRowRenderer` 내부에서 조건부 렌더링. center 칼럼에서만 표시되므로, `VirtualRowRenderer`가 `columnType="center"`일 때만 isEmpty 체크 후 렌더링. Section 레벨이 아닌 Renderer 레벨에서 처리.
- **isEmpty 스타일링**: `TableScrollableRowSection`에서 `isEmpty && '[&_[data-slot="scroll-area-viewport"]>div]:h-full'` 클래스로 ScrollArea viewport 높이를 확장. 이 로직은 Section 레벨에 유지.
- **cell 가시성**: `table.isCellHidden()` 필터링은 RowRenderer 내부에 유지. cell 가시성은 렌더링 시점의 관심사다.

#### stickyTree 관련

- **stickyTree 적용 범위**: stickyTree 모드에서는 **left/center/right 모든 열**에 `StickyTreeRenderer`가 사용된다. 현재 `TableBodySegment.tsx:117-123`에서 stickyTree 분기는 `columnType`과 무관하게 `rowType === 'center'`이면 발동되며, 이것이 의도된 동작이다. `TableScrollableRowSection`에서 stickyTree 여부를 일괄 결정하고, stickyTree 모드면 left/center/right 세 영역 모두에 `StickyTreeRenderer`를 배치한다.
- **stickyTree의 cells 접근**: `StickyTreeRenderer`는 `table` context에서 직접 cells를 가져오므로, `getCells` props 패턴을 사용하지 않는다. **이로 인해 VirtualRowRenderer와 StickyTreeRenderer의 인터페이스가 다르다.** stickyTree 모드에서는 getCells를 전달할 필요 없이 StickyTreeRenderer만 배치하면 된다.

#### stickyTree + Column Pinning 조합 (잠재적 이슈)

**발견된 문제:** `useStickyTreeCells.ts:27`에서 `row.getCenterVisibleCells()`를 하드코딩하고 있다. 이는 StickyTreeRenderer가 center 열만 렌더링한다는 의미다.

현재 동작 분석:
1. `TableCenterRowSection`의 left/right 영역에서 `TableBodySegment(left/right, center)` 호출
2. `TableBodySegment.tsx:117-123`에서 stickyTree 조건 충족 시 `StickyTreeRenderer` 반환
3. 하지만 `StickyTreeRenderer` 내부에서 `getCenterVisibleCells()`만 사용

**결과:** stickyTree + column pinning 조합 시 left/right 고정 열이 비어 보일 가능성이 있다.

**확인 필요:**
1. 이 조합이 실제로 사용되는 케이스가 있는지 (기존 테스트 케이스 검토)
2. 의도된 제약 사항인지, 버그인지
3. 제약 사항이라면 문서화, 버그라면 리팩토링 시 해결 필요

#### props 및 ref 관련

- **getCells 콜백 참조 안정성**: `getCells={(row) => row.getLeftVisibleCells()}`처럼 인라인 함수를 넘기면 매 렌더마다 새 참조가 생성된다. RowRenderer가 내부적으로만 이 콜백을 사용하고 하위 컴포넌트에 전달하지 않으므로 **useCallback 불필요**. 실질적인 리렌더링 문제 없음.
- **ref 전달 체인**: `centerBodyRef`, `bodyScrollRef` 등의 ref 연결이 깨지지 않도록 주의. 특히 `TableScrollableRowSection`에서 `ScrollArea`에 걸리는 `bodyRef` + `bodyScrollRef` + `centerBodyRef` 3개의 ref가 올바르게 연결되어야 한다.
- **VirtualRowRenderer의 rows 접근**: rows를 props로 받되, 내부에서 `rowVirtualizer.getVirtualItems()`로 virtualItems를 구하고 `rows[virtualItem.index]`로 접근하는 방식. PinnedRowRenderer와 다르게 rows를 직접 순회하지 않음.

#### CenterRowSection 고유 로직

`TableScrollableRowSection`이 유지해야 할 `TableCenterRowSection` 고유 로직:

1. **무한 스크롤 useEffect**: `table.handleInfiniteScroll()` 호출
2. **maxVisibleRows 높이 계산**: `combinedRows.length < maxVisibleRows` 분기
3. **isEmpty 스타일링**: ScrollArea viewport 높이 확장
4. **복합 ref 관리**: `bodyRef`, `bodyScrollRef`, `centerBodyRef` 동시 처리

---

## 검증 결과 요약

### 코드 검증 완료 항목

| 문제점 | 문서 위치 | 코드 검증 |
|--------|----------|---------|
| splitRows 4곳 호출 | 63-75행 | ✅ TableBodyArea(13), TableTopRowSection(15), TableBottomRowSection(16), TableBodySegment(39) |
| TableBodySegment 9가지 분기 | 28-44행 | ✅ rowType(3) × columnType(3) = 9가지 조합 |
| Top/Bottom 중복 | 46-61행 | ✅ 약 80% 코드 동일, shadow/ref/handler만 다름 |
| stickyTree 분기 분산 | 76-83행 | ✅ TableCenterRowSection:96-110 + TableBodySegment:117-123 |
| 빈 상태 처리 center-center만 | 174행 | ✅ TableBodySegment:43에서 `columnType === 'center' && rowType === 'center'` 조건 |

### 제안 방향 검증 결과

| 제안 | 검증 결과 |
|------|-----------|
| PinnedRowRenderer / VirtualRowRenderer 분리 | ✅ 타당. rowType 분기와 columnType 분기 동시 제거 가능 |
| TablePinnedRowSection으로 Top/Bottom 통합 | ✅ 타당. 80% 중복 코드 제거, position prop으로 shadow/ref/handler만 분기 |
| splitRows 1회 호출 후 props 전달 | ✅ 타당. 정보 흐름이 하향식으로 개선, props drilling은 1-2단계로 수용 가능 |
| left/right 래퍼 추가 추상화 불필요 | ✅ 타당. 통합으로 3곳 → 2곳 자연 감소, 과한 추상화 방지 |
| stickyTree 결정을 TableScrollableRowSection에서 일괄 처리 | ✅ 타당. 응집도 향상, 두 파일 동시 수정 불필요 |

### 추가 발견 사항 (문서에 반영됨)

- isEmpty 스타일링 처리 위치 명확화 (Section 레벨)
- maxVisibleRows 계산 로직 위치 명확화 (TableScrollableRowSection)
- VirtualRowRenderer의 rows 접근 방식 명시 (virtualItems → rows 매핑)
- getCells 콜백 안정성 최종 결론 (useCallback 불필요)
- StickyTreeRenderer와 VirtualRowRenderer의 인터페이스 차이 명시

---

## 미해결 질문 (구현 전 확인 필요)

### 1. stickyTree + Column Pinning 조합 지원 여부

- [ ] 기존 테스트 케이스에서 이 조합이 사용되는지 확인
- [ ] 스토리북에서 실제 동작 테스트
- [ ] 지원하지 않는다면: 문서화된 제약 사항으로 처리
- [ ] 지원해야 한다면: StickyTreeRenderer에 getCells 콜백 추가하거나, columnType prop 방식으로 전환

### 2. StickyTreeRenderer 인터페이스 통일

- [ ] VirtualRowRenderer와 동일하게 getCells 콜백을 받도록 수정할지 결정
- [ ] 수정 시 `useStickyTreeCells.ts`, `StickyTreeNode.tsx` 변경 필요
- [ ] 현재 인터페이스 유지 시 두 Renderer의 사용법이 달라지는 문제 감수

### 3. 기존 테스트 호환성

- [ ] 기존 browser 테스트가 새 구조에서 동작하는지 확인
- [ ] 특히 row pinning, column pinning, stickyTree 관련 테스트 집중 검토

### 4. 점진적 마이그레이션 전략

- [ ] 한 번에 모든 파일 교체 vs 단계별 교체 결정
- [ ] 단계별 시: TableBodySegment를 유지하면서 내부만 새 Renderer 호출하는 방식 가능
