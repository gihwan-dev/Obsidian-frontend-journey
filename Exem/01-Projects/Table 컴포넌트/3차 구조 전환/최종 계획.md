# Table Cell 렌더링: Absolute → Flex 전환 리팩토링

## Context

현재 Table 셀은 `position: absolute` + `left: column.getStart()` + `width: column.getSize()`로 렌더링.
모든 셀이 TanStack columnSizing 상태를 구독하고, `column.getStart()`는 앞쪽 모든 컬럼 크기를 합산(O(n)).
**어떤 컬럼 크기가 변경되면 모든 셀이 리렌더링**된다.

### 기대 효과 (기대치 교정 포함)

CSS flex 전환은 **리렌더링 횟수를 줄이지 않는다**. TableCell에 React.memo가 없으므로 부모(TableRow) 리렌더링 시 모든 셀이 리렌더링되며, 이는 CSS가 아닌 React의 동작이다.

실제 개선:
- **셀 당 비용 감소**: `column.getStart()` O(n) 제거 → 300셀 기준 ~6ms 절감/프레임
- **컨테이너 리사이즈**: ResizeObserver + 3-pass 제거 → CSS flex 자동 분배 (22ms → ~0.5ms, 44배)
- **코드 간소화**: 3-pass 알고리즘 ~300줄 + ResizeObserver ~40줄 제거 → ~4KB 번들 절감
- **아키텍처 기반 마련**: 후속 CSS Variables 도입으로 드래그 리사이즈 시 React 우회 가능

> 진정한 리렌더링 횟수 감소를 위해서는 `React.memo` + props 안정화 또는 CSS Variables가 필수.
> 이 리팩토링은 "성능 최적화"가 아닌 **"아키텍처 개선 + 성능 기반 마련"**.

### 이론적 근거 (리서치 기반)

- **Reflow Isolation**: absolute row → 형제 요소 레이아웃에 영향 없음 (O(N) → O(1))
- **Flex 1차원 최적화**: 최신 브라우저에서 1차원 flex 알고리즘은 고도로 최적화
- **Layer Explosion 방지**: absolute는 transform과 달리 레이어 승격 강제 없음 → GPU 메모리 안전
- **Flexbox 단절 대응**: 각 Row가 독립 flex 컨테이너 → 고정폭은 state, auto는 flex-1로 동기화

---

## Phase 0: CellMerging(셀 병합) 제거 [별도 PR]

CellMerging 제거로 flex 전환의 복잡도를 대폭 낮춘다.
그룹 헤더의 `header.colSpan`은 CellMerging과 **완전히 다른 개념**이므로 유지.

### 삭제 대상
- `features/CellMerging.ts` → 제거 또는 no-op Feature로 변환
- `utils/cellMergingUtils.ts` → 제거
- `spec/CellMerging/` (스토리 + 스크린샷 테스트) → 제거

### 수정 대상
| 파일 | 변경 |
|------|------|
| `useCellLayout.ts` | `mergeInfo` 참조 제거, colSpan/rowSpan 분기 제거, `getCellHeight()` 간소화 |
| `TableCell.tsx` | `cellState`에서 `mergeInfo` 제거, `CellContent`의 `isHidden` prop 제거 |
| `useCellAppearance.ts` | mergeInfo 의존성 제거 |
| `layoutUtils.ts` | `getCellPosition`에서 colSpan/rowSpan 파라미터 제거 |
| `rowRendererUtils.ts` | `filterVisibleCells`에서 merge hidden 필터 제거 |

### 주의사항
- `header.colSpan` (그룹 헤더 spanning) **절대 건드리지 않음**
- CellMerging 미사용 시 `DEFAULT_MERGE_INFO` 반환하므로 기능 영향 없음
- 독립적으로 먼저 머지 가능

---

## Phase 1: Cell/Header flex 전환 + 컨테이너 min-width [원자적]

flex 전환과 컨테이너 width 전략은 분리 불가. 한 번에 적용.

### 1a. containerSizes 단일화

**문제**: TableHeaderArea.tsx가 자체적으로 `table.getCenterTotalSize()` 등을 계산하여
Table.tsx의 `calcMinTotal()` 변경 시 헤더-바디 정렬 어긋남.

**파일: `TableHeaderArea.tsx`**
- 자체 containerSizes 계산 제거
- `useTableContainerSize()` 컨텍스트 소비자로 변경
```diff
- const containerSizes = {
-   left: table.getLeftTotalSize(),
-   center: table.getCenterTotalSize(),
-   right: table.getRightTotalSize(),
- };
+ const containerSizes = useTableContainerSize();
```

**파일: `Table.tsx`** (line 275-289)
- containerSizes 계산을 `calcMinTotal()` 기반으로 변경
- **useMemo 사용하지 않음** (IIFE 유지) — TanStack table 참조는 stable이므로 useMemo 의존성으로 부적합

```typescript
const containerSizes = (() => {
  const columnSizing = table.getState().columnSizing;
  const calcMinTotal = (columns: Column<TableRowData<T>, unknown>[]) =>
    columns.reduce((sum, col) => {
      if (columnSizing[col.id] !== undefined) return sum + col.getSize();
      if ((col.columnDef as any).size) return sum + (col.columnDef as any).size;
      return sum + ((col.columnDef as any).minSize ?? 50);
    }, 0);

  if (!isColumnPinningEnabled) {
    return { left: 0, right: 0, center: calcMinTotal(table.getVisibleLeafColumns()) };
  }
  return {
    left: table.getLeftTotalSize(),
    right: table.getRightTotalSize(),
    center: calcMinTotal(table.getCenterVisibleLeafColumns()),
  };
})();
```

**파일: VirtualRowRenderer.tsx**
- `width: totalSize` 제거, `const totalSize = table.getTotalSize()` 제거
```diff
  <TableBody style={{
-   width: totalSize,
    height: rowVirtualizer.getTotalSize() === 0 ? '100%' : rowVirtualizer.getTotalSize(),
    ...style,
  }}>
```

**파일: PinnedRowRenderer.tsx** — 동일하게 `width: totalSize` 제거

**파일: Table.tsx** — `hasAutoColumns` 플래그 추가 (containerSizes 계산 직후)
```typescript
const hasAutoColumns = table.getVisibleLeafColumns().some(
  col => table.getState().columnSizing[col.id] === undefined
    && !(col.columnDef as any).size
);
```

> **컨테이너 width 전략**: auto 컬럼 존재 시 `width: '100%'`로 뷰포트를 채우고,
> `minWidth`로 최소 폭 보장. auto 컬럼 없으면 고정 합산값 사용.

**파일: TableCenterRowSection.tsx** (line 87)
```diff
- style: { width: containerSizes.center, position: 'relative' as const },
+ style: {
+   width: hasAutoColumns ? '100%' : containerSizes.center,
+   minWidth: containerSizes.center,
+   position: 'relative' as const,
+ },
```

**파일: TableHeaderArea.tsx** center header div
```diff
- <div style={{ width: containerSizes.center, height: '100%' }}>
+ <div style={{
+   width: hasAutoColumns ? '100%' : containerSizes.center,
+   minWidth: containerSizes.center,
+   height: '100%',
+ }}>
```

**파일: TablePinnedRowSection.tsx** center div (line 88)
```diff
- style={{ width: containerSizes.center, overflow: 'auto' }}
+ style={{
+   width: hasAutoColumns ? '100%' : containerSizes.center,
+   minWidth: containerSizes.center,
+   overflow: 'auto',
+ }}
```

**파일: TableRemainingSpaceProvider** contentWidth
```typescript
const hasAutoColumns = table.getVisibleLeafColumns().some(
  col => table.getState().columnSizing[col.id] === undefined
);
// auto 컬럼 존재 시 flex가 공간을 채움 → 남은 X 공간 없음
contentWidth={hasAutoColumns ? Infinity : table.getCenterTotalSize()}
```

### 1b. Cell flex 전환

**파일: `useCellLayout.ts`** — 전면 교체

```typescript
export const useCellLayout = <T extends object>(
  cell: Cell<TableRowData<T>, unknown>,
) => {
  const options = useTableOptions();
  const table = cell.getContext().table;

  const getCellHeight = (): string => '100%'; // Phase 0에서 mergeInfo 제거됨

  const getBaseStyle = (): React.CSSProperties => {
    const columnDef = cell.column.columnDef;
    const columnSizing = table.getState().columnSizing;
    const hasExplicitWidth = columnSizing[cell.column.id] !== undefined;
    const style: React.CSSProperties = {};

    if (hasExplicitWidth) {
      style.flex = '0 0 auto';
      style.width = cell.column.getSize();
    } else {
      style.flex = '1 0 0%';
    }

    style.minWidth = (columnDef as any).minSize ?? 0; // flex 기본 min-width: auto 방지
    if ((columnDef as any).maxSize) {
      style.maxWidth = (columnDef as any).maxSize;
    }
    style.height = getCellHeight();

    return style;
  };

  return { getBaseStyle };
};
```

- `position: 'absolute'`, `left`, 기존 `width` 제거
- `getColumnPosition()`, `getCellPosition` import 제거
- `isColumnPinningEnabled` 파라미터 제거 (3-section 구조가 이미 처리)
- `getPinnedColumnOffsetStyle()` 제거 (3-section에서 항상 no-op)
- 반환값에서 `left`, `width`, `mergeInfo` 제거 (mergeInfo는 Phase 0에서 제거됨)

**파일: `TableCell.tsx`**
- `useCellLayout(cell, isColumnPinningEnabled)` → `useCellLayout(cell)`
- `isColumnPinningEnabled` 관련 코드 제거
- `mergeInfo` 관련 코드 제거 (Phase 0에서 선행)

**파일: `layoutUtils.ts`**
- `getCellPosition()` 함수 삭제

### 1c. Header Cell flex 전환

**파일: `BaseTableHeaderCell.tsx`**

`CellPosition` → `HeaderCellLayout` 인터페이스:
```typescript
interface HeaderCellLayout {
  height: number;
  shouldRender: boolean;
}
```

**그룹 헤더 flex 헬퍼 함수** (`layoutUtils.ts`에 추가):

> **핵심 문제**: `header.getSize()`는 auto 컬럼에 대해 JS 계산값(기본 150px)을 반환하지만,
> 브라우저 flex 렌더링은 이와 다른 실제 폭을 배분함 → 그룹 헤더와 리프 컬럼 정렬 불일치.
> 따라서 그룹 헤더는 리프 컬럼 분석 기반의 flex 속성을 사용해야 한다.

```typescript
/** 그룹 헤더의 flex 스타일을 리프 컬럼 분석으로 계산한다. */
export const getGroupHeaderFlexStyle = (
  header: Header<any, unknown>,
  columnSizing: Record<string, number>,
): React.CSSProperties => {
  const leafHeaders = header.getLeafHeaders();
  let fixedBasis = 0;
  let autoCount = 0;

  for (const leaf of leafHeaders) {
    const hasExplicit = columnSizing[leaf.column.id] !== undefined;
    if (hasExplicit) {
      fixedBasis += leaf.column.getSize();
    } else {
      autoCount += 1;
    }
  }

  if (autoCount > 0) {
    // auto 자식이 있으면: flex-grow = auto 개수, flex-basis = 고정 자식 합산
    return { flex: `${autoCount} 0 ${fixedBasis}px` };
  }
  // 모든 자식이 고정폭이면: 고정 합산값
  return { flex: `0 0 ${fixedBasis}px` };
};
```

baseStyle을 flex 기반으로:
```typescript
const baseStyle: React.CSSProperties = (() => {
  const table = header.getContext().table;
  const columnSizing = table.getState().columnSizing;
  const colDef = header.column.columnDef as any;
  const style: React.CSSProperties = {};

  if (header.colSpan > 1) {
    // 그룹 헤더: 리프 컬럼 분석으로 flex 계산
    Object.assign(style, getGroupHeaderFlexStyle(header, columnSizing));
  } else {
    const hasExplicitWidth = columnSizing[header.column.id] !== undefined;
    if (hasExplicitWidth) {
      style.flex = '0 0 auto';
      style.width = header.column.getSize();
    } else {
      style.flex = '1 0 0%';
    }
  }

  style.minWidth = colDef.minSize ?? 0; // flex 기본 min-width: auto 방지
  if (colDef.maxSize) style.maxWidth = colDef.maxSize;
  style.height = cellLayout.height;

  return { ...style, ...additionalStyles };
})();
```

> **그룹 헤더 flex 동기화 원리**: auto 자식 1개 = flex-grow 1. 리프 컬럼도 auto면 flex-grow 1.
> 따라서 그룹 헤더의 flex-grow가 리프 컬럼의 auto 개수와 일치 → 비례 확장이 정확히 동기화.
> 고정 자식의 폭은 flex-basis에 포함되어 리프의 고정 크기와 합산값 일치.

**파일: `layoutUtils.ts`**
- `getHeaderCellPosition()` → `getHeaderCellLayout()`:
```typescript
export const getHeaderCellLayout = <T extends object>(
  header: Header<TableRowData<T>, unknown>,
  headerHeight: number = 40,
) => {
  const rowSpan = tableHeaderRowSpan(header);
  return {
    height: headerHeight * (rowSpan || 1),
    shouldRender: rowSpan !== null,
  };
};
```

**파일: `TableHeader.tsx`**
- 헤더 행에 `display: flex` 추가
- `getHeaderCellPosition` → `getHeaderCellLayout` 호출
- `cellPosition` → `cellLayout` prop 이름 변경
- `<ResizeHandler>` sibling 렌더링 제거 (Phase 2에서 cell 내부로 이동)

**파일: `TableHeaderCell.tsx` + 하위 컴포넌트**
- `cellPosition` → `cellLayout` prop 타입 변경
- `showResizeHandler` prop 추가

### 1d. Row 수정

**파일: `TableRow.tsx`** — `overflow: 'visible'` 추가 (rowSpan 없어도 안전):
```diff
  const base: React.CSSProperties = {
    position: params.stickyTreeMode ? 'relative' : 'absolute',
    left: 0,
    width: '100%',
    height: params.rowHeight,
    display: 'flex',
+   overflow: 'visible',
  };
```

### 1e. StickyTreeRenderer 확인

`StickyTreeNode.tsx`는 `TableRow(stickyTreeMode=true)` + `TableCell` 사용.
stickyTreeMode에서 `position: relative` + `display: flex` → flex 변경이 자동 적용.
별도 수정 불필요하나 시각 확인 필수.

---

## Phase 2: ResizeHandler 재배치

### overflow-hidden 충돌 해결

**문제**: `BaseTableHeaderCell`에 `overflow-hidden` 클래스 존재 (line 71).
ResizeHandler를 cell 내부로 이동 시 `right: -2px` 돌출이 clip됨.

**파일: `BaseTableHeaderCell.tsx`**
- 외곽 div에서 `overflow-hidden` 제거
- 내부 콘텐츠 영역에 `overflow-hidden truncate` 이동

```diff
  return cn(
-   'flex size-full items-center justify-center overflow-hidden truncate px-2 py-0...',
+   'flex size-full items-center justify-center px-2 py-0...',
    ...
  );
```

콘텐츠를 감싸는 내부 div에 `overflow-hidden truncate` 적용:
```tsx
<div className="relative flex size-full items-center justify-center">
  <div className="overflow-hidden truncate">
    {children}
  </div>
  {showResizeHandler && header.column.getCanResize?.() && (
    <ResizeHandler header={header} />
  )}
</div>
```

**파일: `ResizeHandler.tsx`**
- `cellPosition` prop 제거
- `left: cellPosition.left + cellPosition.width - 2` → `right: -2px`
```typescript
style={{
  position: 'absolute',
  right: -2,
  top: 0,
  height: '100%',
  // ... 기존 transform (onEnd 모드) 유지
}}
```

**파일: `TableHeader.tsx`**
- `<ResizeHandler>` sibling 렌더링 제거 (이미 BaseTableHeaderCell 내부로 이동)

---

## Phase 3: handleResizeStart 안전화

### 전체 auto 컬럼 측정 + flushSync

**문제**: auto 컬럼 하나만 고정 전환하면 나머지 auto의 flex 재분배 → 레이아웃 점프.
React 18 batching으로 `setColumnSizing()`과 `resizeHandler()` 사이 상태 불일치 가능.

**파일: `ResizeHandler.tsx`**

```typescript
import { flushSync } from 'react-dom';

const handleResizeStart = (e: React.MouseEvent<HTMLButtonElement>) => {
  // 1. 모든 auto 컬럼의 실제 DOM 너비를 동시 측정
  const currentSizing = table.getState().columnSizing;
  const headerRow = e.currentTarget.closest('[role="row"]');
  if (headerRow) {
    const measuredSizing: Record<string, number> = { ...currentSizing };
    const headerCells = headerRow.querySelectorAll<HTMLElement>('[role="columnheader"]');
    headerCells.forEach(cell => {
      const colId = cell.dataset.columnId;
      if (colId && currentSizing[colId] === undefined) {
        measuredSizing[colId] = cell.getBoundingClientRect().width;
      }
    });

    // 2. flushSync로 동기 반영 (React 18 batching 우회)
    flushSync(() => {
      table.setColumnSizing(measuredSizing);
    });
  }

  // 3. 측정 완료 후 TanStack resize handler 호출
  if (isOnEndMode && refs.tableRef.current) {
    // 기존 guidePosition 계산 로직 유지
    ...
  }
  resizeHandler?.(e);
};
```

> **Layout Thrashing 안전**: `mousedown` 이벤트 핸들러 진입 시점에서의
> `getBoundingClientRect()` 호출은 DOM write 직후가 아니므로 강제 동기 레이아웃이 아님.

### 리사이즈 종료 정책: "한 번 터치 = 영구 고정"

리사이즈 종료 시 auto 복원을 **하지 않는다**. TanStack Table의 표준 UX 패턴을 따른다:

- `handleResizeStart`에서 모든 auto 컬럼의 DOM 너비를 측정하여 `columnSizing`에 등록
- 리사이즈 종료 후에도 측정된 값이 `columnSizing`에 그대로 유지됨
- 즉, 한 번이라도 리사이즈가 발생한 후에는 **모든 컬럼이 고정폭**이 됨
- 이후 컨테이너 리사이즈 시에도 flex 재분배가 아닌 고정폭 유지 (스크롤바 발생 가능)
- 사용자가 원래 auto 동작을 원하면 "컬럼 초기화" 기능으로 `columnSizing`을 비워야 함

> **근거**: AG Grid, TanStack Table 등 주요 테이블 라이브러리 모두 이 패턴 사용.
> auto 복원은 사용자가 의도적으로 설정한 너비가 예기치 않게 변경되는 UX 문제를 유발.

---

## Phase 4: useColumnSizing 간소화 [별도 PR, Phase 1-3 안정화 후]

Phase 1-3만으로 `getStart()` 제거, 컨테이너 리사이즈 성능 개선, 코드 간소화가 달성됨.
Phase 4는 추가적인 번들 절감 + 코드 복잡도 감소.

### 4-1. `useColumnSizing.ts` 재작성
- ResizeObserver effect 전체 삭제
- 3-pass 알고리즘(`calculateColumnSizing()`) 호출 제거
- 명시적 size + externalColumnSizing 컬럼만 등록

### 4-2. `useColumnSizing/utils.ts` 함수 14개 삭제
`partitionColumns`, `calculateFixedColumnsSize`, `buildFixedColumnsSizing`,
`calculateAutoColumnWidth`, `findMinSizeExceedColumns`, `findMaxSizeRestrictedColumns`,
`adjustAutoColumnWidthForMinSize`, `adjustAutoColumnWidthForMaxSize`,
`buildFinalColumnsSizing`, `calculateFlatColumnSizing`, `calculateColumnSizing`,
`calculateHierarchicalColumnSizing`, `calculateGroupColumnSize`, `findChildLeafColumns`

### 4-3. `AutoColumnSizing.ts` feature 간소화
- `table.calculateColumnSizing` 메서드 제거

### ⚠️ Phase 4 전제 조건
- Phase 1-3 머지 후 1-2주 안정화 기간
- **그룹 헤더**: Phase 1c에서 이미 `getGroupHeaderFlexStyle` 헬퍼 도입 완료.
  Phase 4에서 useColumnSizing 제거 후에도 동일 헬퍼가 정상 동작
  (auto 컬럼은 `columnSizing`에 없음 → `autoCount++`, 고정 컬럼은 `getSize()` 정확)

---

## Phase 5 (후속): CSS Variables 도입

- 고정폭 컬럼: `flex: 0 0 var(--col-X-width)`
- 리사이즈 중: `style.setProperty('--col-X-width', newWidth)` → React 렌더 우회
- 리사이즈 종료 시: React state 동기화
- **드래그 리사이즈: ~12ms → ~0.5ms (60fps 안정)**

---

## 수정 파일 요약

### Phase 0 (CellMerging 제거)
| 파일 | 변경 |
|------|------|
| `features/CellMerging.ts` | 제거 |
| `utils/cellMergingUtils.ts` | 제거 |
| `useCellLayout.ts` | mergeInfo 참조 제거 |
| `TableCell.tsx` | mergeInfo, isHidden 제거 |
| `useCellAppearance.ts` | mergeInfo 의존성 제거 |
| `rowRendererUtils.ts` | merge hidden 필터 제거 |
| `spec/CellMerging/` | 제거 |

### Phase 1-3 (flex 전환)
| 파일 | 변경 |
|------|------|
| `useCellLayout.ts` | absolute → flex |
| `BaseTableHeaderCell.tsx` | absolute → flex, overflow-hidden 이동 |
| `layoutUtils.ts` | getCellPosition 삭제, getHeaderCellLayout, getGroupHeaderFlexStyle 추가 |
| `TableHeader.tsx` | flex row, ResizeHandler sibling 제거 |
| `ResizeHandler.tsx` | right:-2, 전체 측정 + flushSync |
| `TableRow.tsx` | overflow: visible |
| `Table.tsx` | containerSizes calcMinTotal, RemainingSpace |
| `TableHeaderArea.tsx` | useTableContainerSize 소비자로 변경, minWidth |
| `TableCenterRowSection.tsx` | minWidth |
| `TablePinnedRowSection.tsx` | center minWidth |
| `VirtualRowRenderer.tsx` | width: totalSize 제거 |
| `PinnedRowRenderer.tsx` | width: totalSize 제거 |
| `TableHeaderCell.tsx` + 하위 | cellLayout, showResizeHandler |
| `TableCell.tsx` | isColumnPinningEnabled 제거 |

---

## 검증 방법

### Phase 0 검증
- `pnpm typecheck` 통과
- `pnpm test` 통과 (CellMerging 테스트 제거 후)
- Storybook에서 기존 Table 스토리 시각 확인 (병합 미사용 테이블)

### Phase 1-3 검증
- [ ] `pnpm typecheck` 통과
- [ ] `pnpm test` 통과
- [ ] `pnpm test:browser` 통과 (리사이즈, 피닝 테스트)
- [ ] Storybook 전 스토리 시각 비교
- [ ] **수동 테스트 체크리스트**:
  - 컬럼 균등 분배 (size 미지정 시)
  - 컬럼 리사이즈 정상 (드래그 시작 시 점프 없음)
  - 컬럼 피닝 (Left + Right) 레이아웃
  - 수평 스크롤 (auto만, 고정만, 혼합)
  - 그룹 헤더 정렬 (리프 컬럼과 수직 정렬)
  - StickyTree 모드 시각 확인
  - 컨테이너 리사이즈 (사이드바 토글)
  - Column Pinning + Resize 조합
  - Column Ordering(DnD) + Resize 조합

### 커밋 전략
- Phase 0: 별도 PR (독립 머지 가능)
- Phase 1-3: 단일 PR, Phase별 커밋 분리 (git revert로 전체 되돌리기 가능)
- Phase 4: 별도 PR (Phase 1-3 안정화 후)

---

## Agent Team 실행 계획

### 의존성 분석

```
Phase 0 (CellMerging 제거) ─── 완료 후 ──→ Phase 1-3 (flex 전환)

Phase 1-3 내부:
  Layer 1 (병렬):
    ├─ [A] containerSizes 단일화 (1a)
    ├─ [B] Cell flex 전환 (1b)
    └─ [C] Header flex 전환 + Row 수정 (1c, 1d)

  Layer 2 (순차, Layer 1 완료 후):
    └─ [D] ResizeHandler 재배치 + 안전화 (Phase 2 + 3)

  Orchestrator (직접 수행):
    └─ layoutUtils.ts 수정 (getCellPosition 삭제, getHeaderCellLayout, getGroupHeaderFlexStyle)
    └─ 전체 통합 검증 (typecheck, test, storybook)
```

### 파일 충돌 분석

| 공유 파일 | 접근 에이전트 | 해결 |
|-----------|--------------|------|
| `layoutUtils.ts` | B(삭제), C(추가) | **Orchestrator 직접 수정** — 삭제+추가 동시 처리 |
| `BaseTableHeaderCell.tsx` | C(flex), D(overflow-hidden) | Layer 분리로 순차 처리 |
| `ResizeHandler.tsx` | D (Phase 2+3 통합) | 단일 에이전트 전담 |
| `TableHeader.tsx` | C(flex row), D(sibling 제거) | Layer 분리로 순차 처리 |

### Phase 0 Team: CellMerging 제거

> 별도 PR. Phase 1-3과 독립 실행 가능.

**Agent α** (general-purpose, model: sonnet)
- `features/CellMerging.ts` 제거
- `utils/cellMergingUtils.ts` 제거
- `spec/CellMerging/` 제거
- 관련 import/export 정리

**Agent β** (typescript-pro, model: sonnet)
- `useCellLayout.ts` — mergeInfo 참조 제거, colSpan/rowSpan 분기 제거
- `TableCell.tsx` — cellState에서 mergeInfo 제거, CellContent의 isHidden prop 제거
- `useCellAppearance.ts` — mergeInfo 의존성 제거
- `rowRendererUtils.ts` — merge hidden 필터 제거

**Orchestrator**: 통합 후 `pnpm typecheck && pnpm test` 검증

### Phase 1-3 Team: Flex 전환

#### Layer 1: 병렬 실행 (3 agents)

**Agent A** — containerSizes 단일화 (frontend-developer, model: sonnet)
```
담당 파일:
  - Table.tsx: containerSizes IIFE → calcMinTotal 기반, hasAutoColumns 플래그
  - TableHeaderArea.tsx: 자체 containerSizes → useTableContainerSize() 소비자
  - TableCenterRowSection.tsx: width → width/minWidth 조합
  - TablePinnedRowSection.tsx: width → width/minWidth 조합
  - VirtualRowRenderer.tsx: width: totalSize 제거
  - PinnedRowRenderer.tsx: width: totalSize 제거
  - TableRemainingSpaceProvider: contentWidth 로직 (hasAutoColumns)
```

**Agent B** — Cell flex 전환 (typescript-pro, model: sonnet)
```
담당 파일:
  - useCellLayout.ts: 전면 교체 (absolute → flex, getBaseStyle 새 구현)
  - TableCell.tsx: isColumnPinningEnabled 제거, useCellLayout(cell) 호출 변경

주의: layoutUtils.ts의 getCellPosition 삭제는 Orchestrator가 수행
```

**Agent C** — Header flex 전환 + Row 수정 (frontend-developer, model: sonnet)
```
담당 파일:
  - BaseTableHeaderCell.tsx: CellPosition → HeaderCellLayout, flex baseStyle
  - TableHeader.tsx: display: flex 추가, getHeaderCellLayout 호출
  - TableHeaderCell.tsx + 하위: cellPosition → cellLayout, showResizeHandler prop
  - TableRow.tsx: overflow: visible 추가

주의: layoutUtils.ts의 getHeaderCellLayout/getGroupHeaderFlexStyle 추가는 Orchestrator가 수행
```

**Orchestrator** — Layer 1 완료 후 직접 수행:
```
  - layoutUtils.ts: getCellPosition() 삭제 + getHeaderCellLayout() 추가 + getGroupHeaderFlexStyle() 추가
  - 3 agents 결과 통합 검증: pnpm typecheck
```

#### Layer 2: 순차 실행 (Layer 1 통합 후)

**Agent D** — ResizeHandler 재배치 + 안전화 (frontend-developer, model: sonnet)
```
담당 파일:
  - BaseTableHeaderCell.tsx: overflow-hidden 내부 div로 이동, ResizeHandler 내부 렌더링
  - ResizeHandler.tsx: cellPosition 제거 → right: -2px, flushSync + 전체 측정 구현
  - TableHeader.tsx: ResizeHandler sibling 렌더링 제거

Phase 2 + Phase 3 통합 (동일 파일 중심이므로 분리 불필요)
```

**Orchestrator** — 최종 검증:
```
  - pnpm typecheck
  - pnpm test
  - pnpm test:browser
  - Storybook 시각 확인 지시
```

### 실행 흐름 요약

```
[Phase 0] ──────────────────────────────────────────────────────
  α (삭제) ─┬─ Orchestrator 통합 → typecheck/test → 별도 PR
  β (수정) ─┘

[Phase 1-3] ────────────────────────────────────────────────────
  Layer 1:
    A (containers) ─┐
    B (cell flex)   ─┼─ Orchestrator: layoutUtils.ts + 통합 → typecheck
    C (header flex) ─┘

  Layer 2:
    D (resize) ──────── Orchestrator: 최종 검증 → 단일 PR
```

### 에이전트 프롬프트 전략

각 에이전트에게 제공할 컨텍스트:
1. **플랜 파일 전체** 읽기 지시 (아키텍처 이해)
2. **담당 파일 목록** + 변경 사항 명세
3. **건드리지 말 파일** 명시 (layoutUtils.ts 등 Orchestrator 전담)
4. **flex 공통 규칙**: `minWidth: columnDef.minSize ?? 0`, auto → `flex: 1 0 0%`, 고정 → `flex: 0 0 auto` + `width`
5. **검증 기준**: `pnpm typecheck` 통과 필수

---

## 의문점

1. flushSync 써야하나? tanstack-table 내부 동작이 setState 기반으로 알고 있는데?
2. 