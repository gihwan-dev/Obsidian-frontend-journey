## TL;DR

Column Grouping의 헤더 렌더링 문제는 **CSS 페인팅 순서**(z-index 미설정으로 Row 1이 Row 0의 overflow를 가림)가 즉각적 원인이고, **행 기반 flat 렌더링으로 2차원 문제를 1차원 flex에 우겨넣은 것**이 구조적 원인이다. 즉각 수정으로 z-index 패치를 적용한 후, **중첩 Flex(Column-Tree Rendering)** 으로 전환하여 rowSpan 개념 자체를 제거하고, minSize 차이로 인한 body-header 정렬 불일치는 측정 기반 보정으로 보완하는 3단계 전략을 권장한다.

---

## 상세 답변

### 1. 문제 진단: 무엇이 실제로 깨져 있는가

4개의 독립 분석 경로와 실제 소스 코드(`layoutUtils.ts`, `TableHeader.tsx`, `BaseTableHeaderCell.tsx`, `useHeaderCellStyle.ts`, `ResizeHandler.tsx`) 교차 검증을 통해 다음을 확인했다.

#### 높이 버그 (40px로 보이는 문제)

`getHeaderCellLayout`은 rowSpan=2, height=80px를 **올바르게** 계산한다. TanStack Table이 2-level 그룹에서 비그룹 컬럼의 depth-0 헤더를 `isPlaceholder=true`로 생성하고, `deepestHeader` 함수가 이 placeholder 체인을 따라가 depth-1의 leaf를 찾아 rowSpan을 정확히 계산한다. `useHeaderCellStyle`도 `style.height = 80`을 올바르게 설정한다.

**실제 원인은 CSS 페인팅 순서**이다. `TableHeader.tsx`에서 각 headerGroup마다 생성되는 `<div role="row" style={{ height: 40, display: 'flex' }}>` 컨테이너들이 순차적으로 배치된다. Row 0의 80px 셀이 40px flex container를 overflow하지만, Row 1의 flex container가 DOM 순서상 나중에 위치하므로 Row 0의 overflow 영역 위에 페인팅된다. z-index가 설정되지 않았고 모든 요소가 같은 stacking context에 있으므로, 이것은 CSS 스펙의 정상 동작이다.

#### 너비 버그 (80px -> 200px)

코드 분석 결과, `basicGroupColumns`의 "상태" 컬럼(`size: 80`)에서는 `isFixedWidthColumn`이 `true`를 반환하고 `flex: '0 0 auto', width: 80`이 설정되어 80px로 렌더링되어야 한다. 200px이 관찰되었다면 **분석에 사용된 스크린샷이 `sortableGroupColumns`의 연봉 컬럼(size 미지정) 기준**일 가능성이 높다. 이 컬럼은 `flex: '1 0 0%'`로 설정되어 사용 가능 공간에 비례해 확장된다.

만약 `size: 80` 컬럼에서 실제로 200px이 렌더링된다면, 런타임에서 `header.column.getSize()` 반환값을 확인해야 한다. TanStack Table 내부 캐시 또는 columnSizing 상태가 의도치 않게 변경된 경우일 수 있다.

#### 리사이즈 오프셋 불일치

`ResizeHandler.tsx`의 `measureAndFixAutoColumns`가 `headerRow.querySelectorAll('[role="columnheader"]')`로 현재 행의 모든 columnheader를 측정한다. 그룹 행(Row 0)에서 리사이즈가 시작되면 그룹 헤더("개인정보", "업무정보")의 너비도 `columnSizing`에 등록되어, 이후 해당 그룹 ID가 `isFixedWidthColumn`에서 `true`를 반환하게 되는 부작용이 있다. 다만, 현재 설계에서 그룹 컬럼에는 리사이즈 핸들이 표시되지 않을 가능성이 높으므로 직접적 문제 발생 빈도는 낮다.

### 2. 구조적 원인: 왜 이 문제가 계속 반복되는가

현재 `TableHeader`는 TanStack Table의 `getHeaderGroups()`가 반환하는 **행 기반 flat 배열**을 그대로 DOM에 매핑한다:

```
Row 0 (flex container): [ID placeholder] [개인정보] [업무정보] [상태 placeholder]
Row 1 (flex container): [ID spacer]      [이름]     [이메일]    [부서] [직급] [상태 spacer]
```

이 구조에는 근본적인 한계가 있다:

1. **차원 불일치**: 그룹 헤더는 본질적으로 2차원 격자(grid) 배치 문제이다. 각 셀이 다양한 rowSpan/colSpan을 가진 직사각형 블록이며, 이것을 빈틈 없이 배치해야 한다. 그러나 CSS flex는 1차원 레이아웃 모델이다. 두 개의 독립 flex container 사이에서 아이템 경계를 동기화하려면 동일한 flex 규칙을 모든 행에 적용해야 하는데, 행마다 아이템 수와 구성이 다르므로 이것은 원리적으로 불완전하다.

2. **minSize 카스케이드 문제**: `computeGroupFlex`의 수학은 minSize가 바인딩되지 않을 때 올바르다. 그러나 컨테이너가 충분히 넓지 않아 minSize 제약이 활성화되면, 행별 독립 flex 배분이 서로 다른 결과를 만든다. 이것은 CSS flex 모델의 구조적 한계이며 코드 수정으로 해결할 수 없다.

3. **rowSpan 시뮬레이션의 취약성**: flex에는 rowSpan 개념이 없으므로, overflow + z-index로 시각적으로 흉내 낸다. 이것은 깊이가 증가할수록 복잡해지고, 이벤트 전파/접근성/브라우저 호환성 측면에서 취약하다.

### 3. 권장 접근: 3단계 전략

#### Stage 1: 즉각 패치 (현재 구조 유지, 시각적 버그 수정)

**목적**: 프로덕션에서 당장 보이는 높이/z-index 문제를 수정한다.

**변경 파일 및 내용**:

**(1) `layoutUtils.ts`** - `getHeaderCellLayout` 반환값에 `rowSpan` 추가:

```typescript
export const getHeaderCellLayout = <T extends object>(
  header: Header<TableRowData<T>, unknown>,
  headerHeight: number = 40,
) => {
  const rowSpan = tableHeaderRowSpan(header);
  return {
    height: headerHeight * (rowSpan || 1),
    rowSpan: rowSpan || 1,           // 추가
    shouldRender: rowSpan !== null,
  };
};
```

**(2) `BaseTableHeaderCell.tsx`** - rowSpan > 1 셀에 z-index 적용:

```typescript
const isMultiRowCell = cellLayout.rowSpan > 1;
const finalStyle: React.CSSProperties = isMultiRowCell
  ? { ...baseStyle, position: 'relative', zIndex: 10 }
  : baseStyle;
```

그리고 `data-rowspan` 하드코딩 교체:

```typescript
// Before: data-rowspan={headerGroup.depth === 0 && !columnDef.columns ? 2 : 1}
// After:
data-rowspan={cellLayout.rowSpan > 1 ? cellLayout.rowSpan : undefined}
```

**(3) `TableHeader.tsx`** - Row flex container에 overflow:visible 명시:

```typescript
<div
  key={headerGroup.id}
  role="row"
  style={{ height: headerRowHeight, display: 'flex', overflow: 'visible' }}
  // ...
>
```

**(4) `ResizeHandler.tsx`** - 그룹 컬럼 측정 제외:

```typescript
headerCells.forEach((cell) => {
  const colId = cell.dataset.columnId;
  const isGroupHeader = !!cell.dataset.colspan;
  if (colId && currentSizing[colId] === undefined && !isGroupHeader) {
    measuredSizing[colId] = cell.getBoundingClientRect().width;
    hasNewMeasurements = true;
  }
});
```

#### Stage 2: 중첩 Flex 전환 (구조적 해결)

**목적**: rowSpan 시뮬레이션을 제거하고, 컬럼 트리 구조를 DOM에 직접 매핑한다.

**핵심 아이디어**: TanStack의 `headerGroups`를 행별로 순회하지 않고, `headerGroups[0].headers`를 루트로 하여 `header.subHeaders`를 재귀적으로 순회한다. 그룹 노드는 `flex-direction: column` 컨테이너가 되어 라벨 영역과 자식 영역을 수직으로 배치한다. 비그룹 노드(leaf)는 `height: 100%`로 전체 헤더 높이를 차지한다.

**구현 구조**:

```
TableHeader (변경)
└── 단일 flex container (display: flex, height: totalDepth * headerRowHeight)
    ├── ColumnTreeNode (leaf: ID) → height: 100%, flex: 0 0 60px
    ├── ColumnTreeNode (group: 개인정보) → flex-direction: column
    │   ├── GroupLabel → height: 40px, "개인정보"
    │   └── ChildrenRow → display: flex
    │       ├── ColumnTreeNode (leaf: 이름) → flex: 1 0 0%
    │       └── ColumnTreeNode (leaf: 이메일) → flex: 1 0 0%
    ├── ColumnTreeNode (group: 업무정보) → flex-direction: column
    │   ├── GroupLabel → height: 40px
    │   └── ChildrenRow → display: flex
    │       ├── ColumnTreeNode (leaf: 부서)
    │       └── ColumnTreeNode (leaf: 직급)
    └── ColumnTreeNode (leaf: 상태) → height: 100%, flex: 0 0 80px
```

**수학적 정확성**: minSize가 바인딩되지 않는 조건에서, 중첩 flex의 leaf 너비와 body(flat flex)의 leaf 너비가 일치함이 증명되어 있다. 그룹의 `flex-grow = autoChildCount`, 각 자식의 `flex-grow = 1`이므로, 비례 분배에 의해 각 leaf가 전체에서 `1/totalAutoCount`의 비율을 가진다.

**제거되는 코드**: `isNonGroupedPlaceholder` 분기 전체, `deepestHeader` 함수, `tableHeaderRowSpan` 함수, invisible spacer 생성 로직, z-index 해킹(Stage 1의 패치).

**주의사항**:
- 기존 `TableHeaderCell`, `DraggableTableHeaderCell`, `StaticTableHeaderCell`은 leaf 노드에서 재사용한다.
- `ColumnGrouping.browser.test.tsx`가 `[role="row"]` 선택자에 의존하면 수정이 필요하다.
- border 이중 적용을 방지하기 위해, 그룹 컨테이너에는 border를 두지 않고 leaf와 GroupLabel에만 border를 적용하는 전략이 필요하다.

#### Stage 3: Body-Header 측정 기반 동기화

**목적**: minSize 차이에 의한 body-header 정렬 불일치를 보정한다.

**발생 조건**: 같은 그룹 내에 서로 다른 minSize를 가진 auto 컬럼이 있고, 컨테이너가 충분히 좁아 minSize가 바인딩될 때.

**구현**:

```typescript
// useHeaderBodySync 커스텀 훅
const useHeaderBodySync = (headerAreaRef, bodyAreaRef) => {
  const [corrections, setCorrections] = useState<Record<string, number>>({});

  useLayoutEffect(() => {
    if (!headerAreaRef.current || !bodyAreaRef.current) return;

    const headerLeaves = headerAreaRef.current.querySelectorAll(
      '[role="columnheader"]:not([data-colspan])'
    );
    const bodyFirstRow = bodyAreaRef.current.querySelector('[role="row"]');
    if (!bodyFirstRow) return;

    const bodyCells = bodyFirstRow.querySelectorAll('[role="gridcell"], [role="cell"]');
    const newCorrections: Record<string, number> = {};
    let needsCorrection = false;

    headerLeaves.forEach((headerCell, i) => {
      const bodyCell = bodyCells[i];
      if (!bodyCell) return;

      const headerWidth = headerCell.getBoundingClientRect().width;
      const bodyWidth = bodyCell.getBoundingClientRect().width;
      const diff = Math.abs(headerWidth - bodyWidth);

      if (diff > 1) { // 1px 이상 차이 시 보정
        const colId = headerCell.dataset.columnId;
        if (colId) {
          newCorrections[colId] = bodyWidth;
          needsCorrection = true;
        }
      }
    });

    if (needsCorrection) {
      setCorrections(newCorrections);
    }
  }, [/* leaf column deps */]);

  return corrections;
};
```

이 보정값은 ColumnTreeNode의 leaf 렌더링 시 `width` 스타일로 주입된다. 보정은 초기 렌더 후 1회만 수행되며, 리사이즈 시에는 `measureAndFixAutoColumns`가 모든 auto 컬럼을 고정 너비로 전환하므로 추가 보정이 불필요하다.

### 4. 왜 이 접근인가: 대안 비교

| 접근                       | 장점                         | 단점                             | 판정           |
| ------------------------ | -------------------------- | ------------------------------ | ------------ |
| **현재 구조 + z-index**      | 변경 최소                      | rowSpan 해킹 유지, 3+ level 취약     | Stage 1 (임시) |
| **CSS Grid (헤더만)**       | 네이티브 row/col span          | body flex와 정렬 동기화 어려움          | 기각           |
| **HTML table (헤더만)**     | 브라우저 네이티브                  | body flex와 레이아웃 엔진 불일치         | 기각           |
| **CSS Grid + Subgrid**   | 이론적 최선                     | 전체 아키텍처 변경, virtual scroll 비호환 | 미래 옵션        |
| **Absolute positioning** | 정확한 배치                     | 순환 의존성, 2-pass 렌더링, DnD 비호환    | 기각           |
| **중첩 Flex**              | rowSpan 제거, 구조적 해결, 재귀적 확장 | minSize 불일치(보정 필요), 마이그레이션 비용  | **권장**       |
| **측정 기반 동기화**            | 정밀도 최고                     | 2-pass 렌더링 가능성, 성능 비용          | Stage 3 (보완) |

중첩 Flex를 권장하는 핵심 이유:
1. **문제를 구조적으로 해결**: rowSpan이라는 해결 불가능한 문제를 제거한다.
2. **코드 복잡도 감소**: `isNonGroupedPlaceholder`, `deepestHeader`, `tableHeaderRowSpan` 등 복잡한 로직이 불필요해진다.
3. **자연스러운 확장**: 3-level, 4-level 그룹이 재귀적으로 동작한다.
4. **TanStack API 호환**: `header.subHeaders` 트리 구조가 이미 존재하며, 이를 활용하는 것은 API의 의도된 사용법이다.
5. **성숙한 라이브러리의 교훈**: AG Grid, MUI DataGrid, Ant Design 등 모든 성숙한 테이블 라이브러리는 flex만으로 multi-row 헤더를 구현하지 않는다. 중첩 flex는 현재 아키텍처(row absolute + flex cell)를 최소한으로 변경하면서 이 원칙을 따르는 방법이다.

### 5. 구현 로드맵

```
Phase A: Stage 1 즉각 패치 (1-2일)
├── layoutUtils.ts: rowSpan 필드 추가
├── BaseTableHeaderCell.tsx: z-index 적용, data-rowspan 수정
├── TableHeader.tsx: overflow:visible
├── ResizeHandler.tsx: 그룹 컬럼 측정 제외
└── 기존 테스트 실행 + 수동 검증

Phase B: Stage 2 중첩 Flex 구현 (3-5일)
├── ColumnTreeNode 컴포넌트 신규 생성
├── TableHeader 내부 렌더링 로직 변경
│   ├── groups.map → groups[0].headers 트리 순회
│   ├── isNonGroupedPlaceholder 로직 제거
│   └── getHeaderCellLayout/deepestHeader/tableHeaderRowSpan 제거
├── BaseTableHeaderCell 재활용 (leaf에서)
├── ResizeHandler 범위 변경 (rowgroup 기반)
├── Border 전략 설계 및 적용
├── ColumnGrouping.browser.test.tsx 수정
└── 2-level, 3-level, Mixed Structure 스토리 검증

Phase C: Stage 3 동기화 보정 (2-3일)
├── useHeaderBodySync 훅 구현
├── ColumnTreeNode에 보정값 주입
├── 다양한 minSize 조합 테스트
└── 성능 프로파일링 (50+ 컬럼)
```

---

## 사고 과정 요약

1. **4개 분석 경로**를 독립적으로 수행: 기초 원리(수학적 증명), 현실주의(코드 추적), 적대적(실패 모드 분류), 혁신(패러다임 전환).
2. **실제 소스 코드와 교차 검증**하여 각 경로의 주장을 확인/반증:
   - First Principles의 `deepestHeader` 버그 주장 반증 (TanStack placeholder 메커니즘 확인)
   - Pragmatist의 CSS 페인팅 순서 진단 확인 (코드 경로 추적)
   - Adversarial의 minSize 불일치 수학적 검증 확인
   - Innovator의 중첩 flex에 대한 **새로운 반례 발견** (minSize 바인딩 시 body와 불일치)
3. **가중 조합**: Pragmatist의 즉각 수정 + Innovator의 구조적 해결 + Adversarial의 경고를 반영한 보정 메커니즘.
4. **3단계 전략**: 즉각 패치(리스크 최소) → 중첩 Flex(구조적 해결) → 측정 보정(미세 조정).

---

## 신뢰도: 7/10

### 7점의 근거

**높은 확신 (8-9)**:
- 높이 버그의 근본 원인(CSS 페인팅 순서)은 코드 레벨에서 검증 완료
- 중첩 flex의 수학적 정확성(minSize 미바인딩 시)은 증명 완료
- Stage 1 즉각 패치는 CSS 스펙 기반으로 동작 확실

**중간 확신 (6-7)**:
- 중첩 flex 전환의 실전 적용(border, DnD, 접근성 등 세부 사항)은 구현 과정에서 조정 필요
- 측정 기반 보정의 성능/깜빡임은 실제 테스트 필요

**낮은 확신 (4-5)**:
- Pinning + Grouping의 그룹 분할 엣지 케이스
- 50+ 컬럼 대규모 테이블에서의 성능

### 10점이 아닌 이유

어떤 테이블 라이브러리에서도 column grouping은 가장 복잡한 기능 중 하나이다. AG Grid 같은 20년 역사의 라이브러리도 그룹 헤더 관련 이슈가 지속적으로 보고된다. 이론적 분석과 실전 적용 사이에는 항상 간극이 있으며, 특히 다양한 브라우저, 다양한 컬럼 구성, 다양한 인터랙션(resize + DnD + pinning + sorting)의 조합에서 예상치 못한 엣지 케이스가 발생할 수 있다.

---

## 반대 의견 (Dissenting Views)

### 반대 1: "즉각 패치(z-index)만으로 충분하다" (Pragmatist 관점)

z-index 패치가 2-level 기본 시나리오를 수정하므로, 당장은 이것만으로 충분할 수 있다. 중첩 flex 전환은 큰 변경이며 회귀 위험이 있다. "동작하는 코드를 건드리지 말라"는 원칙에 따라, 더 많은 사용자 피드백을 수집한 후 아키텍처 변경을 결정해도 늦지 않다.

**반박**: z-index 해킹은 3-level 이상에서 추가 복잡성을 만들고, 이벤트 전파/접근성 문제를 내포한다. "6개월~1년 수명"의 임시 조치를 쌓아가면 기술 부채가 복리로 증가한다.

### 반대 2: "측정 기반 동기화 없이도 된다" (Innovator 관점)

minSize 차이에 의한 정렬 불일치는 대부분의 실제 사용 시나리오에서 발생하지 않거나 무시 가능한 수준(서브픽셀)이다. 컨테이너가 충분히 넓으면 minSize가 바인딩되지 않으며, 좁은 컨테이너에서는 어차피 수평 스크롤이 활성화된다.

**반박**: 검증에서 20px 차이가 발생하는 시나리오를 확인했다. 이것은 서브픽셀이 아니라 **육안으로 보이는** 오차이다. minSize가 다양한 실제 테이블에서 "컨테이너가 충분히 넓은" 조건이 항상 보장되지 않는다.

### 반대 3: "CSS Grid로 전체 전환이 더 낫다" (장기 관점)

CSS Subgrid가 안정화되면 테이블 전체(헤더 + body)를 CSS Grid로 전환하는 것이 궁극적 해결책이다. 중첩 flex는 과도기적 해결이며, 결국 또 다른 마이그레이션이 필요하다.

**반박**: CSS Subgrid의 cross-browser 안정성이 충분하지 않고, virtual scroll과의 통합이 검증되지 않았다. 또한 전체 아키텍처 변경은 현재 프로젝트 범위를 크게 초과한다. 중첩 flex는 "현재 시점에서 가장 실용적인 2차원 해결"이며, 향후 Grid 전환 시에도 컬럼 트리 기반 렌더링 패러다임은 재사용 가능하다.
