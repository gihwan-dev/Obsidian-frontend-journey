{
	"nodes":[
		{"id":"e1eb872562c4d721","type":"link","url":"https://tanstack.com/table/v8/docs/guide/custom-features","x":-600,"y":-480,"width":1060,"height":1000},
		{"id":"1ab7291fbf20af03","type":"text","text":"## 커스텀 피쳐 기반 리팩토링\n\n**목표**\n@packages/react/src/table/ 컴포넌트를 리팩토링 하려고해. Tanstack Table의 커스텀 기능을 사용해서 모든 기능을 헤드리스 하게 동작할 수 있게 해서 프레임워크와 무관하게 동작하게 하는것을 목표로 함.\n\n- 기능 하나씩 마이그레이션 진행\n- 우선 적으로 가이드라인 문서를 하나 만들어 놓고 진행하기\n- 테스트 깨져서는 안됨\n- 기능 단위 분리 우선 정리\n\t- cell bordering 기능\n\t- row 이동 기능\n\t- \bsticky tree 기능\n\t- etc...\n","x":500,"y":-480,"width":760,"height":1000},
		{"id":"4305b2d51eabb4ed","x":-1680,"y":-1600,"width":840,"height":1030,"type":"text","text":"# Table 커스텀 기능 리스트업  \n  \nTanStack Table Custom Feature 마이그레이션 관점에서 Table 컴포넌트의 모든 기능을 정리한 문서.  \n  \n- **1부**: Headless 커스텀 기능 — 프레임워크 무관 상태/로직 (TanStack Custom Feature 후보)  \n- **2부**: React 렌더링 어댑터 — DOM/React 종속 렌더링/UI 기능  \n- **3부**: 공통 패턴 — Controlled/Uncontrolled 통합  \n  \n---  \n  \n## 1부: Headless 커스텀 기능  \n  \n프레임워크에 무관하게 동작하는 순수 상태/로직 기능 — TanStack Table Custom Feature로 구현할 대상.  \n  \n| #   | 기능명               | 설명                                   |\n| --- | ----------------- | ------------------------------------ |\n| 1   | CellMerging       | rowSpan/colSpan 셀 병합 계산, 숨김 셀 추적     |\n| 2   | TreeSelection     | 트리 리프 전용 선택, 부모 토글, indeterminate 상태 |\n| 3   | PinAwareSorting   | 고정 행 위치 보존하는 커스텀 정렬 모델               |\n| 4   | FilterAwareExpand | 검색 시 모든 트리 행 자동 확장                   |\n| 5   | GlobalSearch      | 다중 검색어, 숫자 인식, 재귀 하위 행 검색            |\n| 6   | AutoColumnSizing  | 3-pass 자동 컬럼 너비 분배 알고리즘              |\n| 7   | RowOrdering       | 행 순서 변경 (버튼 swap + DnD move 통합)      |\n| 8   | ColumnDnd         | 컬럼 순서 드래그 앤 드롭                       |\n| 9   | RowClick          | 행 클릭 선택/토글, clickedRowId 상태          |\n| 10  | RowDrag           | 커스텀 행 드래그 (외부 콜백 전용)                 |\n| 11  | InfiniteScroll    | threshold 기반 무한 스크롤                  |\n| 12  | CellFormatting    | 자동 정렬, 숫자 포맷, ratio 데이터              |\n| 13  | InlineUtilities   | 인라인 expander/checkbox 결정 로직          |\n| 14  | PinningStyle      | 고정 행/열 오프셋 계산                        |\n  \n---  \n  \n### 1. CellMerging  \n  \nrowSpan/colSpan 셀 병합을 계산하고, 병합으로 숨겨진 셀을 추적한다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `hiddenCellsSet` | `Set<string>` | 병합으로 숨겨진 셀 (`\"rowId:columnId\"` 형식) |  \n| `rowSpanMap` | `Map` | 셀별 계산된 rowSpan 값 |  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| table | `getMergeInfo(rowId, columnId)` | `{rowSpan, colSpan, isHidden, isLastRowSpan}` 반환 |  \n| table | `isCellHidden(rowId, columnId)` | 셀 숨김 여부 판별 |  \n| cell | `calculateRowSpan()` | 표시 가능 행을 고려한 실제 rowSpan 계산 |  \n| cell | `calculateColSpanForCell()` | 셀의 colSpan 값 조회 |  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/hooks/useTableMerge.ts`  \n- `packages/react/src/table/utils/tableMergeUtils.ts`  \n- `packages/react/src/table/providers/TableHiddenCellProvider.tsx`  \n- `packages/react/src/table/components/TableCell/useCellLayout.ts`  \n  \n---  \n  \n### 2. TreeSelection  \n  \n트리 구조에서 리프 노드만 선택 상태에 포함하고, 부모 토글 시 하위 리프를 일괄 선택/해제한다. 부모의 indeterminate 상태를 파생한다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `rowSelection` | `RowSelectionState` | TanStack 기본 타입, 리프 행 ID → boolean |  \n  \n> 부모 노드는 selection state에 포함되지 않으며, indeterminate는 렌더링 시 리프 선택으로부터 파생된다.  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| row | `collectLeafRows(row)` | 부모 행에서 모든 리프 Row 객체를 재귀 수집 |  \n| table | `collectAllLeafRowsFromFlatList(flatRows)` | 평탄화된 배열에서 리프 행 수집 |  \n| table | `calculateNextTreeSelectionState(toggledRow, currentSelection)` | 부모 토글 시 새 selection 상태 계산 |  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/core/treeSelection.ts`  \n- `packages/react/src/table/core/__test__/treeSelection.test.ts`  \n- `packages/react/src/table/core/__test__/collectLeafRows.test.ts`  \n  \n---  \n  \n### 3. PinAwareSorting  \n  \n고정(pinned) 행의 위치를 보존하면서 비고정 행만 정렬하는 커스텀 정렬 모델.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `sorting` | `SortingState` | TanStack 기본 정렬 상태 |  \n  \n> 행을 `pinnedTopRows`, `unpinnedRows`, `pinnedBottomRows`로 분리한 뒤 비고정 행만 정렬하고 재조합한다.  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| table | `getSortedRowModel()` | pin 상태를 보존하는 커스텀 정렬 row model |  \n  \n> 내부 로직: pin 상태로 분리 → 비고정 행 정렬 → 재조합. 중첩 subRows도 재귀적으로 동일 로직 적용.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/utils/getSortedRowModel.ts`  \n  \n---  \n  \n### 4. FilterAwareExpand  \n  \n글로벌 검색이 활성화되면 모든 트리 행을 자동 확장하여 검색 결과가 보이도록 한다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `expanded` | `ExpandedState` | TanStack 기본 확장 상태 |  \n| `globalFilter` | `string` | 검색 키워드 (트리거 조건) |  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| table | `getExpandedRowModel()` | 커스텀 확장 row model |  \n| table | `expandRows(rowModel, forceExpanded)` | `forceExpanded=true`(globalFilter 활성) 시 전체 행 확장 |  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/utils/getExpandedRowModel.ts`  \n  \n---  \n  \n### 5. GlobalSearch  \n  \n공백으로 분리된 다중 검색어를 지원하고, 숫자 패턴을 인식하며, 트리 하위 행을 재귀 검색한다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `globalFilter` | `string` | 검색 키워드 |  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| table | `globalFilterFn(row, columnId, filterValue)` | TanStack filterFn 시그니처 준수 |  \n| util | `splitSearchTerms(searchWord)` | 공백 분리 + 소문자 변환 |  \n| util | `matchesSearchTerm(value, searchTerm)` | 문자열/숫자 매칭 (콤마 정규화 포함) |  \n| util | `isNumericSearchPattern(term)` | 숫자 패턴 감지 |  \n| util | `normalizeNumber(value)` | 숫자에서 콤마 제거 |  \n| util | `searchInSubRows(row, terms)` | 재귀 하위 행 검색 |  \n  \n> 고정(pinned) 행은 필터링에서 제외된다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/utils/globalFilterFn.ts`  \n- `packages/react/src/table/utils/searchHelpers.ts`  \n  \n---  \n  \n### 6. AutoColumnSizing  \n  \n3-pass 알고리즘으로 컬럼 너비를 자동 분배한다. 컨테이너 크기 변경 시 ResizeObserver로 재계산한다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `columnSizing` | `Record<string, number>` | 컬럼별 너비 |  \n  \n> 컬럼을 explicit(명시적 크기), external(고정 크기), auto(유연) 세 그룹으로 분류한다.  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| table | `calculateColumnSizing()` | 3-pass: (1) explicit 크기 할당 → (2) external 크기 할당 → (3) 남은 공간을 auto 컬럼에 분배 |  \n| util | `filterValidColumns()` | 유효 컬럼 필터링 |  \n| util | `filterVisibleColumns()` | 표시 가능 컬럼 필터링 |  \n| util | `partitionColumns()` | fixed vs auto 컬럼 분리 |  \n| util | `hasAutoColumns()` | resize 시 재계산 필요 여부 판별 |  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/hooks/useColumnSizing/useColumnSizing.ts`  \n- `packages/react/src/table/hooks/useColumnSizing/utils.ts`  \n  \n---  \n  \n### 7. RowOrdering  \n  \n버튼 기반 swap과 DnD 기반 move를 하나의 기능으로 통합한다. 동일한 `rowOrder` 상태와 `rowReorderUtils` 유틸리티를 공유한다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `rowOrder` | `{ root: string[], [parentId]: string[] }` | 계층적 행 순서 (트리 지원) |  \n| `initialRowOrder` | 동일 타입 | 비제어 모드 초기값 |  \n  \n> 필터링 활성 시 순서 변경이 차단된다. 정렬 상태는 순서 변경 후 자동 초기화된다.  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| row | `canMoveUp` / `canMoveDown` | 이동 가능 여부 |  \n| row | `handleMoveUp()` / `handleMoveDown()` | 버튼 swap 실행 |  \n| table | `onRowOrderChange(newOrder)` | 제어 모드 콜백 |  \n| util | `swapArrayElements(arr, i, j)` | 인접 요소 교환 |  \n| util | `arrayMove(arr, from, to)` | 요소 이동 |  \n| util | `updateParentSubRows(data, parentId, newOrder)` | 트리 구조 subRows 갱신 |  \n| util | `reconstructDataWithPinning(data, order, pinning)` | pin 그룹을 유지하며 데이터 재구성 |  \n| util | `getSiblingRows(row, table)` | 이동 가능한 형제 행 조회 |  \n| util | `resetSortingIfNeeded(table)` | 순서 변경 후 정렬 초기화 |  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/hooks/useTableRowOrdering.ts`  \n- `packages/react/src/table/hooks/useTableRowDndMonitor.ts`  \n- `packages/react/src/table/utils/rowReorderUtils.ts`  \n- `packages/react/src/table/utils/applyInitialRowOrder.ts`  \n  \n---  \n  \n### 8. ColumnDnd  \n  \n컬럼 헤더를 드래그 앤 드롭으로 순서를 변경한다. 그룹 헤더의 리프 컬럼 ID를 추출하여 정확한 위치를 계산한다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `columnOrder` | `string[]` | 컬럼 ID 순서 |  \n| `initialColumnOrder` | `string[]` | 비제어 모드 초기값 |  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| table | `onColumnOrderChange(newOrder)` | 제어 모드 콜백 |  \n| util | `validateDndAction(source, target)` | tableId, parentId 일치 검증 |  \n| util | `getRespectiveLeafIds(header)` | 그룹 헤더에서 리프 컬럼 ID 추출 |  \n| util | `calculateNewColumnOrder(current, source, target, edge)` | 드롭 위치(left/right)에 따른 새 순서 계산 |  \n  \n> `@atlaskit/pragmatic-drag-and-drop` 라이브러리 기반. `extractClosestEdge()`로 드롭 위치 판별.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/hooks/useTableColumnDndMonitor.ts`  \n- `packages/react/src/table/utils/columnDndUtils.ts`  \n- `packages/react/src/table/components/TableHeaderCell/DraggableTableHeaderCell.tsx`  \n  \n---  \n  \n### 9. RowClick  \n  \n행 클릭으로 선택/토글하고, 현재 클릭된 행 ID를 상태로 관리한다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `clickedRowId` | `string \\| null` | 현재 클릭된 행 ID |  \n  \n> 같은 행 클릭 시 선택 해제, 다른 행 클릭 시 선택 전환. `disableUnClick` 옵션으로 해제를 비활성화할 수 있다.  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| table | `handleRowClick(rowId, row?)` | 클릭 상태 관리 및 `onRowClick` 콜백 호출 |  \n| table | `clickedRowId` | 현재 상태 조회 |  \n| callback | `onRowClick(rowData, index)` | 선택 시 행 데이터 전달, 해제 시 null |  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/hooks/useTableClick.ts`  \n- `packages/react/src/table/providers/TableRowClickProvider.tsx`  \n  \n---  \n  \n### 10. RowDrag  \n  \n외부 드래그 콜백 전용의 행 드래그 기능. RowOrdering DnD와 상호 배타적이다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `dragState` | `{ data: T \\| null, rowId: string \\| null }` | 현재 드래그 중인 행 데이터 |  \n| `dragPreviewPosition` | `{ x: number, y: number }` | 프리뷰 좌표 |  \n  \n> `DRAG_THRESHOLD=8px`를 초과해야 드래그로 인식한다.  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| table | `startDrag(event, rowId, rowData)` | 포인터 기반 드래그 시작 |  \n| table | `draggedRowId` | 현재 드래그 중인 행 ID |  \n| table | `renderDragPreview()` | 포털 기반 프리뷰 컴포넌트 |  \n| callback | `onRowDragStart(row)` | 드래그 시작 콜백 |  \n| callback | `onRowDrag({ row, clientX, clientY })` | 드래그 중 콜백 |  \n| callback | `onRowDragEnd(row, event)` | 드래그 종료 콜백 |  \n  \n> RowOrdering의 `draggable`과 동시 사용 불가 — 충돌 검사가 내장되어 있다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/hooks/useTableDrag.tsx`  \n- `packages/react/src/table/providers/TableDragProvider.tsx`  \n- `packages/react/src/table/components/TableDragPreview.tsx`  \n  \n---  \n  \n### 11. InfiniteScroll  \n  \n스크롤 위치가 threshold에 도달하면 콜백을 호출하는 무한 스크롤.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `threshold` | `number` | 하단으로부터의 트리거 거리 (기본값 100px) |  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| table | `handleInfiniteScroll(event)` | 스크롤 이벤트 핸들러 |  \n| callback | `onBottomReached()` | threshold 도달 시 호출 |  \n  \n> `scrollHeight - scrollTop - clientHeight ≤ threshold` 조건으로 판별. 스크롤 불가능한 컨테이너(`scrollHeight ≤ clientHeight`)는 건너뛴다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/hooks/useInfiniteScroll.ts`  \n  \n---  \n  \n### 12. CellFormatting  \n  \n셀 값의 타입에 따라 자동 정렬(alignment)을 결정하고, 숫자 포맷과 ratio 데이터를 처리한다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| column `align` | `'left' \\| 'right' \\| 'center'` | 명시적 정렬 |  \n| column `type` | `'string' \\| 'number' \\| 'stringNumber'` | 셀 데이터 타입 |  \n| column `decimal` | `number` | 숫자 소수점 자릿수 |  \n| column `format` | `'ratio'` | ratio 렌더링 플래그 |  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| cell | `getCellAlign(value, columnAlign)` | 값 타입 기반 자동 정렬 (숫자→right, 문자→left) |  \n| cell | `toLocaleString()` 적용 | 숫자 title 생성 |  \n| cell | ratio 렌더링 | `format: 'ratio'`일 때 바 시각화 |  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/components/TableCell/useCellAppearance.ts`  \n- `packages/react/src/table/components/TableCell/RatioCell.tsx`  \n- `packages/react/src/table/utils/tableHelpers.tsx`  \n  \n---  \n  \n### 13. InlineUtilities  \n  \n셀 내에 인라인으로 표시할 expander/checkbox의 표시 여부와 깊이(depth) 기반 로직을 결정한다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| column `expander.display` | `boolean` | expander 명시적 표시 여부 |  \n| column `expander.depth` | `number` | 표시할 트리 깊이 (-1: 모든 깊이) |  \n| column `checkbox.display` | `boolean` | checkbox 명시적 표시 여부 |  \n| column `checkbox.depth` | `number` | 표시할 트리 깊이 (-1: 모든 깊이) |  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| cell | `calculateInlineStatus(row, column)` | `{showExpander, showCheckbox, paddingLeftRem}` 반환 |  \n| cell | `shouldDisplayExpander()` | 깊이 매칭 + 첫 번째 컬럼 기본 규칙 |  \n| cell | `shouldDisplayCheckbox()` | checkbox 동일 로직 |  \n| header | `canRenderInlineHeaderCheckbox()` | 헤더 전용 체크박스 표시 판별 |  \n| column | `isInlineSelectHost()` | 선택 호스트 컬럼 식별 |  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/utils/tableInlineUtils.ts`  \n- `packages/react/src/table/components/TableCell/CellInlineUtilities.tsx`  \n- `packages/react/src/table/components/TableCell/CellUtilityControl.tsx`  \n- `packages/react/src/table/hooks/useTableColumns.tsx`  \n  \n---  \n  \n### 14. PinningStyle  \n  \n고정(pinned) 행과 열의 오프셋 스타일을 계산한다.  \n  \n**상태 (State)**  \n  \n| 상태 | 타입 | 설명 |  \n|------|------|------|  \n| `rowPinning` | `RowPinningState` | `{ top: string[], bottom: string[] }` |  \n| `columnPinning` | `ColumnPinningState` | `{ left: string[], right: string[] }` |  \n  \n**API**  \n  \n| 레벨 | API | 설명 |  \n|------|-----|------|  \n| row | `getPinnedRowTopStyle(table, options, rowId)` | `{ zIndex: 10, top: index * rowHeight }` |  \n| column | `getPinnedColumnOffsetStyle(table, pinning, columnId, options)` | left pinned: 이전 컬럼 너비 합, right pinned: 이후 컬럼 너비 합 |  \n  \n> `column.getSize()`를 사용하여 오프셋을 계산한다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/utils/tablePinningUtils.ts`  \n- `packages/react/src/table/components/TableRow.tsx`  \n- `packages/react/src/table/components/TableHeaderCell/BaseTableHeaderCell.tsx`  \n  \n---  \n  \n## 2부: React 렌더링 어댑터  \n  \nDOM/React에 의존하는 렌더링/UI 기능 — 프레임워크 종속 레이어.  \n  \n| # | 기능명 | 설명 |  \n|---|--------|------|  \n| 1 | 9-Grid 레이아웃 | 행/열 고정을 위한 9분할 그리드 구조 |  \n| 2 | 스크롤 동기화 | 9-Grid 섹션 간 스크롤 위치 동기화 |  \n| 3 | Sticky Tree | 트리 부모 행 sticky 렌더링 |  \n| 4 | 셀 경계선 | 남은 공간 감지 기반 스마트 보더 |  \n| 5 | 검색 하이라이팅 | 검색어 하이라이트 렌더링 |  \n| 6 | 남은 공간 감지 | 테이블 컨테이너 여백 감지 |  \n| 7 | 리사이즈 가이드 | 컬럼 리사이즈 시각 가이드라인 |  \n| 8 | 드래그 프리뷰 | DnD 프리뷰 요소 포털 렌더링 |  \n| 9 | 툴바 | 검색, 제목, 옵션 메뉴 포함 툴바 |  \n| 10 | 푸터 | 페이지네이션, 행 정보, per-page 선택기 |  \n| 11 | 컬럼 가시성 모달 | 컬럼 표시/숨김 토글 모달 |  \n| 12 | 커스텀 스타일 | Context 기반 커스텀 스타일 적용 |  \n| 13 | Empty 상태 | 빈 테이블 상태 표시 |  \n| 14 | 셀·헤더 렌더링 | 셀/헤더 컴포넌트 트리 |  \n| 15 | 레이아웃 유틸리티 | 위치/크기 계산 헬퍼 |  \n  \n---  \n  \n### 1. 9-Grid 레이아웃  \n  \n행 고정(top/bottom)과 열 고정(left/right)을 동시에 지원하기 위해 테이블을 9개 섹션으로 분할하는 레이아웃.  \n  \n```  \n┌──────────┬────────────────┬──────────┐  \n│ top-left │   top-center   │top-right │  ← pinned top rows  \n├──────────┼────────────────┼──────────┤  \n│   left   │    center      │  right   │  ← scrollable body  \n├──────────┼────────────────┼──────────┤  \n│ bot-left │  bot-center    │bot-right │  ← pinned bottom rows  \n└──────────┴────────────────┴──────────┘  \n  pinned-L      scroll        pinned-R```  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/Table.tsx` — 9-Grid 아키텍처 정의  \n- `packages/react/src/table/utils/layoutUtils.ts` — 위치/크기 계산  \n- `packages/react/src/table/components/TableHeaderArea.tsx` — left/center/right 헤더 섹션  \n- `packages/react/src/table/components/TableBodyArea.tsx` — top/center/bottom 바디 섹션  \n- `packages/react/src/table/components/TableCenterRowSection.tsx` — 중앙 스크롤 영역 + left/right 고정 컬럼  \n- `packages/react/src/table/components/TableTopRowSection.tsx`  \n- `packages/react/src/table/components/TableBottomRowSection.tsx`  \n  \n---  \n  \n### 2. 스크롤 동기화  \n  \n9-Grid의 각 섹션이 동일한 스크롤 위치를 유지하도록 동기화한다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/hooks/useTableScrollSync/useTableScrollSync.ts`  \n- `packages/react/src/table/hooks/useTableScrollSync/useTableScrollSync.browser.test.tsx`  \n- `packages/react/src/table/providers/TableScrollSyncProvider.tsx`  \n  \n---  \n  \n### 3. Sticky Tree  \n  \n트리 구조의 부모 행을 sticky 위치에 고정하여 스크롤 시 컨텍스트를 유지한다.  \n  \n> 파싱 로직(트리 구조 해석)은 headless로 분리 가능하나, 주요 구현이 React 렌더링에 집중되어 있어 어댑터로 분류.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/components/StickyTree/StickyTreeRenderer.tsx`  \n- `packages/react/src/table/components/StickyTree/components/StickyTreeNode.tsx`  \n- `packages/react/src/table/components/StickyTree/stickyTreeUtils.ts`  \n- `packages/react/src/table/components/StickyTree/utils/stickyTreeChildren.ts`  \n- `packages/react/src/table/components/StickyTree/utils/stickyTreeNodeStyles.ts`  \n- `packages/react/src/table/components/StickyTree/hooks/useStickyTreeCells.ts`  \n- `packages/react/src/table/components/StickyTree/hooks/useStickyTreeNode.ts`  \n- `packages/react/src/table/components/TableBodySegment.tsx`  \n  \n---  \n  \n### 4. 셀 경계선  \n  \n남은 공간 감지를 활용하여 셀 보더를 스마트하게 표시한다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/components/TableCell/useCellAppearance.ts`  \n- `packages/react/src/table/components/TableCell/TableCell.tsx`  \n- `packages/react/src/table/providers/TableRemainingSpaceProvider.tsx`  \n  \n---  \n  \n### 5. 검색 하이라이팅  \n  \n다중 검색어를 셀 텍스트에서 하이라이트 처리한다. 숫자 검색 패턴도 지원한다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/components/HighlightText.tsx`  \n- `packages/react/src/table/utils/searchHelpers.ts`  \n- `packages/react/src/table/components/TableCell/CellContent.tsx`  \n- `packages/react/src/table/providers/TableSearchProvider.tsx`  \n  \n---  \n  \n### 6. 남은 공간 감지  \n  \n테이블 컨테이너의 X/Y축 여백을 감지하여 보더, 스크롤 등의 동작을 조정한다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/providers/TableRemainingSpaceProvider.tsx`  \n- `packages/react/src/table/components/TableCell/useCellAppearance.ts`  \n  \n---  \n  \n### 7. 리사이즈 가이드  \n  \n컬럼 리사이즈 드래그 중 수직 가이드라인을 포털로 렌더링한다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/components/TableHeaderCell/PortalResizeGuide.tsx`  \n- `packages/react/src/table/components/TableHeaderCell/ResizeHandler.tsx`  \n- `packages/react/src/table/components/TableHeaderCell/PortalDropIndicator.tsx`  \n  \n---  \n  \n### 8. 드래그 프리뷰  \n  \n행/컬럼 드래그 시 포털 기반 프리뷰 요소를 렌더링한다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/components/TableDragPreview.tsx`  \n- `packages/react/src/table/hooks/useTableDrag.tsx`  \n- `packages/react/src/table/providers/TableDragProvider.tsx`  \n  \n---  \n  \n### 9. 툴바  \n  \n검색, 제목, 옵션 메뉴, 행 이동 버튼을 포함하는 테이블 상단 툴바.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/components/TableToolbar.tsx`  \n- `packages/react/src/table/components/TableOptionsMenu.tsx`  \n- `packages/react/src/table/components/TableMoveToButton.tsx`  \n- `packages/react/src/table/components/TableRenderer.tsx`  \n  \n---  \n  \n### 10. 푸터  \n  \n페이지네이션 컨트롤, 행 정보, per-page 선택기를 포함하는 테이블 하단 푸터.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/components/TableFooter.tsx`  \n- `packages/react/src/table/components/TablePagination.tsx`  \n- `packages/react/src/table/components/TablePerPage.tsx`  \n- `packages/react/src/table/components/TableRenderer.tsx`  \n  \n---  \n  \n### 11. 컬럼 가시성 모달  \n  \n컬럼 표시/숨김 토글과 순서 변경을 지원하는 모달.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/components/TableColumnVisibilityModal.tsx`  \n  \n---  \n  \n### 12. 커스텀 스타일  \n  \nContext 기반으로 테이블의 각 섹션(wrapper, container, header, cell, footer, toolbar)에 커스텀 스타일을 적용한다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/providers/TableCustomStylesProvider.tsx`  \n- `packages/react/src/table/types/table.types.ts` — `TableCustomStyle` 타입 정의  \n- `packages/react/src/table/components/TableRenderer.tsx`  \n- `packages/react/src/table/components/TableHeaderArea.tsx`  \n- `packages/react/src/table/components/TableCell/useCellAppearance.ts`  \n- `packages/react/src/table/components/TableFooter.tsx`  \n- `packages/react/src/table/components/TableToolbar.tsx`  \n  \n---  \n  \n### 13. Empty 상태  \n  \n데이터가 없을 때 빈 상태 메시지를 표시한다. 커스텀 콘텐츠를 지원한다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/components/TableEmptyRow.tsx`  \n- `packages/react/src/table/components/TableBodySegment.tsx`  \n  \n---  \n  \n### 14. 셀·헤더 렌더링  \n  \n셀과 헤더의 컴포넌트 트리. 숫자 포맷, 하이라이팅, 체크박스, 라디오, expander 등 다양한 셀 유형을 포함한다.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/components/TableCell/TableCell.tsx`  \n- `packages/react/src/table/components/TableCell/CellContent.tsx`  \n- `packages/react/src/table/components/TableCell/CellInlineUtilities.tsx`  \n- `packages/react/src/table/components/TableCell/CellUtilityControl.tsx`  \n- `packages/react/src/table/components/TableCell/RatioCell.tsx`  \n- `packages/react/src/table/components/TableHeader.tsx`  \n- `packages/react/src/table/components/TableHeaderCell/HeaderCellContent.tsx`  \n- `packages/react/src/table/components/TableHeaderCell/TableHeaderCell.tsx`  \n- `packages/react/src/table/components/TableHeaderCell/BaseTableHeaderCell.tsx`  \n- `packages/react/src/table/components/TableHeaderCell/DraggableTableHeaderCell.tsx`  \n- `packages/react/src/table/components/TableHeaderCell/StaticTableHeaderCell.tsx`  \n- `packages/react/src/table/components/TableBody.tsx`  \n- `packages/react/src/table/components/TableRow.tsx`  \n- `packages/react/src/table/components/cells/CheckboxCell.tsx`  \n- `packages/react/src/table/components/cells/ExpanderCell.tsx`  \n- `packages/react/src/table/components/cells/RadioCell.tsx`  \n  \n---  \n  \n### 15. 레이아웃 유틸리티  \n  \n위치, 크기, 행 분할 등의 레이아웃 계산 헬퍼.  \n  \n**관련 소스 파일**  \n  \n- `packages/react/src/table/utils/layoutUtils.ts` — `getHeaderCellPosition`, `getRowTopPosition`, `getCellPosition`, `splitRows`  \n- `packages/react/src/table/utils/tablePinningUtils.ts`  \n- `packages/react/src/table/utils/tableMergeUtils.ts`  \n- `packages/react/src/table/components/TableCell/useCellLayout.ts`  \n- `packages/react/src/table/hooks/useColumnSizing/utils.ts`  \n  \n---  \n  \n## 3부: 공통 패턴  \n  \n### Controlled / Uncontrolled 통합  \n  \n모든 상태 관리 기능은 TanStack Table의 Controlled/Uncontrolled 패턴을 따른다. 독립 Feature가 아닌 각 Feature의 `getDefaultOptions`에 내장되는 공통 패턴이다.  \n  \n```typescript  \ninterface FeatureOptions<T> {  \n  // Controlled 모드  \n  [state]?: StateType;  on[State]Change?: OnChangeFn<StateType>;  \n  // Uncontrolled 모드  \n  initial[State]?: StateType;}  \n```  \n  \n**기능별 적용 현황**  \n  \n| 기능 | Controlled | Uncontrolled |  \n|------|-----------|-------------|  \n| RowOrdering | `rowOrder` + `onRowOrderChange` | `initialRowOrder` |  \n| ColumnDnd | `columnOrder` + `onColumnOrderChange` | `initialColumnOrder` |  \n| Selection | `rowSelection` + `onRowSelectionChange` | `initialRowSelection` |  \n| Expand | `expanded` + `onExpandedChange` | `initialExpanded` |  \n| Sorting | `sorting` + `onSortingChange` | `initialSorting` |  \n| Pagination | `pagination` + `onPaginationChange` | `initialPagination` |  \n| GlobalSearch | `keyword` + `onKeywordChange` | `defaultKeyword` |  \n  \n**구현 메커니즘**  \n  \n- `Table.tsx`에서 `useDeepMemo`로 옵션을 병합하며 controlled 속성이 기본값을 오버라이드  \n- 각 Feature는 `table.getState()`로 상태를 읽고, `table.setState()`로 상태를 설정  \n- 외부 핸들러가 없으면 TanStack Table이 내부 상태를 관리  \n  \n---  \n  \n## Provider 인프라  \n  \nReact 어댑터 전반에서 사용하는 Context Provider 목록:  \n  \n| Provider | 역할 |  \n|----------|------|  \n| `TableProvider` | 핵심 table 인스턴스 |  \n| `TableOptionsProvider` | 테이블 옵션 |  \n| `TableRefsProvider` | DOM ref (스크롤 동기화용) |  \n| `TableContainerSizeProvider` | 컨테이너 크기 |  \n| `TableRowVirtualizerProvider` | 행 가상화 상태 |  \n| `TableRowClickProvider` | 행 클릭 상태 |  \n| `TableHiddenCellProvider` | 셀 병합 숨김 상태 |  \n| `TableScrollSyncProvider` | 스크롤 동기화 |  \n| `TableSearchProvider` | 검색 상태 |  \n| `TableDragProvider` | 드래그 상태 |  \n| `TableCustomStylesProvider` | 커스텀 스타일 |  \n| `TableRemainingSpaceProvider` | 남은 공간 감지 |"},
		{"id":"424bd6a4c662f41c","x":500,"y":-1600,"width":780,"height":1030,"type":"text","text":"# Table Custom Features 마이그레이션 구현 계획\n\n> `survey.md`의 아키텍처 결정 사항을 바탕으로 한 최종 기술 명세서입니다.\n> 14개 Headless 기능을 TanStack Table Custom Feature API(`_features`)로 전환하는 단계별 설계를 포함합니다.\n\n---\n\n## 1. 목표\n\n현재 `create*Config` + Provider + Hook 패턴으로 분산된 테이블 기능 로직을 **TanStack Table Custom Feature API** 기반으로 통합한다.\n\n**핵심 원칙:**\n- **Zero Breaking Changes:** 외부 API(`TableOptions`) 100% 하위 호환성 유지\n- **Atomic Migration:** 과도기 없이 기능 단위로 완결적 전환 (Feature Flag 미사용)\n- **Single Source of Truth:** 모든 상태는 `table.getState()`로 일원화\n- **Headless First:** DOM 의존성(이벤트, 측정)과 비즈니스 로직의 엄격한 분리\n\n---\n\n## 2. 아키텍처 개요\n\n### 2.1 현재 구조 (AS-IS)\n\n```mermaid\ngraph TD\n    TO[TableOptions] --> Config[create*Config x9]\n    Config --> Merge[lodash merge]\n    Merge --> Hook[useReactTable + Custom Hooks x16]\n    Hook --> Context[Context Provider x12]\n    Context --> Comp[Components]\n```\n\n**문제점:**\n- 상태의 파편화 (TanStack Internal / React Context / Local State)\n- `create*Config`, Hook, Provider 간 로직 분산\n- Provider 중첩으로 인한 렌더링 오버헤드\n\n### 2.2 목표 구조 (TO-BE)\n\n```mermaid\ngraph TD\n    TO[TableOptions] --> Adapter[Option Bridge]\n    Adapter --> Feature[Custom Features x14]\n    Feature --> Table[useReactTable with _features]\n    Table --> State[table.getState]\n    State --> Comp[Components]\n```\n\n**개선점:**\n- **Co-location:** 기능별 상태·로직·API가 Feature 객체 내에 응집\n- **Provider-less:** 로직용 Provider 제거, 렌더링 전용 Provider만 유지\n- **Referential Stability:** Feature 배열 및 옵션 객체의 불변성 보장\n\n---\n\n## 3. 디렉토리 구조\n\n```\npackages/react/src/table/\n├── features/                          ← NEW\n│   ├── index.ts                       ← Feature 조립(Priority Sort) 및 옵션 브릿지\n│   ├── row-click/\n│   │   ├── rowClickFeature.ts         ← TableFeature 구현체\n│   │   ├── rowClickFeature.types.ts   ← State/Options 타입 정의\n│   │   └── rowClickFeature.test.ts    ← Headless 단위 테스트\n│   ├── global-search/\n│   │   ├── globalSearchFeature.ts\n│   │   ├── globalSearchFeature.utils.ts\n│   │   └── ...\n│   ├── cell-merging/\n│   │   └── ...\n│   └── ... (나머지 Feature)\n├── Table.tsx                          ← MODIFIED (Provider 축소, _features 주입)\n├── types/\n│   ├── table.types.ts                 ← PRESERVED (외부 API 유지)\n│   └── tanstack-table.d.ts            ← MODIFIED (Feature별 타입 확장 통합)\n├── components/                        ← MODIFIED (state 직접 접근으로 변경)\n├── hooks/                             ← REDUCED (Adapter Hook만 잔존)\n└── providers/                         ← REDUCED (렌더링 전용만 잔존)\n```\n\n---\n\n## 4. Custom Feature 공통 구현 패턴\n\n### 4.1 Feature 객체 구조\n\n모든 Feature는 `TableFeature` 인터페이스를 구현하며, **Controlled/Uncontrolled** 패턴을 `makeStateUpdater`로 내재화한다.\n\n```typescript\n// features/row-click/rowClickFeature.ts\nimport { makeStateUpdater, functionalUpdate } from '@tanstack/react-table';\n\nexport const RowClickFeature: TableFeature<any> = {\n  // 1. 초기 상태 (Initial State)\n  getInitialState: (state) => ({\n    clickedRowId: null,\n    ...state,\n  }),\n\n  // 2. 기본 옵션 (Controlled 체크 및 State Updater 생성)\n  getDefaultOptions: <TData extends RowData>(table: Table<TData>) => ({\n    onClickedRowIdChange: makeStateUpdater('clickedRowId', table),\n  }),\n\n  // 3. 인스턴스 확장 (API Injection)\n  createTable: <TData extends RowData>(table: Table<TData>) => {\n    // 내부 State 변경을 외부 Callback으로 전달하는 Proxy\n    table.setClickedRowId = (updater) => {\n      const safeUpdater = (old) => functionalUpdate(updater, old);\n      table.options.onClickedRowIdChange?.(safeUpdater);\n    };\n    // 비즈니스 로직 메서드\n    table.handleRowClick = (rowId, row) => {\n       /* Implementation */\n    };\n  },\n  \n  // 4. 엔티티 확장 (Row/Column/Cell)\n  createRow: (row, table) => {\n    row.getIsClicked = () => table.getState().clickedRowId === row.id;\n  }\n};\n```\n\n### 4.2 옵션 브릿지 (Bridge Pattern)\n\n기존 `TableOptions`를 Feature가 이해하는 `TableOptionsResolved` 형태로 변환하는 어댑터.\n\n```typescript\n// features/index.ts\nexport function resolveFeatureOptions<T extends object>(\n  options: TableOptions<T>,\n): Partial<TableOptionsResolved<T>> {\n  return {\n    // 예: RowClick 옵션 매핑\n    ...(options.clickable?.use && {\n      enableRowClick: true,\n      disableUnClick: options.clickable.disableUnClick,\n      // Controlled 모드: 외부 값을 state로 주입\n      ...(options.clickable.clickedRowId !== undefined && {\n        state: { clickedRowId: options.clickable.clickedRowId },\n      }),\n      // 핸들러 매핑\n      ...(options.clickable.onClickedRowIdChange && {\n        onClickedRowIdChange: options.clickable.onClickedRowIdChange,\n      }),\n    }),\n    // ... 다른 기능 매핑\n  };\n}\n```\n\n---\n\n## 5. Table.tsx 통합 및 최적화\n\n### 5.1 Feature 주입 순서 제어\n\n기능 간 의존성(Dependency) 해결을 위해 주입 순서를 상수로 관리한다.\n\n```typescript\n// features/index.ts\nconst FEATURE_PRIORITY = [\n  'Expanding',      // TreeSelection보다 먼저\n  'TreeSelection',  // RowOrdering보다 먼저 (선택 상태 유지)\n  'RowOrdering',\n  // ...\n  'Layout',         // 가장 마지막\n];\n\nexport function buildFeatureList(options: TableOptions<any>) {\n  const features = [];\n  // ... push features based on options\n  return features.sort(sortByPriority); \n}\n```\n\n### 5.2 Table.tsx 구현\n\n**참조 안정성(Referential Stability)**을 확보하여 불필요한 테이블 재생성을 방지한다.\n\n```typescript\n// Table.tsx\nexport const Table = forwardRef(function Table<T extends object>(\n  { options, ...props }: TableProps<T>, ref\n) {\n  // 1. Feature List Memoization\n  // options 객체 전체가 아닌, 활성화 '플래그'만 의존성으로 감시\n  const features = useMemo(() => buildFeatureList(options), [\n    options.clickable?.use,\n    options.sortable?.use,\n    options.search?.use,\n    options.merging?.use,\n    // ...\n  ]);\n\n  // 2. Option Bridge\n  const featureOptions = useMemo(() => resolveFeatureOptions(options), [options]);\n\n  const table = useReactTable({\n    _features: features,\n    ...featureOptions,\n    // ...\n  });\n\n  return (\n    <TableProvider table={table}>\n      {/* 로직 Provider 제거됨. 렌더링/스타일 관련 Provider만 유지 */}\n      <TableCustomStylesProvider ...>\n         <TableRenderer>{children}</TableRenderer>\n      </TableCustomStylesProvider>\n    </TableProvider>\n  );\n});\n```\n\n### 5.3 Provider 제거 계획\n\n| Provider | 처리 | 대체 |\n|----------|------|------|\n| `TableRowClickProvider` | **Remove** | `table.getState().clickedRowId` |\n| `TableHiddenCellProvider` | **Remove** | `table.getState().hiddenCellsSet` |\n| `TableSearchProvider` | **Remove** | `table.getState().globalFilter` |\n| `TableDragProvider` | **Remove** | `table.getState().dragState` |\n| `TableScrollSyncProvider` | **Keep** | DOM Ref 동기화 (React Adapter) |\n| `TableRefsProvider` | **Keep** | DOM Ref |\n\n---\n\n## 6. 14개 Feature 상세 설계 및 Phase\n\n### Phase 1: 패턴 확립 & 구조적 확장 (2개)\n가장 위험도가 낮은 기능으로 아키텍처(Table/Row/Column/Cell 확장)를 검증한다.\n\n1.  **RowClick Feature:**\n    * **검증:** `makeStateUpdater`를 통한 Controlled/Uncontrolled 동작, Provider 제거 효과.\n    * **범위:** `createTable` (핸들러), `createRow` (상태 조회).\n2.  **InlineUtilities Feature:**\n    * **검증:** Cell/Column 레벨의 확장(`createCell`, `createColumn`) 패턴 검증.\n    * **내용:** Expander/Checkbox 표시 로직 이관. 상태 없이 계산 로직만 존재.\n\n### Phase 2: 데이터 로직 (2개)\n순수 데이터 변환 로직을 이관한다.\n\n3.  **GlobalSearch Feature:**\n    * **내용:** `createSearchConfig` 제거, `filterFn` 주입, Pinned Row 필터링 제외 로직 통합.\n    * **State:** TanStack built-in `globalFilter` 사용.\n4.  **CellFormatting Feature:**\n    * **내용:** `createCell`에서 포맷팅 메소드(`getFormattedValue`) 주입.\n\n### Phase 3: Core 로직 (4개)\n기존 Core 기능과 상호작용이 많은 복잡한 로직을 처리한다.\n\n5.  **TreeSelection Feature:**\n    * **의존성:** `Expanding` 기능보다 늦게 초기화되어야 함 (Priority 제어).\n    * **내용:** `TableMeta` 의존성 제거.\n6.  **RowOrdering Feature:** (High Complexity)\n    * **내용:** DnD 라이브러리 연동부(Adapter)와 상태 관리(Feature)의 명확한 분리. 필터링 시 이동 불가 로직 통합.\n7.  **ColumnDnd Feature:**\n    * **내용:** `@atlaskit` 이벤트 핸들러는 컴포넌트에 유지, 순서 계산 로직만 이관.\n8.  **RowDrag Feature:**\n    * **내용:** 포인터 이벤트 핸들링은 Hook으로 유지하되, `dragState` 및 데이터는 Feature로 이관.\n\n### Phase 4: 레이아웃 & DOM 연동 (6개)\nDOM 측정 및 레이아웃 계산이 필요한 고난이도 기능을 처리한다.\n\n9.  **PinAwareSorting Feature:** 커스텀 `getSortedRowModel`을 Feature 기본값으로 설정.\n10. **FilterAwareExpand Feature:** 커스텀 `getExpandedRowModel` 통합.\n11. **AutoColumnSizing Feature:** `ResizeObserver`(Adapter)에서 `table.calculateColumnSizing()`(Feature) 호출 구조.\n12. **PinningStyle Feature:** `row.getPinnedRowTopStyle()` 등 스타일 계산 로직 통합.\n13. **CellMerging Feature:** (High Risk & Performance)\n    * **최적화:** `getMergeInfo` 호출 시 성능 저하 방지를 위해 계산 결과 Memoization 필수.\n    * **State:** `hiddenCellsSet`의 직렬화/역직렬화 처리.\n14. **InfiniteScroll Feature:**\n    * **내용:** 가장 단순하지만 DOM 스크롤 이벤트와 연동되므로 마지막에 정리.\n\n---\n\n## 7. 테스트 전략\n\n### 7.1 Headless 단위 테스트 (New)\nUI 렌더링 없이 로직을 검증하는 테스트 케이스를 신규 작성한다. 이는 비즈니스 로직의 견고함을 보장한다.\n\n```typescript\n// features/cell-merging/cellMerging.test.ts\nimport { createTable, getCoreRowModel } from '@tanstack/table-core';\nimport { CellMergingFeature } from './cellMergingFeature';\n\ndescribe('CellMergingFeature', () => {\n  it('rowSpan이 2 이상인 셀은 다음 행의 같은 컬럼을 숨김 처리해야 한다', () => {\n    // 1. Headless Table 인스턴스 생성\n    const table = createTable({\n      _features: [CellMergingFeature],\n      data: mockData,\n      columns: mockColumns,\n      getCoreRowModel: getCoreRowModel(),\n      // ...\n    });\n\n    // 2. API 호출 및 상태 검증\n    const mergeInfo = table.getMergeInfo('row-0', 'col-0');\n    expect(mergeInfo.rowSpan).toBe(2);\n    \n    const isHidden = table.isCellHidden('row-1', 'col-0');\n    expect(isHidden).toBe(true);\n  });\n});\n```\n\n### 7.2 기존 테스트 유지\n- `spec/` 디렉토리의 Storybook browser test는 모두 통과해야 함.\n- UI 렌더링 및 통합 시나리오의 회귀(Regression) 방지용."},
		{"id":"967de262fc232784","x":-600,"y":-1600,"width":840,"height":1030,"type":"text","text":"# Architectural Survey: Table Custom Features 마이그레이션  \n  \n> `table-custom-features.md`에 정리된 기능들을 **TanStack Table Custom Feature API** 기반으로 전면 재구성하기 위한 아키텍처 결정 사항입니다.  \n  \n---  \n  \n## 1. 프로젝트 컨텍스트  \n  \n### 1-1. 마이그레이션 범위  \n  \n- 14개 Headless 기능(1부) 전체를 Custom Feature로 전환하나요?  \n> **Yes.** 14개 기능 모두를 Custom Feature로 전환합니다. 하나씩 순차적으로 진행하며, 각 기능은 독립적인 PR로 처리합니다.  \n  \n- React 렌더링 어댑터(2부)도 포함되나요?  \n> **Partial.** 렌더링 어댑터 자체를 없애지는 않지만, 어댑터 내부에 존재하는 **비즈니스 로직과 상태 관리 코드는 모두 Headless Feature로 이관**합니다. 어댑터는 오직 View(렌더링)와 DOM Event 바인딩 역할만 남깁니다.  \n  \n### 1-2. 타임라인 & 제약  \n  \n- 기존 Table API(`TableOptions`)의 하위 호환성을 유지해야 하나요?  \n> **Strictly Yes.** 내부 구현은 완전히 바뀌더라도, 외부에서 주입하는 `TableOptions` 인터페이스와 동작은 **100% 하위 호환성을 유지**해야 합니다. Consumer 코드 수정 없이 내부 엔진만 교체하는 것이 목표입니다.  \n  \n- 과도기 허용 여부?  \n> **No.** 릴리즈 단위에서는 기존 코드와 신규 코드가 공존하지 않도록, 기능 단위로 깔끔하게 대체하여 커밋합니다.  \n  \n---  \n  \n## 2. TanStack Custom Feature API 설계 전략  \n  \n### 2-1. Feature 단위 결정  \n  \n- 기능을 1:1로 매핑하나요, 통합하나요?  \n> **1:1 Mapping.** 유지보수성을 위해 `table-custom-features.md`에 정의된 14개 기능을 각각 독립된 Feature로 구현합니다. (예: `RowOrdering`, `RowDrag`는 별도 Feature로 유지하되 내부적으로 상태를 공유할 수 있음)  \n  \n### 2-2. Custom Feature 구현 패턴  \n  \n- 어떤 확장 포인트를 사용하나요?  \n> **All.** 기능의 성격에 따라 필요한 확장을 모두 사용합니다.  \n> - `createTable`: 전역 메소드 및 상태 주입  \n> - `getDefaultOptions`: 기본값 설정 및 `initialState` 처리  \n> - `createColumn/Row/Cell`: 엔티티별 메소드 확장 (예: `row.getIsHidden()`)  \n  \n- Feature 간 의존성 처리?  \n> **Internal State Access.** `table.getState()`를 통해 다른 Feature의 상태를 참조합니다. 초기화 순서가 중요한 경우 `_features` 배열의 주입 순서를 제어하여 해결합니다. (예: `Expanding` 관련 Feature를 먼저 주입)  \n  \n### 2-3. 상태 관리  \n  \n- Controlled/Uncontrolled 패턴 처리?  \n> **Internalize.** 현재 Wrapper 컴포넌트에서 수행하던 Controlled/Uncontrolled 분기 로직을 **Custom Feature 내부(`getDefaultOptions` 등)**로 가져옵니다. TanStack Table 코어의 상태 관리 매커니즘에 위임하여 Wrapper의 복잡도를 제거합니다.  \n  \n---  \n  \n## 3. 기존 아키텍처와의 관계  \n  \n### 3-1. create*Config 패턴 전환  \n  \n- `create*Config` 함수들은 어떻게 되나요?  \n> **Deprecated & Removed.** 기존의 절차적 Config 생성 함수들은 모두 제거하고, `useReactTable`의 `_features` 배열에 선언적으로 주입하는 방식으로 변경합니다.  \n  \n### 3-2. Provider 인프라  \n  \n- Provider 처리 전략은?  \n> **Remove Logic Providers.** 상태나 로직을 들고 있는 Provider(`TableHiddenCellProvider`, `TableSearchProvider` 등)는 **제거**하고 `table.getState()`로 대체합니다.  \n> 단, UI 렌더링에 필수적인 Context(`TableCustomStylesProvider` 등)는 React 어댑터 계층에 유지합니다.  \n  \n### 3-3. Hook 이관  \n  \n- 커스텀 Hook 처리?  \n> **Split.**  \n> - **Logic Hooks** (예: `useTableMerge`): Custom Feature 내부 로직으로 흡수.  \n> - **Adapter Hooks** (예: `useTableScrollSync`): DOM 조작이 필요한 경우 어댑터 레이어에 남기되, 내부 상태는 `table` 인스턴스와 동기화.  \n  \n---  \n  \n## 4. 호환성 & 기능 매트릭스  \n  \n### 4-1. Feature 호환성  \n  \n- 기존의 비호환 조합(X) 개선 계획?  \n> **Maintain Status Quo.** 이번 마이그레이션의 목표는 \"리팩토링\"이지 \"기능 개선\"이 아닙니다. 기존의 제약 사항과 호환성 매트릭스는 그대로 유지합니다.  \n  \n- 충돌 감지?  \n> **Documentation based.** 런타임 에러를 던지기보다, 개발자 문서(주석)를 통해 제약 사항을 명시합니다.  \n  \n### 4-2. 9-Grid 레이아웃 호환  \n  \n- 9-Grid 렌더러와의 데이터 통신?  \n> **Via State.** 9-Grid 레이아웃 계산에 필요한 정보(Pinning 오프셋 등)는 모두 `table.getState()`에 저장하고, 렌더러는 이를 구독하여 화면을 그립니다.  \n  \n---  \n  \n## 5. 테스트 전략  \n  \n### 5-1. Feature 단위 테스트  \n  \n- Headless 로직 테스트?  \n> **Create New Unit Tests.** UI 렌더링 없이 `createTable()` 인스턴스만으로 상태 변화를 검증하는 **순수 로직 단위 테스트**를 신규 작성합니다.  \n  \n- 기존 테스트 처리?  \n> **Keep.** 기존의 Storybook/Vitest 기반 통합 테스트는 회귀(Regression) 방지를 위해 그대로 유지하며, 마이그레이션 후에도 통과해야 합니다.  \n  \n---  \n  \n## 6. 패키지 구조 & 배포  \n  \n### 6-1. Feature 코드 위치  \n  \n- 디렉토리 구조?  \n> **Co-location.** 기능별로 응집도를 높여 구성합니다.  \n> `packages/react/src/table/features/[FeatureName]/`  \n>  ├── `index.ts` (Feature 정의)  \n>  ├── `types.ts` (State/Options 타입)  \n>  └── `utils.ts` (순수 함수)  \n  \n### 6-2. 외부 공개 범위  \n  \n- Feature의 외부 공개?  \n> **Internal Use Only.** 이 Feature들은 `@exem-fe/react` 테이블의 내부 구현 상세로 취급하며, 사용자가 개별적으로 import하여 조립하게 하지 않습니다.  \n  \n---  \n  \n## 7. 마이그레이션 실행 전략  \n  \n### 7-1. 단계별 전환 순서  \n  \n- 어떤 순서로 진행하나요?  \n> **Low Risk → High Complexity.**  \n> 1. **Phase 1 (독립 기능):** `RowClick`, `InfiniteScroll` (패턴 확립 및 Provider 제거 검증)  \n> 2. **Phase 2 (데이터 로직):** `GlobalSearch`, `CellFormatting` (순수 로직 이관)  \n> 3. **Phase 3 (Core 로직):** `RowOrdering`, `TreeSelection` (기존 Core 기능과 상호작용)  \n> 4. **Phase 4 (Layout/DOM):** `CellMerging`, `PinningStyle` (가장 복잡함)  \n  \n### 7-2. Breaking Change 관리  \n  \n- 전략?  \n> **Internal Refactor.** 외부 API(`TableOptions`) 변경 없음. `package.json` 버전 업그레이드 없이 패치/마이너 수준에서 내부 로직만 교체.  \n  \n### 7-3. 롤백 전략  \n  \n- 실패 시?  \n> **Fail Fast.** 기능 단위로 완결성 있게 마이그레이션 하되, 이슈 발생 시 해당 Feature PR을 리버트. (Feature Flag 사용 안 함)  \n  \n---  \n  \n## 8. 추가 고려사항  \n  \n### 8-1. TanStack Table 버전  \n  \n- 버전 업그레이드?  \n> **Freeze.** 현재 사용 중인 버전(v8)을 유지합니다.  \n  \n### 8-2. 문서화  \n  \n- 문서화 계획?  \n> **Update Only.** 새로운 아키텍처 문서를 따로 만들지 않고, 기존 코드의 JSDoc과 Storybook 문서를 현행화하는 수준으로 진행합니다."},
		{"id":"e80db5fc32bcadfb","x":1480,"y":-1600,"width":780,"height":1030,"type":"text","text":"# Table Custom Features 마이그레이션 마일스톤\n\n> 14개 Headless 기능을 TanStack Table Custom Feature API로 전환하는 작업 목록.\n> 각 Feature는 독립 PR로 처리하며, 기존 테스트가 모두 통과해야 완료로 인정한다.\n\n---\n\n## Phase 1. 기반 구조 및 패턴 확립\n\n이 Phase에서 확립된 패턴(Feature 객체 구조, 옵션 브릿지, Provider 제거, 타입 확장)이 이후 모든 Feature의 템플릿이 된다.\n\n- [ ] **Feature 인프라 구축 (`features/index.ts`, 타입 기반)**\n    - 목표: `features/` 디렉토리 생성, `buildFeatureList()` 및 `resolveFeatureOptions()` 함수 구현, `Table.tsx`에 `_features` 배열 주입 구조 연결\n    - 포함: `tanstack-table.d.ts` 확장 구조 설계, Feature 주입 순서(Priority) 상수 정의\n    - 검증: 빈 Feature 배열로 기존 테이블이 정상 동작 (`pnpm test`, `pnpm typecheck`)\n\n- [ ] **RowClick Feature 구현 (패턴 확립용)**\n    - 목표: 첫 번째 Custom Feature 구현으로 전체 패턴 확립. `getInitialState` / `getDefaultOptions` / `createTable` / `createRow` 확장 포인트 모두 사용\n    - 포함: `useTableClick.ts` 로직 이관, `TableRowClickProvider` 제거, 컴포넌트(`TableRow.tsx` 등)에서 `table.handleRowClick` 직접 호출로 전환\n    - 검증: Headless 단위 테스트 + RowClick Storybook browser test 통과\n\n- [ ] **InlineUtilities Feature 구현 (Cell/Column 확장 패턴)**\n    - 목표: `createCell` / `createColumn` 확장 포인트 패턴 검증. 상태 없이 계산 로직만 존재하는 Feature 유형 확립\n    - 포함: `tableInlineUtils.ts` 로직 이관, `useTableColumns.tsx`의 인라인 결정 로직 분리, `cell.getInlineStatus()` / `column.isInlineSelectHost()` API 제공\n    - 검증: Expander/Checkbox가 포함된 스토리 정상 렌더링\n\n---\n\n## Phase 2. 데이터 로직 이관\n\n순수 데이터 변환/필터링 로직을 Feature로 이관한다. 첫 `create*Config` 제거가 포함된다.\n\n- [ ] **GlobalSearch Feature 구현**\n    - 목표: `createSearchConfig.ts` 제거, 커스텀 `globalFilterFn`을 Feature 기본 옵션으로 주입, `TableSearchProvider` 제거\n    - 포함: `globalFilterFn.ts` + `searchHelpers.ts` 로직 이관, Pinned Row 필터 제외 로직 통합, Controlled(`keyword` + `onKeywordChange`) / Uncontrolled(`defaultKeyword`) 패턴을 Feature 내부에서 처리\n    - 검증: 다중 검색어, 숫자 패턴 검색, 트리 하위 행 재귀 검색 테스트 통과\n\n- [ ] **CellFormatting Feature 구현**\n    - 목표: `createCell`에서 셀별 포맷팅 메소드(`getCellAlign`, `getFormattedValue`) 주입\n    - 포함: `tableHelpers.tsx`의 포맷팅 관련 함수 이관, `useCellAppearance.ts`의 포맷팅 로직 분리\n    - 검증: 숫자 자동 right 정렬, 소수점 포맷, ratio 셀 렌더링 정상 동작\n\n---\n\n## Phase 3. Core 로직 이관\n\n기존 Core 기능 및 외부 DnD 라이브러리와 상호작용하는 복잡한 로직을 처리한다. Headless(Feature)와 Adapter(Hook/Component)의 경계를 명확히 한다.\n\n- [ ] **TreeSelection Feature 구현**\n    - 목표: `core/treeSelection.ts` 로직을 Feature로 이관, `TableMeta.toggleTreeRowSelection` 의존성 제거\n    - 포함: `table.toggleTreeRowSelection()` / `row.collectLeafRows()` / `row.getTreeSelectionState()` API 제공, Expanding Feature보다 늦은 초기화 순서 보장\n    - 검증: 부모 토글 → 리프 일괄 선택, indeterminate 상태, 기존 `treeSelection.test.ts` / `collectLeafRows.test.ts` 통과\n\n- [ ] **RowOrdering Feature 구현**\n    - 목표: 상태 관리(`rowOrder`)와 유효성 검증을 Feature로 이관, DnD 이벤트 바인딩(`dnd-kit`)은 어댑터에 유지\n    - 포함: `useTableRowOrdering.ts` + `rowReorderUtils.ts` + `applyInitialRowOrder.ts` 로직 이관, `row.canMoveUp()` / `row.handleMoveUp()` API 제공, 필터링 시 이동 차단 로직 통합, 정렬 자동 초기화\n    - 검증: 버튼 swap + DnD move 모두 동작, Controlled/Uncontrolled 모드, 트리 구조 행 순서 변경\n\n- [ ] **ColumnDnd Feature 구현**\n    - 목표: 컬럼 순서 계산 로직을 Feature로 이관, `@atlaskit/pragmatic-drag-and-drop` 이벤트 핸들러는 `DraggableTableHeaderCell.tsx`에 유지\n    - 포함: `columnDndUtils.ts` 로직 이관, `createColumnOrderingConfig.ts` 제거, `table.validateColumnDnd()` / `table.calculateNewColumnOrder()` API 제공\n    - 검증: 그룹 헤더 포함 컬럼 DnD, 리프 컬럼 ID 추출, 좌/우 드롭 위치 계산\n\n- [ ] **RowDrag Feature 구현**\n    - 목표: `dragState` 및 프리뷰 좌표를 Feature 상태로 이관, `TableDragProvider` 제거\n    - 포함: `useTableDrag.tsx`의 상태 관리 부분 이관 (포인터 이벤트 바인딩은 어댑터 유지), `table.startDrag()` / `table.getDraggedRowId()` / `row.getIsDragging()` API 제공\n    - 검증: 드래그 threshold, 프리뷰 렌더링, RowOrdering DnD와의 상호 배타 동작\n\n---\n\n## Phase 4. 레이아웃 & Row Model 통합\n\n커스텀 Row Model 및 DOM 측정이 관여하는 고난이도 기능을 처리한다.\n\n- [ ] **PinAwareSorting Feature 구현**\n    - 목표: `createSortableConfig.ts` 제거, 커스텀 `getSortedRowModel`을 Feature `getDefaultOptions`로 주입\n    - 포함: `getSortedRowModel.ts` 로직 이관, pinned row 분리 → 비고정 행 정렬 → 재조합 로직 보존\n    - 검증: 고정 행 위치 보존 확인, 중첩 subRows 재귀 정렬\n\n- [ ] **FilterAwareExpand Feature 구현**\n    - 목표: `createExpandableConfig.ts` 제거, 커스텀 `getExpandedRowModel`을 Feature 기본값으로 주입\n    - 포함: `getExpandedRowModel.ts` 로직 이관, `globalFilter` 활성 시 전체 트리 행 자동 확장\n    - 검증: 검색어 입력 시 모든 트리 노드 확장, 검색어 제거 시 원래 확장 상태 복원\n\n- [ ] **AutoColumnSizing Feature 구현**\n    - 목표: 3-pass 컬럼 너비 분배 알고리즘을 Feature로 이관, `createResizableConfig.ts` 제거\n    - 포함: `useColumnSizing/` 디렉토리 전체 이관, `table.calculateColumnSizing()` API 제공, ResizeObserver 연동은 어댑터(Table.tsx)에서 Feature 메소드 호출\n    - 검증: 컨테이너 리사이즈 시 자동 너비 재계산, explicit/external/auto 컬럼 분류 정확성\n\n- [ ] **PinningStyle Feature 구현**\n    - 목표: `createPinnableConfig.ts` 제거, 고정 행/열 오프셋 계산을 `createRow` / `createColumn`에서 처리\n    - 포함: `tablePinningUtils.ts` 로직 이관, `row.getPinnedRowTopStyle()` / `column.getPinnedColumnOffsetStyle()` API 제공\n    - 검증: 행/열 고정 시 오프셋 스타일 정확성, 9-Grid 레이아웃과 정상 연동\n\n- [ ] **CellMerging Feature 구현**\n    - 목표: `TableHiddenCellProvider` 제거, 셀 병합 상태(`hiddenCellsSet`, `rowSpanMap`)를 `table.getState()`로 이관\n    - 포함: `useTableMerge.ts` + `tableMergeUtils.ts` 로직 이관, `table.getMergeInfo()` / `table.isCellHidden()` / `cell.calculateRowSpan()` API 제공, 계산 결과 Memoization 적용\n    - 검증: rowSpan/colSpan 병합 정확성, 숨김 셀 추적, 가상화 환경에서의 성능 (기존 browser test 통과)\n\n- [ ] **InfiniteScroll Feature 구현**\n    - 목표: `useInfiniteScroll.ts` 로직을 Feature로 이관\n    - 포함: `table.handleInfiniteScroll()` / `table.checkBottomReached()` API 제공, threshold 상태 관리\n    - 검증: threshold 도달 시 `onBottomReached` 콜백 호출, 스크롤 불가능 컨테이너 스킵\n\n---\n\n## Phase 5. 정리 및 마무리\n\n모든 Feature 전환 완료 후, 사용되지 않는 레거시 코드를 제거하고 최종 검증을 수행한다.\n\n- [ ] **`createTableConfig.ts` 및 레거시 Config 함수 제거**\n    - 목표: `createTableConfig.ts` 파일 제거, 남은 `create*Config` 함수 정리\n    - 포함: Pagination / ColumnVisibility는 Custom Feature 없이 옵션 브릿지에서 직접 TanStack 옵션으로 전달하는 구조로 단순화\n    - 검증: `pnpm typecheck` + `pnpm lint` 통과, 미참조 import 없음\n\n- [ ] **사용되지 않는 Hook/Provider/Utils 파일 정리**\n    - 목표: Feature로 이관 완료된 Hook, Provider, Utils 파일 삭제\n    - 포함: 빈 디렉토리 정리, `core/` 디렉토리 내 이관 완료 파일 제거\n    - 검증: `pnpm build` 성공, Storybook 정상 빌드\n\n- [ ] **전체 회귀 테스트 및 타입 정리**\n    - 목표: 모든 기존 테스트 통과 확인, `tanstack-table.d.ts` 타입 확장 최종 검토\n    - 포함: `pnpm test` + `pnpm test:browser` 전체 실행, 호환성 매트릭스 기존 조합 검증\n    - 검증: 전체 테스트 통과, TypeScript strict 모드 에러 없음\n"}
	],
	"edges":[
		{"id":"c770522ba5a9ae9f","fromNode":"4305b2d51eabb4ed","fromSide":"right","toNode":"967de262fc232784","toSide":"left"},
		{"id":"bfde8463d9ec00aa","fromNode":"967de262fc232784","fromSide":"right","toNode":"424bd6a4c662f41c","toSide":"left"},
		{"id":"2de4eb535b3c5d71","fromNode":"424bd6a4c662f41c","fromSide":"right","toNode":"e80db5fc32bcadfb","toSide":"left"}
	]
}