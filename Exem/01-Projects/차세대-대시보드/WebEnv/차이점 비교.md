## 1. 개요 (Executive Summary)
현재 차세대 프로젝트(MaxGauge-VI)는 레거시와 동일한 `WebEnv`라는 저장소 이름을 사용하고 있지만, **데이터의 성격과 활용 패턴은 근본적으로 다릅니다.**

레거시 시스템에서 WebEnv가 큰 문제 없이 운영될 수 있었던 이유는 이를 단순 **'설정(Preference) 저장소'**로 제한적으로 사용했기 때문입니다. 반면, 차세대 시스템은 WebEnv를 **'비정형 NoSQL DB'**처럼 사용하여 관계형 데이터(대시보드-위젯-인스턴스)를 통째로 직렬화하고 있습니다.

이 문서는 **왜 레거시 구조는 안전했으나, 차세대 구조는 데이터 무결성 훼손 및 유지보수 불능 상태로 이어질 수밖에 없는지**를 비교 분석합니다.

---

## 2. 구조적 차이점 비교 (Architecture Comparison)

| 비교 항목                   | 레거시 WebEnv                    | 차세대 WebEnv                                 |
| :---------------------- | :---------------------------- | :----------------------------------------- |
| **저장 목적**               | UI 테마, 언어, 알람 소리 등 **단순 선호도** | 대시보드 구조, 위젯 관계, 인스턴스 스냅샷 등 **핵심 비즈니스 데이터** |
| **저장 단위** (Granularity) | **Key 분산형** (인스턴스별, 기능별 파편화)  | **거대 단일 JSON Blob** (All-in-One)           |
| **참조 방식**               | **ID 참조** (Reference)         | **객체 스냅샷** (Snapshot, 3중 중복 저장)            |
| **동시성**                 | 키가 분리되어 있어 충돌 확률 낮음           | **Last-Write-Wins**. 단 하나의 필드 변경이 전체를 덮어씀  |
| **비유**                  | 서류철에 문서를 나눠서 보관               | 거대한 쓰레기봉투에 모든 물건을 담음                       |

---

## 3. 상세 리스크 분석

### 3-1. 저장 단위의 고립성 (Isolation vs Monolith)

* **레거시:**
    * `EXEM.webEnv.instance` 하위에 `[instanceId]`별로 키가 독립적으로 존재합니다.
    * 특정 인스턴스 데이터가 깨지더라도 해당 인스턴스 설정만 영향을 받으며, 전체 시스템으로 전파되지 않습니다. (**Low Blast Radius**)
* **차세대:**
    * `dashboardStore`라는 단 하나의 키에 모든 대시보드, 위젯, 템플릿 정보가 JSON으로 직렬화됩니다.
    * 위젯 하나의 위치를 1px만 옮겨도 수천 라인의 JSON 전체가 갱신됩니다. 저장 중 오류 발생 시 **사용자의 모든 대시보드 데이터가 증발**할 위험이 있습니다.

### 3-2. 데이터 정합성과 좀비 데이터

* **레거시:**
    * WebEnv에는 주로 플래그(`true/false`)나 스타일 이름만 저장하고, 비즈니스 객체는 런타임에 ID로 조회합니다.
    * 인스턴스가 삭제되어도 WebEnv에 남은 것은 단순 ID 문자열뿐이라 시스템 오류를 유발하지 않습니다.
* **차세대:**
    * `dashboardListInfo`, `widgetState`, `instanceList` 세 곳에 **인스턴스 객체 전체를 복제**해서 저장합니다.
    * **문제점:** 인스턴스 명이나 IP가 변경되어도 WebEnv 내부의 데이터는 갱신되지 않아 **과거의 유령 데이터**를 보여줍니다.
    * **Cascading 부재:** 인스턴스가 삭제될 때, 거대 JSON 문자열 안에 깊숙이 박힌 인스턴스 정보를 찾아 지워주는 로직이 없습니다. 삭제된 인스턴스가 대시보드에 계속 남아 치명적인 렌더링 에러를 유발합니다.

### 3-3. 동시성 제어 및 확장성

* **레거시:**
    * 사용자 A가 테마를 바꾸고, B가 알람 설정을 바꿔도 키가 다르므로(`THEME` vs `SOUND`) 충돌하지 않습니다.
* **차세대:**
    * Zustand Persist가 전체 스토어를 덮어쓰는 방식입니다.
    * 브라우저 탭 1에서 '대시보드 A'를 수정하고, 탭 2에서 '대시보드 B'를 수정하면, 나중에 저장된 내용이 이전 내용을 **완전히 덮어씁니다(Overwrite).**
    * 대시보드 개수가 늘어날수록 Payload 크기가 선형적으로 증가하여 네트워크 부하 및 저장 지연이 발생합니다.

### 3-4. 스키마 마이그레이션

* **레거시:**
    * 단순 Key-Value 구조라 새로운 옵션이 필요하면 키를 추가하면 그만입니다.
* **차세대:**
    * 복잡한 객체 그래프(대시보드→위젯→상태→인스턴스)를 문자열로 저장 중입니다.
    * 위젯 속성명이 변경되거나 구조가 바뀌면, `ALTER TABLE` 없이 수천 명 사용자의 JSON 문자열을 파싱해서 변환해 주는 **고비용의 마이그레이션 스크립트**가 매 배포마다 필요해집니다.

---