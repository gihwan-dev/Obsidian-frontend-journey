## Part 1. On paper

이 예제에서는 실제 앱에 어떻게 FSD를 적용할 수 있는지에 대해 서술한다. 아래는 Medium 클론이며, 글을 쓰고 댓글을 달 수 있는 기능을 제공한다.
![[Pasted image 20250203083401.png]]

작은 앱이기에, 과도한 분리는 지양한다. 전체 앱의 구성이 3 계층으로 나뉠거라 예상된다: **App**, **Pages**, **Shared** 이다.

## 페이지 목록

위 스크린샷을 보고 우리는 다음과 같은 페이지들이 존재할거라 예상할 수 있다:
- Home (article feed)
- Sign in and sign up
- Article reader
- Article editor
- User profile viewer
- User profile editor (user settings)

페이지 계층의 모든 페이지들은 *slice*를 가진다:
```text
📂 pages/
  📁 feed/
  📁 sign-in/
  📁 article-read/
  📁 article-edit/
  📁 profile/
  📁 settings/
```

FSD에서는 페이지가 다른 페이지를 참조할 수 없다. 즉, 페이지에서 다른 페이지의 코드를 불러올 수 없다. 이는 **계층간 임포트 규칙** 때문이다:

> slice 내부의 모듈은 상위 계층에서만 임포트할 수 있다.

같은 계층에서는 임포트할 수 없다.

## 피드 자세히 보기

![[Pasted image 20250203083900.png]]
익명 유저가 볼 수 있는 화면

![[Pasted image 20250203083939.png]]
로그인된 유저가 볼 수 있는 화면

피드 페이지에는 세 가지 동적인 영역이 있다:
1. 로그인 상태에 따른 Sign-in 링크의 가시성
2. 피드에서 필터링을 하기 위한 태그의 리스트
3. 좋아요 버튼을 가진 기사들

sign-in 링크는 헤더의 한 부분이며 모든 페이지에서 공통된다.

### 태그 리스트

태그의 리스트를 만들기 위해서 우리는 사용 가능한 태그들을 fetch 하고, 태그를 칩의 형태로 렌더링 하고, 선택된 태그를 클라이언트 사이드 저장소에 저장해야 한다. 이 각각의 연산은 "API 상호작용", "유저 인터페이스", "스토리지" 로 구분될 수 있다. FSD에서 코드는 목적에 따라 *segments*로 구분된다. *Segments*는 *slice* 내부에 존재하는 폴더로 목적을 서술하는 이름을 가진다. 그리고 이 목적은 보편적이기에 다음과 같은 관습적인 이름이 있다:
- 📂 `api/` 백엔드 인터랙션을 처리하는 코드
- 📂 `ui/` 렌더링과 외관을 처리하는 코드
- 📂 `model/` 스토리지와 비즈니스 로직
- 📂 `config/` 피처 플래그, 환경 변수 그리고 다른 형태의 설정들

우리는 여기서 태그를 fetch하는 코드를 `api`에, 태그 컴포넌트를 `ui`에, 스토리지 상호작용을 `model`에 둘것이다.

### 기사(Article)

같은 그룹핑 원칭을 사용해서, 피드를 분해할 수 있다:

- 📂 `api/`: 페이지별 아티클을 요청하는 함수; 아티클에 좋아요를 누르는 함수
- 📂 `ui/`:
	- 탭리스트 - 태그가 선택되면 추가적인 탭이 나와야 함
	- 각각의 아티클
	- 페이지네이션 기능
- 📂 `model/`: 현재 페이지와 아티클들의 클라이언트 사이드 저장소