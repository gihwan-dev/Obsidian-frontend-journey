*Layers*는 FSD 조직적 계층(organisational hierarchy)의 첫 번째 수준이다. 계층의 목적은 코드가 필요로 하는 책임의 정도와 앱의 모듈들에 대한 의존성의 정도에 따라 코드를 분리하는 것이다. 각 계층은 코드에 얼마나 많은 책임을 할당해야 하는지 결정하는데 도움이되는 특별한 의미를 가지고 있다.

총 **7개의 계층**이 있으며, 가장 많은 책임과 의존성에서 가장 적은 것 순으로 배열되어 있다:
![[Pasted image 20250213091042.png]]

모든 layer를 사용할 필요는 없다. 프로젝트에 필요한 것들만 가져다 사용하면 된다. 주로 대부분의 프론트엔드 프로젝트는 Shared, Pages, App 계층을 가진다.

## layer 에서의 임포트 규칙
Layer는 *Slice*로 구성된다 -- 슬라이스는 높은 응집도를 가진 모듈 그룹이다. 슬라이스간의 의존성은 **계층에 대한 임포트 규칙**에 의해 통제된다.

> 각 slice는 자신보다 아래 계층에 존재하는 slice의 모듈만 임포트 할 수 있다.

예를 들어, `📁 ~/features/aaa` 폴더는 "aaa"라는 이름의 슬라이스다. 그 안의 파일인 `~/features/aaa/api/request.ts`는 `📁 ~/features/bbb`의 어떤 파일도 임포트할 수 없지만, `📁 ~/entities`와 `📁 ~/shared`의 코드는 임포트할 수 있으며, `~/features/aaa/lib/cache.ts`와 같이 `📁 ~/features/aaa` 내의 형제 코드도 임포트할 수 있다.

App과 Shared 계층은 이 규칙의 **예외**다 -- 이들은 동시에 계층이면서 슬라이스다. 슬라이스는 비즈니스 도메인별로 코드를 분할하는데, Shared는 비즈니스 도메인을 가지지 않고, App은 모든 비즈니스 도메인을 결합하기 때문이다.

실제로, App과 Shared 계층은 세그먼트로 구성되어 있으며, 세그먼트들은 서로 자유롭게 임포트할 수 있다는 것을 의미한다.

## 계층 정의
이 섹션에서는 각 계층에 어떤 종류의 코드가 속하는지에 대한 직관을 만들기 위해 각 계층의 의미를 설명한다.

### Shared
이 계층은 앱의 나머지 부분을 위한 기초를 형성한다. 백엔드, 서드파티 라이브러리, 환경 등 외부 세계와의 연결을 생성하는 공간이다. 또한 자체적으로 고도로 독립된 라이브러리를 정의하는 공간이기도 하다.

이 계층은 App 계층과 마찬가지로 슬라이스를 포함하지 않는다. 슬라이스는 계층을 비즈니스 도메인으로 나누기 위한 것이지만, Shared에는 비즈니스 도메인이 존재하지 않는다. 이는 Shared의 모든 파일들이 서로를 참조하고 임포트 할 수 있다는 것을 의미한다.

이 계층에서 일반적으로 찾을 수 있는 세그먼트들은 다음과 같다:
- `📁 api` — API 클라이언트와 특정 백엔드 엔드포인트에 요청을 보내는 함수들이다.
- `📁 ui` — 애플리케이션의 UI 키트다. 이 계층의 컴포넌트들은 비즈니스 로직을 포함해서는 안 되지만, 비즈니스 테마를 가지는 것은 괜찮다. 예를 들어 회사 로고와 페이지의 레이아웃을 여기에 둘 수 있다. UI 로직을 포함한 컴포넌트도 허용된다.
- `📁 lib` — 내부 라이브러리들의 모음이다. 이 폴더는 헬퍼나 유틸리티로 취급되어서는 안된다([[헬퍼 & 유틸이 쓰레기통이 되는 이유]]). 대신, 이 폴더의 모든 라이브러리는 날짜, 색상, 텍스트 조작 등과 같이 하나의 집중된 영역을 가져야 한다. 그리고 그 집중 영역은 README 파일에 문서화되어야 한다. 팀의 개발자들은 이러한 라이브러리들에 무엇을 추가할 수 있고 없는지 알아야 한다.
- `📁 config` — 환경 변수, 전역 기능 플래그 및 앱을 위한 기타 전역 설정이다.
- `📁 routes` — 라우트 상수나 라우트 매칭을 위한 패턴이다.
- `📁 i18n` — 번역을 위한 설정 코드, 전역 번역 문자열이다.

더 많은 세그먼트를 추가할 수 있지만, 이러한 세그먼트의 이름이 내용의 본질이 아닌 목적을 설명하도록 해야한다. 예를들어 `components`, `hooks`, `types`는 코드를 찾을 때 그다지 도움이 되지 않기 때문에 좋지 않은 세그먼트의 이름이다.

## 엔티티
이 계층의 슬라이스들은 프로젝트가 다루는 실제 세계의 개념드를 나타낸다. 일반적으로 비즈니스가 제품을 설명하기 위해 사용하는 용어들이다. 예를들어, 소셜 네트워크는 `User`, `Post`, `Group`와 같은 비즈니스 엔티티들을 다룰 수 있다.

엔티티 슬라이스는 데이터 저장소(`📁 model`), 데이터 유효성 검사 스키마(`📁 model`), 엔티티 관련 API 요청 함수(`📁 api`), 그리고 인터페이스에서의 시각적 표현(`📁 ui`)을 포함할 수 있다. 시각적 표현이 완전한 UI 블록을 생성할 필요는 없다 -- 이는 주로 앱의 여러 페이지에서 동일한 외관을 재사용하기 위한 것이며, 다른 비즈니스 로직은 props나 슬롯을 통해 부착될 수 있다.

### 엔티티 관계
FSD에서 엔터티들은 슬라이스이며, 기본적으로 슬라이스들은 서로를 알 수 없다. 하지만 실제로는 엔티티들이 상호작용하며, 때로는 한 엔티티가 다른 엔티티들을 소유하거나 포함한다. 그래서 이러한 상호작용의 비즈니스 로직은 Features나 Pages와 같은 상위 계층에 두는것이 좋다.

한 엔티티의 데이터 객체가 다른 데이터 객체들을 포함할 때, 일반적으로 `@x` 표기법을 사용한 교차 참조 API를 만들어 엔티티 간의 연결을 명시적으로 만들고 슬라이스 격리를 우회하는 것이 좋은 방법이다. 그 이유는 연결된 엔티티들은 함께 리폭토링되어야 하므로, 그 연결을 놓치지 않도록 하는 것이 가장 좋기 때문이다.

예를들어:
```ts
// entities/artist/model/artist.ts

import type { Song } from "entities/song/@x/artist";

export interface Artist {
  name: string;
  songs: Array<Song>;
}
```

```ts
// entities/song/@x/artist.ts
export type { Song } from "../model/song.ts"
```

`@x` 표기법에 더 자세히 알아보려면 [[Public API]] 섹션을 참조하자.

## Features
이 계층은 유저가 사용하는 앱의 주요 상호작용을 위한 것이다. 이러한 상호작용들은 종종 비즈니스 엔티티들을 포함하는데, 앱이 그런 엔티티들을 다루기 때문이다.

Features 계층을 효과적으로 사용하는데 중요한 원칙중 하나는 **모든것이 feature일 필요는 없다는 것이다.**  어떤 것이 Features가 되어야 하는지에 대한 좋은 지표는 여러 페이지에서의 재사용성이다.

예를들어, 어떤 앱이 여러 에디터를 가지고 있고 모든 에디터에 댓글 기능이 있다면, 댓글은 재사용되는 기능이다. 슬라이스는 코드를 빨리 찾기 위한 매커니즘이라는 것을 기억해라. 너무 많은 Features가 있다면, 중요한 것들이 묻혀버린다.

이상적으로는, 새로운 프로젝트를 시작할 때 *pages*와 *features* 폴더만 둘러보더라도 이 프로젝트가 어떤 기능들을 가지고 있는지 파악할 수 있어야 한다. 어떤 코드를 feature로 분류할지 결정할 때는, 프로젝트에 새로 참여한 개발자가 중요한 코드들이 어디에 있는지 쉽고 빠르게 찾을 수 있도록 구성해야 한다.

feature 슬라이스는 폼과 같은 상호작용을 수행하기 위한 UI(`📁 ui`), 액션을 수행하는데 필요한 API 호출(`📁 api`), 유효성 검사와 내부 상태(`📁 model`), 기능 플래그(`📁 config`)를 포함할 수 있다.

## Widgets
Widgets 계층은 큰 규모의 독립적인 UI 블록들을 위한 것이다. 위젯은 여러 페이지에서 재사용되거나, 한 페이지 안에 여러 개의 큰 독립적인 블록들이 있을 때 그 중 하나로 사용될 때 가장 유용하다. 

만약 UI 블록이 페이지의 주요 콘텐츠 대부분을 차지하고 재사용되지 않는다면, 그것은 **위젯이 되어서는 안되며**, 대신 해당 페이지 내부에 직접 배치되어야 한다.

> [! Tip]
> 중첩 라우팅 시스템(Remix의 라우터와 같은)을 사용하는 경우, Pages 계층이 플랫 라우팅 시스템에서 사용되는 것처럼 Widgets 계층을 사용하면 좋다 -- 데이터 패칭, 로딩 상태, 에러 경계를 포함한 완전한 라우터 블록을 만들기 위해서다.
 
