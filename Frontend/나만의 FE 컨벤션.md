클린코드를 작성하려면 어떤 것들을 생각해야할까? 라는 물음에서 시작해서 내가 생각하는 좋은 구성을 생각하고 정리해 봤습니다.

# 250907
## **나만의 클린 프론트엔드 컨벤션**

좋은 소프트웨어는 쉽게 읽고, 수정하고, 확장할 수 있어야 합니다. 이 문서는 그러한 목표를 달성하기 위해 \*\*'책임의 분리(Separation of Responsibilities)'\*\*라는 핵심 철학을 바탕으로 우리가 지향해야 할 아키텍처와 코드 스타일을 정의합니다.

### **1. 핵심 철학: 높은 응집도와 명확한 경계**

  - **높은 응집도**: "같은 이유로 변경되는 코드는 함께 둔다." 각 기능(페이지, 공통 도메인)에 관련된 코드를 한곳에 모아 관리합니다.
  - **명확한 경계**: 프론트엔드 애플리케이션의 내부 로직과 외부 데이터 통신(API)의 경계를 명확히 분리하여 의존성을 관리합니다.

### **2. 아키텍처: 계층적 기능 구조 (Layered Feature Structure)**

우리 아키텍처는 코드의 재사용 범위에 따라 **Page**, **Feature**, **Common** 이라는 세 가지 주요 계층으로 구성됩니다. 모든 데이터 통신 관련 로직은 별도의 **API** 경계로 분리하여 중앙에서 관리합니다.

```
src/
├── apis/
│   └── user/               # 'user' 도메인 관련 API 경계
│       ├── queries.ts      # useGetUser, useUpdateUser 등 쿼리 훅
│       ├── keys.ts         # 쿼리 키
│       └── api.ts          # fetcher 함수
│
├── features/
│   └── user/               # 2개 이상의 페이지에서 사용되는 'user' 공통 기능
│       ├── components/     # UserProfileCard, UserList 등 공통 UI
│       └── hooks/          # useUserAuth 등 공통 로직 훅
│
├── pages/
│   └── user-profile-page/  # 특정 페이지에만 종속적인 코드
│       ├── components/     # ProfileEditForm 등 이 페이지 전용 컴포넌트
│       ├── UserProfilePage.tsx
│       └── index.ts
│
├── components/
│   └── common/             # Button, Input 등 전역 공용 컴포넌트
└── ...
```

  - **`apis/` (API Boundary)**: 외부 서비스와의 모든 통신을 책임지는 유일한 계층입니다. 백엔드 API 명세와 1:1로 대응하며, 서버 상태 관리(React Query)의 모든 정의(훅, 키, fetcher)를 포함합니다.
  - **`features/` (Shared Domain Layer)**: **두 개 이상의 페이지에서 공통으로 사용되는** 특정 도메인(`user`, `post` 등)의 컴포넌트와 훅이 위치합니다. 예를 들어, '사용자 프로필 카드' 컴포넌트가 프로필 페이지와 관리자 페이지 양쪽에서 사용된다면 `features/user/components/`에 위치합니다.
  - **`pages/` (Composition Layer)**: 특정 라우트(페이지)에만 종속적인 코드를 관리합니다. 이 계층의 주된 역할은 `features`와 `common`의 컴포넌트들을 조합하여 하나의 완전한 페이지를 구성하는 것입니다.
  - **`components/common/` (Global Layer)**: `Button`, `Input`, `Layout` 등 특정 도메인과 무관한, 애플리케이션 전역에서 사용되는 순수 UI 컴포넌트가 위치합니다.

### **3. 역할과 책임 (Roles & Responsibilities)**

각 계층은 명확하게 정의된 책임만을 수행합니다.

#### **컴포넌트 (Components)**

  - **역할**: 오직 **View**와 **Trigger**의 역할만 담당합니다.
  - **책임**:
      - 전달받은 상태(props)를 기반으로 UI를 렌더링합니다.
      - 사용자 인터랙션에 반응하여 이벤트를 발생시킵니다.
      - **내부에 비즈니스 로직을 포함하지 않습니다.** 상태를 변경하는 로직은 모두 훅을 통해 전달받습니다.
  - **설계 패턴**:
      - **컨테이너-프레젠터 패턴**: 페이지 컴포넌트(`UserProfilePage.tsx`)가 컨테이너 역할을 맡아 훅을 호출하고, 하위 컴포넌트들은 프레젠터 역할을 수행합니다.
      - **컴파운드 패턴/아토믹 디자인**: 레이아웃 유연성이 필요할 때, 컴포넌트를 작은 단위로 쪼개고 조합하여 사용합니다.

#### **커스텀 훅 (Custom Hooks)**

  - **역할**: UI와 비즈니스 로직을 연결하는 \*\*컨트롤러(Controller)\*\*입니다.
  - **책임**:
      - `useState`, `useReducer`를 사용하여 컴포넌트의 지역 상태를 관리합니다.
      - `apis` 계층의 쿼리 훅이나 전역 상태 스토어를 호출하여 데이터를 가져옵니다.
      - **이벤트 핸들러의 '내용'을 정의**하여 컴포넌트에 전달합니다.
  - **이벤트 핸들러 처리**:
      - **선언 위치**: 이벤트 핸들러 함수 자체(`const handleClick = () => ...`)는 **컴포넌트 내부에 선언**하여 가독성을 높입니다.
      - **로직 위치**: 핸들러 내부에서는 커스텀 훅에서 반환된 함수(`userActions.updateName(newName)`)를 호출하여 실제 로직을 위임합니다.

<!-- end list -->

```jsx
// pages/user-profile-page/UserProfilePage.tsx
const UserProfilePage = () => {
  const { user, actions } = useUserProfilePage(); // 이 페이지 전용 컨트롤러 훅
  const { data: userFromApi } = useGetUser(userId); // apis 계층의 쿼리 훅

  const handleNameChange = (newName) => { // 핸들러는 컴포넌트에 선언
    actions.updateName(newName); // 실제 로직은 훅에 위임
  };

  return <UserProfileView user={user} onNameChange={handleNameChange} />;
}
```

#### **상태 (State as Data)**

  - **역할**: 상태는 **데이터**로만 취급하며, 그 이상의 역할을 갖지 않습니다.
  - **종류별 책임**:
      - **React Query (Server State)**: `apis` 계층에서 중앙 관리합니다. 데이터 변환은 쿼리 훅의 `select` 옵션을 활용합니다.
      - **Zustand (Global Client State)**: 여러 페이지/기능에서 공유하며 자주 변경되는 클라이언트 상태. **도메인 단위**로 스토어를 분리합니다.
      - **Context API (Global Static State)**: 테마, 사용자 세션 등 거의 변경되지 않는 정적 데이터를 전역으로 제공할 때 사용합니다.
      - **useState/useReducer (Local State)**: 단일 컴포넌트 또는 해당 페이지 내에서만 사용하는 지역 상태.


### **4. 네이밍 및 코딩 스타일**

일관된 스타일은 코드의 가독성을 높입니다.

#### **변수 (Variables)**

  - **일반**: 명사로 작성합니다. (e.g., `user`, `productList`)
  - **Boolean**: `is` 또는 `has`로 시작하여 명확하게 표현합니다. (e.g., `isOpen`, `hasPermission`)

#### **함수 (Functions)**

  - **일반/동작**: 동사로 시작합니다. (e.g., `getUser`, `calculatePrice`)
  - **이벤트 핸들러**: `handle` + (대상) + (동작) 형태로 작성합니다. (e.g., `handleNameInputChange`, `handleSubmitForm`)
  - **Boolean 반환**: `is` 또는 `has`로 시작합니다. (e.g., `isValidEmail`, `hasItems`)

#### **Props**

  - **전달**: 필요한 만큼만 명시적으로 전달합니다. 객체 전체를 불필요하게 넘기지 않습니다.
  - **받기**: 항상 디스트럭처링하여 사용합니다. `const UserProfile = ({ user, onEdit }) => ...`

#### **TypeScript**

  - **`interface` vs `type`**: 객체나 클래스의 형태를 정의할 땐 `interface`를, 그 외 유니언, 인터섹션, 원시 타입 별칭 등에는 `type`을 사용합니다.
  - **타입 추론 활용**: 불필요한 타입 선언을 지양하고, 타입스크립트가 추론할 수 있는 코드를 작성합니다.

#### **Tailwind CSS**

  - **중복 추출 금지**: `@apply` 등을 사용해 스타일을 추출하기보다는, **컴포넌트를 재사용**하여 스타일 중복을 해결합니다.

### **5. 주요 패턴 가이드**

#### **Props Drilling 대처법**

1.  **컴포넌트 구조 개선**: 가장 먼저 \*\*컴포지션(Composition)\*\*을 시도합니다. `children` prop을 활용하거나, 컴파운드 패턴을 적용해 중간 컴포넌트를 거치지 않도록 구조를 개선합니다.
2.  **상태 관리 도구 도입**: 구조 개선으로 해결되지 않고, 여러 컴포넌트에서 공유되는 상태라면 전역 상태(Zustand, Context) 도입을 고려합니다.

#### **공용 컴포넌트 설계**

  - **단일 책임 원칙**: 하나의 공용 컴포넌트는 한 가지 명확한 역할만 수행해야 합니다.
  - **만능 컴포넌트 지양**: `variant`, `mode` 등 수많은 props로 분기하는 컴포넌트는 유지보수를 어렵게 만듭니다. 목적이 다른 경우 별도의 컴포넌트로 분리하는 것이 좋습니다.
---

## **변수**
### 변수 네이밍

**일반적인 경우**

명사로 한다.

**flag 값을 담는 경우**

is 또는 has의 1인칭 동사로 시작한다. 메서드의 경우 동사로 시작하는데, 이 관례와 충돌될 수 있다. 이를 해결하기 위해 flag 변수의 경우 is로 시작하고, flag를 확인하는 메서드인 경우 check로 시작한다.

## **함수**
### 함수 **네이밍**

**일반 함수**

동사로 시작한다.

**이벤트 핸들러**

handle로 시작한다. handle + 도메인 + 동작 으로 정의한다.

**콜백**

콜백은 함수를 통해 드러나는 시그니쳐지, 선언되지 않는다. 그렇기에 onClick 과 같은 형태의 함수는 선언에 사용되지 않고 매개변수를 통해 콜백임을 드러낼 때만 사용한다.

**flag 확인 함수**

앞서 살펴 봤듯이, flag 확인 함수는 check로 시작한다.

### **선언 순서**

함수의 선언 순서는 계층적 구조의 아래에 있는 함수가 가장 위에 와야한다. 즉, 선언 이전에 호출하지 않는다.

### 화살표 함수 사용

함수 선언문이 아닌 화살표 함수를 사용한다.

## Props
### **props에 대한 생각**

props를 어떻게 다뤄야할까?

- props는 함수의 인자다.
- local state는 함수 내부에 선언된 **지역 변수**다.
- 전역 상태, 리액트 쿼리는 함수 내부에 선언된 **전역 변수**다.

### Props drilling
Props의 drilling 같아 보이지만 실제로 그렇지 않은 경우가 많다. 이를 정리해보자.

1. 내려지는 객체의 일부분이 아닌 전체가 계속해서 내려가는 경우
2. 내려지는 객체를 사용하지 않는 컴포넌트가 중간에 있는 경우

이런 경우 첫 번째로 구조적인 문제를 해결해본다. HOC, 컴파운드 패턴 등의 디자인 패턴을 적용해 컴포넌트의 깊이를 끌어올려본다.

컴파운드 패턴 등으로도 해결이 안되는 상황이라면 전역 상태 도입을 고려해본다. 전역 상태 또한 ContextAPI를 사용해서 사용하는 컴포넌트와 생명 주기를 함께할 수 있도록 구성한다.

## 커스텀 훅
## 상태

**상태 관리에 대한 생각**

상태는 데이터다. 다만 변경시 사이드이펙트를 일으키는 전역 변수다. 상태는 다음의 값으로부터 얻어질 수 있다. `React Query`, `Zustand`, `Context API`, `useState` 이에 대해 정리해보자.

- 리액트 쿼리와 zustand는 훅이 아닌 **데이터**로 생각한다.
- 언제 Context API를 사용하고 전역 상태는 언제 사용할까?
    - **Context API**: 값이 자주 변경되지 않는 전역의 어떤 상태를 사용해야 할 경우. (theme provider 등)
    - **전역 상태 관리 라이브러리**: 값이 자주 변경되는 공유되는 어떤 상태를 사용해야 할 경우.
- **dispatch** 함수는 어느정도 역할까지 가능해야 할까?
    - 상태를 변경하는 로직만 수행한다. zustand의 store는 오로지 값으로만 사용하며 dispatch는 상태의 수정만 담당한다.
- **zustand** 스토어는 어느정도 단위여야 하나?
    - 하나의 스토어만 가지게 하라고 한다. 그런데 전역 상태가 많아지면 한 스토어가 너무 비대해지지 않나? => 도메인 단위로 스토어를 가진다.

**컴포넌트에 대한 생각**

- depth가 깊어지는 것에 대한 고민을 해야한다.
- children을 인자로 받는 컴포넌트는 함수를 인자로 받는 **고차 함수** 아닌가? 고차 함수를 사용하면 함수의 depth가 깊어지는 것을 해결할 수 있다.
- props는 있는게 좋다. 깊지만 않다면. 입력과 출력을 명확히 할 수 있어 추적에 용이하다.
- 컴포넌트도 계층 구조를 분리하고 추상화를 해야한다.

**비즈니스 로직 처리하기**

- 커스텀 훅
    - 비즈니스 로직을 수행하자. 커스텀훅은 오로지 컴포넌트에서만 호출될 수 있다. 비즈니스 로직 컨트롤러라 생각하자. 다양한 비즈니스 로직을 조합해 반환한다.
- 일반 함수
    - 비즈니스 로직과 관련된 일반 함수다. 유틸리티 함수의 조합이다.
- 유틸리티 함수
    - 가장 작은 단위의 일을 하는 함수다. 도메인과 관련된 유틸리티함수, 관련되지 않은 유틸리티 함수로 분리된다. 관련되지 않을 경우 공용 함수다. 이럴 경우 데이터를 단위로 함수를 분리할 수 있을것 같다. 관련 되었을 경우 도메인과 관련된 데이터 단위로 분리할 수 있다.

**컴포넌트 계층 구조를 설계해 책임 분리하기**

- 페이지 컴포넌트: 각 컴포넌트를 조합해 페이지를 구성한다. 모듈로 동작하며 어떤 로직도 포함하지 않는다.
- 컴포넌트
    - View 컴포넌트: UI를 그리고 이벤트를 발생시키는 역할을 한다. 이 컴포넌트 내부에 비즈니스 로직이 존재해서는 안된다. 이 컴포넌트는 이벤트를 발생시키고 변경된 상태에 따른 UI를 그리는 역할만을 담당한다.
        - 네이밍 커벤션: [도메인] + View를 붙인다. ex) LoginEmailInputView
    - 모듈 컴포넌트: View 컴포넌트를 적당한 단위로 묶어 필요한 값을 전달해준다. 커스텀 훅에서 처리된 비즈니스 로직의 결과 또는 수행 되어야 하는 이벤트 핸들러 등을 정의해서 View에 전달한다. 존재할 수 있고 존재하지 않을 수 있다. 어떤 컴포넌트가 정적인 `View`의 역할 이외에 다른 역할을 하지 않는다면 `View`면서 동시에 `모듈` 이다. (ex: Layout과 같은)
    - 프로바이더 컴포넌트: ContextAPI를 전달하는 컴포넌트. 페이지 컴포넌트에서 호출된다.
    - 페이지 컴포넌트: 각각의 컴포넌트들을 import해 하나의 페이지를 구성한다.

**컨트롤러 컴포넌트에 의해 관리되는 View 컴포넌트는 어느정도까지의 도메인을 포함해야 하나?**

적절한 기능을 도메인 단위 묶을 수 있지 않을까? 하는 생각이 든다. 로그인 폼을 생각해보자.

로그인 폼은 로그인 기능을 담당한다. 내부에는 다음과 같은 기능이 있을 수 있다.

- 이메일 입력 기능: 이메일 입력, 이메일 유효성 검증, 이메일 입력에 따른 View 처리
- 패스워드 입력 기능: ....
- 로그인 관련 입력 제출 기능: ...

등등이 있을거다. 이 각각의 입력과 관련된 컨트롤러를 만들 수 있다. 다만 이건 오버 엔지니어링이 아닌가? 하는 생각이 든다. 즉, 컨트롤러 컴포넌트는 유사한 기능의 View를 모아 각 View 컴포넌트가 필요한 값을 전달해 주는 역할을 한다. 기능 단위로 분리해 생각해보자. 계속해서 시도해보고 고민해보는게 스스로 정답을 찾을 수 있는 가장 빠른 길인 것 같다.

**공용 컴포넌트 설계하기**

작은 일을 할수록, 도메인에 묶이지 않을수록 재사용성이 높다. 굳이 도메인이 묶일 필요가 없는 컴포넌트 라면 공용 컴포넌트가 될 수 있다.

공용 컴포넌트는 어느정도로 작은일을 해야할까?

- 적절한 수준의 추상화가 필요하다. 작을수록 좋다면 input 태그를 그냥 쓰는게 좋지 않나?
- 무분별한 prop의 확장은 공통 컴포넌트의 가치를 떨어트린다. 만능 컴포넌트를 지양하자. 공통 컴포넌트의 목적은 개발시간 단축과 유지보수 간편화에 있다. prop이 너무 많으면 이를 다루는 로직도 많아지고 더 복잡한 컴포넌트가 된다. 사용하기도 어렵다. 매개변수가 수십개가 있는 함수를 생각해보자. 어떻게 사용하겠는가.

**결론**

최근 `귀에 쏙쏙 들어오는 함수형 프로그래밍` 이라는 책을 읽으면서 함수의 책임 분리와 계층적 설계 같은 것들에 대해 공부했다. 스스로 리액트 아키텍쳐에 대해 고민하고 정리해보니 이 컴포넌트의 설계도 결국 **책임의 분리** 가 목표인 것 같다. 각 컴포넌트, 훅 에 대해 책임을 잘 분리해서 사용하기 쉽고 기능 추가 수정이 쉬운 코드를 작성하자! 가 주 목표인 것 같다.

계속해서 적용하며 이 내용을 수정하고 보완할 예정이다.

**2024.06.18 느낀점**

오늘 이 패턴을 토대로 리팩토링을 진행 해봤다. 다만 잘못 생각한 부분이 있어 정리하고자 한다.

일단 모듈로 기능을 단위로 View 컴포넌트를 묶어내고자 했다. 다만 이게 프론트엔드에서 힘든 경우가 많다는 점이다. 이렇게 묶음의 단위에 기능만 있어서는 안된다. 레이아웃이나 디자인도 고려되어야 한다는게 문제였다. 예를들어보자. 로그인 페이지에 이메일 입력, 패스워드 입력, 제출 버튼이 있다.

기능적으로 묶으면 이메일과 패스워드 입력, 제출 버튼은 하나의 기능 바운더리에 들어갈 수 있다.

그런데 디자인적으로 묶었을 때 입력 두개는 묶일 수 있지만, 버튼은 아니었다. 결국 이를 해결하기 힘들었고 다시 고민하게 되었다. 그러다 `VAC` 패턴이라는걸 발견했다.

그래서 수정했다. `VAC` 패턴과 컴파운드 컴포넌트 패턴 그리고 아토믹 디자인을 적용해 보려 한다. 아토믹하게 디자인해 `VAC` 패턴을 적용하고 이들을 컴파운드 컴포넌트 패턴으로 위치 시킨다. 그러면 어느정도 레이아웃에 자유로우면서도 View 컴포넌트에서 비즈니스 로직을 처리하지 않고 Props 컴포넌트에서 커스텀 훅을 통해 내려줄 수 있다.

**07.02 느낀점**

리팩토링을 진행하며 이벤트 핸들러의 선언 위치와 소모 위치에 대한 고민을 하게 되었다.

이벤트 핸들러는 어디에 선언되어야 할까? 다음 두 패턴에 따라 진행되면 좋겠다는 생각이 들었다.

1. 상태를 중앙집중형으로 관리하는 패턴
2. 상태를 아토믹하게 관리하는 경우

**상태를 중앙 집중형으로 관리하는 경우**

일단 먼저 해야할 이야기는 이벤트 핸들러는 컴포넌트 내부에서 반드시 드러내기로 했다는 점이다. 이벤트 핸들러는 이벤트가 호출되어 일어나는 일들에 대해 기술된 함수다. 일어나는 일들에 대한 내용을 반드시 드러날 필요가 있다고 생각했다. 이전에는 커스텀 훅에서 이벤트 핸들러를 전달하곤 했는데 이는 부적합한 방식이며 오히려 혼란을 야기한다고 생각했다. 너무 많은 이동이 필요하고 컴포넌트에서 한눈에 파악하기 어렵다.

이 내용을 바탕으로 다음을 가정해 보자. Form 이 있고 EmailInput이 있고 PasswordInput이 있다. 그럼 이 Email, Password Input에 대한 이벤트 핸들러는 어디서 정의해서 어떻게 사용해야 할까?

상태값이 어디에 의존적인지에 따라 다르다고 생각이 들었다. 상태값이 외부에 의존적이라면? 외부에서 전달해준다. 그렇지 않다면 내부에 선언한다.

어느정도 고민을 하며 가이드라인이 명시적이여 지는 느낌이 들어 이제 가이드라인을 작성해보려 한다.

**리액트 클린코드 가이드라인**

**네이밍**

**변수**

- 명사로 정의한다.
- 불리언 값을 가지는 경우 `is`, `has` 와 같은 동사가 붙을 수 있다.

**함수**

- 일반 함수
    - 동사로 시작한다.
- 이벤트 핸들러
    - handle~~ 의 형태로 작성한다.
    - 예) handleAccountInputChange 등

**역할 분담**

**컴포넌트 역할**

View 와 Trigger의 역할을 한다. 상태값을 받아 그에 따른 UI를 보여주며 유저와 상호작용하며 이벤트를 호출한다. 컴포넌트 내부에는 최대한 어떤 비즈니스 로직도 적지 않는다. 이벤트 핸들러, 조건문 등만 기술될 수 있다.

**커스텀훅 역할**

비즈니스 로직을 작성한다. 일반 함수와 다른점은 다른 훅을 사용해 비즈니스 로직을 처리해야 할 때 커스텀 훅의 형태로 작성된다.

**상태 = 데이터**

리액트 쿼리, 클라이언트 상태 관리 도구 등을 통해 생성된 상태는 오로지 데이터로만 취급한다. 그 이상의 역할을 하도록 하지 않는다. 리액트 쿼리를 커스텀 훅으로 작성하더라도 그 내부에는 필요하지 않다면 어떠한 로직도 작성하지 않는다.

부차적으로 고민해봐야할 문제들

flag를 반환하는 변수, 함수 네이밍

→ flag 변수의 이름은 checkIs로 시작?

언제 타입을 사용하고 인터페이스를 사용하는지

테일윈드 컨벤션(인라인? 중복 스타일 추출?)

테일윈드 사용시 중복 스타일을 추출하지 않는다. 스타일의 중복을 추출하기 보단 컴포넌트의 공용화를 진행한다.

컴포넌트를 얼마나 분리할지?(의미 부여를 위해 가능한 모든 UI를 분리?

분리한다. 같은 형태라도 분리해서 의미를 부여한다.

함수의 선언 순서

타입은 어디에 어떤 순서로?

팝업 같은 현재는 보이지 않고 절대적인 값을 가져 순서가 레이아웃에 영향을 주지 않는 UI는 가장 아래로

on+ 라는 함수 명으로 함수를 선언하지는 말자. on + 는 콜백임을 드러내는 시그니처로만 활용하자.

타입 선언 순서?

아래에 있는 타입 선언을 받아와 파라미터나 제네릭에 넣어주는거 정말 안좋은듯. 타입이 없어도 추론할 수 있게 하거나, 공용으로 분리하자.

어떤 컴포넌트가 값을 전달받아야 한다면 딱 필요한 만큼만 시그니처로 노출시키자. 그래서 조금 더 확장성 있고 수정에 용이하다.

객체는 디스트럭처링을 사용한다.

React Query, Zustand는 엔터티 계층에서 사용 가능한 정도의 간단한 기능만 한다.

복잡한 여러 객체가 연관 관계를 가지게 하지 말자(어떤 객체의 값이 다른 객체의 키값이 된다거나 하는 그런 상황). 데이터의 각 키값들에 대한 의미를 추적하기 어렵게 만든다. 여러 객체가 연관 관계를 가져야 한다면 그 사용 컴포넌트에서 계산되어서 사용되어야 한다.

---

## 참고자료

[https://ui.toast.com/fe-guide/ko](https://ui.toast.com/fe-guide/ko)

[https://frontend-fundamentals.com/code/examples/use-user.html](https://frontend-fundamentals.com/code/examples/use-user.html)