HTML 파서는 HTML 마크업을 파싱 트리로 변환한다.

## HTML 문법 정의

HTML의 어휘와 문법은 W3C에 의해 명세로 정의되어 있다. [링크](https://html.spec.whatwg.org/#toc-introduction)

## 문맥 자유 문법이 아니다

HTML은 파서가 요구하는 문맥 자유 문법에 의해 쉽게 정의할 수 없다. HTML 정의를 위한 공식적인 형식으로 [[DTD (Document Type Definition)]]가 있지만 이것은 문맥 자유 문법이 아니다.

XML과 HTML은 유사하고 XML 파서는 많다. 어떤 차이점이 파싱에서의 차이점을 만들어 냈을까?

HTML이 더 "너그럽다"는 점이다. HTML은 암묵적으로 태그에 대한 생략이 가능하다.

이 작은 차이 때문에 HTML은 파싱하기 어렵고 전통적인 구문 분석이 블가능 하기 때문에 문맥 자유 문법이 아니게 된다.

## HTML DTD

HTML의 정의는 [[DTD (Document Type Definition)]] 형식 안에 있는데 [[SGML]] 계열 언어의 정의를 이용한 것이다. HTML DTD는 문맥 자유 문법이 아니다.

## DOM

"파싱 트리"는 DOM 요소와 속성 노드의 트리로서 출력 트리가 된다. 이는 HTML 문서의 객체 표현이고 외부를 향하는 자바스크립트와 같은 HTML 요소의 연결 지점이다. 트리의 최상위 객체는 `document`다.

DOM은 마크업과 1:1 관계를 갖는다. 아래 마크업은
```html
<html>
	<body>
		<p>Hello Worle<p>
		<div>
			<img src="exemple.png" />
		</div>
	</body>
</html>
```

아래의 DOM 트리로 변환된다.

![[Pasted image 20241129174430.png]]

## 파싱 알고리즘

HTML은 일반적인 하향식 또는 상향식 파서로 파싱이 안된다. 그 이유는 다음과 같다.

1. 언어의 너그러운 속성
2. HTML 오류에 대한 브라우저의 관용
3. 변경에 의한 재파싱. 일반적으로 소스는 파싱하는 동안 변하지 않지만 HTML에서 `document.write`를 포함하고 있는 스크립트 태그는 토큰을 추가할 수 있기 대문에 입력 과정에서 파싱이 수정된다.

브라우저는 HTML 파싱을 위해 별도의 파서를 생성한다.

[파싱 알고리즘은 HTML에 자세히 설명되어 있다.](https://html.spec.whatwg.org/multipage/parsing.html#parsing) 알고리즘은 크게 토큰화와 트리 구축 두 단계로 되어 있다.

### 토큰화

어휘 분석으로서 입력 값을 토큰으로 파싱한다. HTML 문서를 의미 있는 최소 단위(토큰)로 나누는 과정이다. 다음과 같은 토큰이 존재한다.

- **DOCTYPE 토큰**: `<!DOCTYPE html>`
- **시작 태그 토큰**: `<div>`, `<p>` 등
- **종료 태그 토큰:** `</div>`, `</p>` 등
- **주석 토큰:** `<!-- 주석 -->`
- **문자 토큰:** 일반 텍스트
- **파일 끝 토큰:** 문서의 끝을 나타냄

토큰화는 다음과 같은 특징을 가진다.

- [[상태 기계 방식]]으로 동작
- 기본 상태 (data state)에서 시작
- 한 번에 한 문자씩 처리
- 문자를 읽으면서 상태가 계속 변화 ([[HTML 토큰 상태 목록]])

다음과 같은 중요한 포인트를 가진다.

- 토큰 생성과 방출은 별개
	- 토큰이 만들어 졌다고 항상 사용되는건 아니다. (파일이 갑자기 끝나면 만들던 토큰은 버려질 수 있다.)
- 태그 토큰의 특성
	- self-closing 플래그를 가진다. (`<img />`)
	- 속성을 가진다.
	- 이름 정보를 포함한다.
- 오류 상황들
	- self-closing이 잘못 사용된 경우
	- 종료 태그에 속성이 있는 경우
	- 종료 태그에 self-closing이 있는 경우

### 토큰화 알고리즘

앞서 말한것 처럼 토큰화는 [[상태 기계 방식]]으로 동작한다. 간단하게 예제를 통해 알아보자.

```html
<div>content</div>
```

위 태그를 예시로 알아본다. 다음과 같은 과정을 통해 토큰화가 진행된다.


| 순번  | 입력                   | 상태                 | 행동                                                                                                               |
| --- | -------------------- | ------------------ | ---------------------------------------------------------------------------------------------------------------- |
| 0   | `<div>content</div>` | Data State         | 다음 문자를 소비한다. `<` 문자를 소비하고 상태를 `Tag Open State`로 변경한다.                                                            |
| 1   | `div>content</div>`  | Tag Open State     | 다음 문자를 소비한다. `ASCII alpha`를 만나면 새로운 open 태그 토큰을 만들고 `Tag Name State` 상태로 계속해서 문자를 소비하며 태그 이름을 갱신한다(lower case로). |
| 2   | `>content</div>`     | Tag Name State     | 다음 문자를 소비한다. `>` 문자를 만나면 `Data State`로 변경하고 현재 태그 토큰을 방출한다(트리 생성자로).                                             |
| 3   | `content</div>`      | Data State         | 다음 문자를 소비한다. `&`, `<`, `NULL`, `EOF` 가 아니라면 현재 입력 문자를 문자 토큰으로 방출한다.                                              |
| 4   | `</div>`             | Data State         | 다음 문자를 소비한다. `<`를 만났기에, `Tag Open State`로 변경한다.                                                                  |
| 5   | `/div>`              | Tag Open State     | 다음 문자를 소비한다. `/` 문자를 만나면 `End Tag Open State`로 변경된다.                                                             |
| 6   | `div>`               | End Tag Open State | 다음 문자를 소비한다. `ASII alpha`를 만나면 새로운 end 태그 토큰을 만든다. `Tag Name State`로 변경되고 계속해서 문자를 소비하며 이름을 갱신한다.                |
| 7   | `>`                  | Tag Name State     | 다음 문자를 소비한다. `>` 문자를 만나면 현재 태그 토큰을 방출한다.                                                                         |

### 트리 구축 알고리즘

트리 구축 단계는 토큰화 단계에서 생성된 토큰을 입력으로 받는다. 파서가 생성될 때 DOM이 생성되고 트리 구축 단계는 DOM 객체와 연결된다. 트리 구축 단계에서는 동적으로 DOM이 확장되거나, 수정된다.

DOM 트리에 요소를 추가하는 것이 아니라면 [[열린 요소]]는 스택(임시 버퍼 저장소)에 추가된다. 이 스택은 부정확한 중첩과 종료되지 않은 태그를 교정한다. 알고리즘은 상태 기계라고 설명할 수 있고 상태는 "삽입 모드"라고 부른다.

아래 예제의 트리 생성 과정을 보자.
```html
 <html>
   <body>
      Hello world
   </body>
</html>  
```


| 순서  | 입력                | 상태         | 동작                                                            |
| --- | ----------------- | ---------- | ------------------------------------------------------------- |
| 0   | html 시작           | html 이전 모드 | HTMLHtmlElement 요소를 생성하고 문서 객체 최상단에 추가한다.                     |
| 1   | body 시작           | head 이전    | "head" 토큰이 없더라도 HTMLHeadElement는 묵시적으로 생성되어 트리에 추가된다.         |
| 2   | -                 | head 안쪽    | body 토큰을 처리해야 함으로 head 안쪽 모드로 변경한다.                           |
| 3   | -                 | head 다음    | body 토큰을 처리하고 HTMLBodyElement를 생성해 추가한다. 이후 body 안쪽 모드로 변경한다. |
| 4   | Hello World 문자 토큰 | body 안쪽    | HTMLTextNode를 생성하고 문자들을 추가한다.                                 |
| 5   | body 끝            | body 다음    | -                                                             |
| 6   | html 끝            | body 다음 다음 | -                                                             |
| 7   | eof               | -          | 파싱 종료                                                         |

## 파싱이 끝난 이후의 동작

브라우저가 문서의 파싱을 종료하면 다음 단계들이 일어난다:

1. 문서와 상요작용 할 수 있게 된다.
2. 열린 요소 스택의 모든 노드들이 pop 된다.
3. 실행이 "지연"된 스크립트들을 파싱하고 실행시킨다.
4. `DOMContentLoaded` 이벤트를 발생시킨다.

## 브라우저의 오류 처리

HTML 에서는 파서가 실수를 수정해준다. 파서는 다음과 같은 오류를 처리해야 한다.

1. 태그 안쪽에 추가하려는 태그가 금지된 것일 때 허용된 태그를 먼저 닫고 금지된 태그를 외부에 추가한다. (table 안에 table, form 내부의 form)
2. 파서가 직접 요소를 추가해서는 안된다. 생략 가능한 경우도 있기 때문. (HTML, HEAD, BODY, TBODY, TR, TD, LI)
3. 인라인 요소 안쪽에 블록 요소가 있는 경우 부모 블록 요소를 만날 때까지 모든 인라인 태그를 닫는다. (span 안의 div)
4. 이 방법들이 도움이 되지 않으면 태그를 추가하거나 무시할 수 있는 상태가 될 때까지 요소를 닫는다.
