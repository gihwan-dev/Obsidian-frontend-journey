브라우저에 동적 기능을 추가하기 위해 도입된 언어이다. Java와 아무 관련이 없다.

TC39에서 지정하고 ECMA 표준 기관에서 공식화한 언어의 공식 이름은 ECMAScript이다. 2016년부터 공신 언어 이름 뒤에 개정 연도가 추가되었다.

> [!info] TC39를 모른다면 [[TC39]]에 설명해 두었다.

즉, 브라우저나 Node.js 에서 실행되는 JavaScript/JS 는 ES<년도> 표준을 구현한 것이다.

TC39 위원회는 브라우저 제조업체(Mozila, Google, Apple) 및 장치 제조업체(삼성 등) 등 광범위한 웹 투자기업의 50 ~ 100명으로 구성된다. 위원회의 모든 구성원은 자원봉사 이지만 이들 중 다수는 이들 회사의 직원이므로 위원회 업무에 대한 부분적인 보상을 받을 수 있다.

TC39는 일반적으로 격월로, 보통 약 3일동안 회의를 열어 지난 회의 이후 회원들이 수행한 작업을 검토하고, 문제를 논의하고, 제안에 대해 투표한다. 회의 장소는 주최 하려는 회원사 간에 순환된다.

모든 TC39 제안은 5단계 프로세스를 통해 진행된다. 0부터 4단계 까지다.

0단계는 대략적으로 TC39의 누군가가 그것이 가치 있는 아이디어라고 생각하고 이를 옹호하고 작업할 계획을 가지고 있음을 의미한다. 즉, TC39 회원이 아닌 소셜 미디어나 블로그 게시물과 같은 비공식적 수단을 통해 '제안(propose)'하는 많은 아이디어가 실제로는 '0단계 전' 이라는 의미이다. 공식적으로 "0단계"로 간주 되려면 제안을 옹호할 TC39 회원을 확보해야 한다.

제안서가 "4단계" 상태에 도달하면 다음 연간 언어 개정판에 포함될 수 있다. 제안서가 이러한 단계를 통과하는 데는 몇 달에서 몇 년이 걸릴 수 있다.

[모든 제안은 TC39의 Github 저장소](https://github.com/tc39/proposals)에서 공개적으로 관리된다.

### 웹은 (JS)에 관한 모든 것을 지배한다.
JS를 실행하는 다양한 환경이 지속적으로 확장되고 있지만(브라우저에서 서버(Node.js), 로봇, ...) JS를 지배하는 유일한 환경은 웹이다. 즉, JS가 웹 브라우저에 어떻게 구현되는지가 현실적으로 중요한 현실이다.

대부분의 경우 사양에 정의된 JS와 브라우저 기반 JS 엔진에서 실행되는 JS는 동일한다. 그러나 고려해야 할 몇 가지 차이점이 있다.

때로는 JS 사양이 새롭거나 개선된 동작을 지시하지만 이는 브라우저 기반 JS 엔진에서 작동하는 방식과 정확이 일치하지 않는다. 따라서 때때로 JS엔진은 해당 웹 콘텐츠가 손상될 수 있다는 이유로 사양에 따른 변경 사항을 따르기를 거부한다.

이러한 경우 TC39는 웹의 현실에 맞게 사양을 따르도록 선택한다. `includes(..)`, `flat(..)` 등이 있다.

### 모든 웹이 JS는 아니다.
다음 코드가 JS 프로그램인가?
```javascript
alert("Hello, JS!");
```
어떻게 보느냐에 따라 다르다. `alert(..)` 함수는 JS 사양에는 포함되어있지 않다. 하지만 모든 웹 JS 환경에는 포함되어 있다. 

다양한 JS 환경(예: 브라우저 JS 엔진, Node.js 등)은 JS 프로그램의 전역 범위에 API를 추가하여 사용자 브라우저에 경고 스타일 상자를 표시하는 것과 같은 환경별 기능을 제공한다.

`fetch(..)`, `getCurrentLocation(..)`, `getUserMedia(..)`, 등의 다양한 JS 모양의 API는 모두 JS처럼 보이는 웹 API이다. Node.js 에서는 `fs.write(..)` 등이 있다.

또 다른 일반적인 예는 `console.log(..)` 가 있다. 이는 JS에 저장되어 있지 않지만 보편적인 유틸리티로 인해 대략적으로 합의된 합의에 따라 거의 모든 JS 환경에서 정의된다.

### 항상 JS는 아니다.
브라우저의 개발자 도구(또는 노드)에서 콘솔/REFL(Read-Evaluate-Print-Loop)을 사용하는 것은 언뜻 보면 매우 간단한 JS 환경처럼 느껴진다. 하지만 실제로는 그렇지 않다.

개발자 도구는 개발자를 위한 도구이다. 그들의 주요 목적은 개발자의 삶을 더 쉽게 만드는 것이다. 그들은 DX(Developer Experience)를 우선시한다. 엄격한 사양 JS 동작의 모든 뉘앙스를 정확하고 순수하게 반영하는 것은 이러한 도구의 목표가 아니다. 따라서 콘솔을 순수 JS환경으로 취급하는 경우 "문제"로 작용할 수 있는 문제가 많이 있다.

다양한 JS 콘솔 환경의 다양한 지점에서 실제로 있었던 몇 가지 이상한 예에 대해 힌트를 주고 이를 사용하는 동안 기본 JS 동작을 가정하지 않는 것에 대한 요점을 강화해보자.
- `var`, `function` 등을 콘솔에서 전역범위로 선언했을 때 실제로 전역 변수를 만드지
- 전역 변수로 `let`, `const` 를 여러개 선언하면 어떤 일이 일어나는가
- `"use strict";` 를 입력하면 콘솔에서 strict mode 가 적용되는지
- non-strict 모드에서 [[this]]의 default-binding 이 함수 호출에 대해 어떻게 동작하는지, 그리고 "전역 객체"에 사용된 전역 변수가 포함되는지.
- multiple line entries에 호이스팅이 어떻게 동작하는지
- ...등등

개발자 콘솔에서 JS가 정확하게 동작해야 하는 방식대로 동작하기를 바라지 마라. 대신 콘솔을 "JS-friendly"한 환경으로 생각해라.
### Many Faces
[[paradigm]]이라는 용어는 프로그래밍에서 코드를 구축하는 마인드셋을 의미한다. 패러다임 내에는 주어진 코드에 고유한 signature를 남기는 프로그램을 구별하는 수많은 형태와 스타일의 프레임워크와 라이브러리들이 있다.

그러나 프로그램의 개별 스타일이 무엇이든 관계없이 패러다임을 둘러싼 큰 그림의 구분은 프로그램을 처음 보면 거의 항상 분명하게 드러난다.

일반적인 패러다임 수준 코드의 범주에는 절차적, 객체지향프로그래밍(OOP), 함수형 프로그래밍(FP)이 포함된다.
- Directive Programming은 하향식, 선형 진행 박식으로 코드를 구성하며 일반적으로 절차라는 관련 단위로 함께 수집된다.
- OOP 스타일은 논리와 데이터를 클래스라는 단위로 함께 수집하여 코드를 구성한다.
- FP 스타일은 코드를 함수(프로시저가 아닌 순수 계산)로 구성하고 해당 함수를 값으로 적용한다.

패러다임은 옳지도 그르지도 않다. 프로그래머가 솔루션에 접근하는 방법, 코드를 구성하고 유지하는 방법을 안내하고 형성하는 방향이다.

일부 언어는 하나의 패러다임에 크게 치우쳐 있다. C는 절차적이며, Java/C++은 거의 전적으로 클래스 지향적이며, Haskell은 철저하게 FP이다.

그러나 많은 언어는 서로 다른 패러다임에서 나올 수 있고 심지어 혼합하고 일치할 수도 있는 코드 패턴을 지원한다.

JavaScript는 확실히 다중 패러다임 언어이다. 절차적, 클래스 지향 또는 FP 스타일 코드를 작성할 수 있으며 전부 아니면 전무의 선택을 강요당하는 대신 한 줄씩 결정을 내릴 수 있다.

### Backwards & Forwards
JavaScript를 대표하는 가장 기본적인 원칙 중 하나는 이전 버전과의 호환성을 유지하는 것이다.

이전 버전과의 호환성이란 일단 유요한 JS로 승인되면 해당 코드가 유효하지 않은 JS가 되도록 하는 언어 변경이 앞으로 발생하지 않는다는 것을 의미한다. 1995년에 작성된 코드는 아무리 원시적이거나 제한적이었더라도 오늘날에도 여전히 작동한다.

