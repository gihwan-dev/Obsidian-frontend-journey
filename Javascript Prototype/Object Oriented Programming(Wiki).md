## 객체 지향 프로그래밍 (Object-oriented programming, OOP)

객체 지향 프로그래밍(OOP)은 *객체* 개념에 기반한 프로그래밍 패러다임입니다. 객체는 데이터와 코드를 포함할 수 있습니다: 데이터는 필드(흔히 속성 또는 프로퍼티라고 알려진) 형태로, 코드는 프로시저(흔히 메서드라고 알려진) 형태로 존재합니다. OOP에서 컴퓨터 프로그램은 서로 상호작용하는 객체들로 구성됩니다.

C++, Java, Python과 같은 가장 널리 사용되는 프로그래밍 언어 대부분은 다중 패러다임을 지원하며, 일반적으로 명령형 프로그래밍과 선언형 프로그래밍을 조합하여 다양한 정도로 객체 지향 프로그래밍을 지원합니다.

## 역사
현대적 의미의 객체 지향 프로그래밍에서 "객체"라는 용어는 1950년대 후반과 1960년대 초반 MIT의 인공지능 그룹에서 처음 등장했습니다. "객체"는 식별된 속성(attributes)을 가진 LISP 원자(atoms)를 의미했습니다. 또 다른 초기 MIT 사례는 1960-1961년 Ivan Sutherland가 만든 Sketchpad입니다. Sketchpad에 관한 그의 학위 논문을 기반으로 한 1963년 기술 보고서의 용어집에서, Sutherland는 "객체"와 "인스턴스"의 개념을 정의했습니다(클래스 개념은 "마스터" 또는 "정의"로 다루어짐). 다만 이는 그래픽 상호작용에 특화되어 있었습니다. 또한 1968년, MIT의 ALGOL 버전인 AED-0는 데이터 구조("plexes"라고 불림)와 프로시저 사이에 직접적인 연결을 확립했는데, 이는 나중에 "메시지", "메서드", "멤버 함수"라고 불리게 된 것을 예견했습니다. 이 시기에는 데이터 추상화와 모듈식 프로그래밍과 같은 주제가 일반적인 논의 대상이었습니다.

Simula는 AED와 같은 MIT의 후기 작업과는 독립적으로 1961-1967년 사이에 개발되었습니다. Simula는 클래스와 객체, 상속, 동적 바인딩과 같이 오늘날 객체 지향 프로그래밍의 필수적인 부분이 된 중요한 개념들을 도입했습니다. 객체 지향 Simula 프로그래밍 언어는 주로 선박과 그 화물이 항구를 통과하는 움직임을 연구하고 개선하기 위한 모델과 같은 물리적 모델링에 관여한 연구자들에 의해 사용되었습니다. Simula는 일반적으로 객체 지향 언어의 주요 특징과 프레임워크를 갖춘 최초의 언어로 인정받고 있습니다.

MIT의 작업과 Simula 언어의 영향을 받아, 1966년 11월 Alan Kay는 후에 Smalltalk 프로그래밍 언어에 통합될 아이디어에 대한 작업을 시작했습니다. Kay는 1967년만큼 이른 시기에 대화에서 "객체 지향 프로그래밍"이라는 용어를 사용했습니다. 비록 때로는 "객체 지향 프로그래밍의 아버지" 라고 불리지만, Alan Kay는 자신의 OO 개념을 더 전통적인 추상 데이터 타입 개념의 객체와 차별화했으며, 컴퓨터 과학계가 그의 개념을 채택하지 않았음을 암시했습니다. Barbara Liskov가 공동 저자로 참여한 1976년 MIT 메모는 Simula 67, CLU, Alphard를 객체 지향 언어로 나열했지만, Smalltalk는 언급하지 않았습니다.

1970년대에는 Alan Kay, Dan Ingalls, Adele Goldberg에 의해 Xerox PARC에서 Smalltalk 프로그래밍 언어의 첫 번째 버전이 개발되었습니다. Smalltalk-72는 프로그래밍 환경을 포함하고 동적 타입을 가졌으며, 처음에는 컴파일되지 않고 인터프리터 방식이었습니다. Smalltalk는 언어 수준에서의 객체 지향 적용과 그래픽 개발 환경으로 주목받게 되었습니다. Smalltalk는 다양한 버전을 거쳐 발전했고 이 언어에 대한 관심이 증가했습니다. Smalltalk는 Simula 67에서 소개된 아이디어의 영향을 받았지만, 클래스를 동적으로 생성하고 수정할 수 있는 완전한 동적 시스템으로 설계되었습니다. 다중 상속과 같은 OOP 이론의 많은 부분이 Smalltalk의 맥락에서 개발되었습니다.

1970년대 후반과 1980년대 동안 객체 지향 프로그래밍이 두각을 나타내기 시작했습니다. Flavors 객체 지향 Lisp는 1979년부터 개발되기 시작했으며, 다중 상속과 믹스인을 도입했습니다. 1981년, Goldberg는 Byte Magazine의 8월호를 편집하여 Smalltalk와 객체 지향 프로그래밍을 광범위한 독자층에 소개했습니다. Interlisp-D를 위한 객체 시스템인 LOOPS는 Smalltalk와 Flavors의 영향을 받았으며, 이에 관한 논문이 1982년에 발표되었습니다. 1986년, 미국 컴퓨터학회(ACM)는 첫 번째 *객체 지향 프로그래밍, 시스템, 언어 및 응용 프로그램 컨퍼런스*(OOPSLA)를 조직했으며, 1,000명이 참석했습니다. 다른 개발 중에는 Common Lisp Object System이 있었는데, 이는 함수형 프로그래밍과 객체 지향 프로그래밍을 통합했으며 메타-객체 프로토콜을 통한 확장을 허용했습니다. 1980년대에는 메모리 내 객체에 대한 하드웨어 지원을 포함하는 프로세서 아키텍처를 설계하려는 몇 가지 시도가 있었지만 성공하지 못했습니다. 그 예로는 Intel iAPX 432와 Linn Smart Rekursiv가 있습니다.

1980년대 중반에는 Brad Cox가 Objective-C를 개발했는데, 그는 ITT Inc.에서 Smalltalk를 사용한 경험이 있었습니다. 박사 논문에서 Simula를 사용했던 Bjarne Stroustrup은 객체 지향 언어인 C++를 만들었습니다.1985년, Bertrand Meyer는 Eiffel 언어의 첫 번째 설계를 완성했습니다. 소프트웨어 품질에 초점을 맞춘 Eiffel은 순수한 객체 지향 프로그래밍 언어이며 전체 소프트웨어 생명주기를 지원하는 표기법입니다. Meyer는 소프트웨어 공학과 컴퓨터 과학의 핵심 아이디어를 기반으로 한 Eiffel 소프트웨어 개발 방법론을 "Object-Oriented Software Construction"에서 설명했습니다. Eiffel의 품질 중심 접근방식에서 핵심적인 것은 Meyer의 신뢰성 메커니즘인 계약에 의한 설계(design by contract)로, 이는 방법론과 언어 양쪽에 통합된 부분입니다.

1990년대 초반과 중반에는 이러한 기술을 지원하는 프로그래밍 언어들이 널리 보급되면서 객체 지향 프로그래밍이 지배적인 프로그래밍 패러다임으로 발전했습니다. 이러한 언어에는 Visual FoxPro 3.0, C++, 그리고 Delphi가 포함되었습니다. 객체 지향 프로그래밍 기법에 크게 의존하는 그래픽 사용자 인터페이스의 인기가 높아지면서 그 지배력은 더욱 강화되었습니다. 관련된 동적 GUI 라이브러리와 OOP 언어의 예로는 Mac OS X의 Cocoa 프레임워크를 들 수 있는데, 이는 Smalltalk를 기반으로 한 C의 객체 지향적이고 동적 메시징 확장인 Objective-C로 작성되었습니다. OOP 툴킷은 또한 이벤트 중심 프로그래밍의 인기를 높였습니다(이 개념이 OOP에만 국한된 것은 아닙니다).

ETH Zürich에서는 Niklaus Wirth와 그의 동료들이 모듈 경계를 넘어서는 타입 검사의 개념을 연구했습니다. Modula-2(1978)는 이 개념을 포함했으며, 그들의 후속 설계인 Oberon(1987)은 객체 지향, 클래스 등에 대한 독특한 접근 방식을 포함했습니다. Wirth의 설계에서는 상속이 명확하게 드러나지 않는데, 이는 그의 명명법이 반대 방향을 바라보기 때문입니다: 이것은 타입 확장(type extension)이라고 불리며, 관점이 부모에서 상속자로 내려가는 방식입니다.

객체 지향 기능은 Ada, BASIC, Fortran, Pascal, COBOL을 포함한 많은 기존 언어에 추가되었습니다. 처음에 이러한 기능을 위해 설계되지 않은 언어에 이러한 기능을 추가하는 것은 종종 코드의 호환성과 유지보수성에 문제를 일으켰습니다.

최근에는 주로 객체 지향적이면서도 절차적 방법론과 호환되는 일부 언어들이 등장했습니다. 이러한 언어로는 Python과 Ruby가 있습니다. 아마도 상업적으로 가장 중요한 최근의 객체 지향 언어는 Sun Microsystems에서 개발한 Java와 Microsoft의 .NET 플랫폼을 위해 설계된 C# 및 Visual Basic.NET(VB.NET)일 것입니다. 이 두 프레임워크는 각각 구현에서 추상화를 생성함으로써 OOP 사용의 이점을 보여줍니다. VB.NET과 C#은 크로스 언어 상속을 지원하여 한 언어로 정의된 클래스가 다른 언어로 정의된 클래스를 서브클래싱할 수 있게 합니다.

## 특징
객체 지향 프로그래밍은 객체를 사용하지만, OOP를 지원한다고 주장하는 모든 언어에서 관련된 모든 기술과 구조가 직접 지원되는 것은 아닙니다. 아래 나열된 특징들은 강력한 클래스 및 객체 지향적(또는 OOP 지원이 있는 다중 패러다임) 언어로 간주되는 언어들 사이에 공통적이며, 주목할 만한 예외가 언급되어 있습니다. Christopher J. Date는 OOP와 다른 기술, 특히 관계형 기술 간의 중요한 비교가 OOP에 대한 합의된 엄격한 정의의 부재로 인해 어렵다고 말했습니다.

### **비-OOP 언어와 공유되는 특징**
* 정수와 영숫자 문자와 같은 소수의 내장 데이터 타입으로 포맷된 정보를 저장할 수 있는 변수들. 여기에는 문자열, 리스트, 해시 테이블과 같이 내장되어 있거나 메모리 포인터를 사용하여 변수를 결합한 결과로 얻어지는 데이터 구조가 포함될 수 있습니다.
* 프로시저 - 함수, 메서드, 루틴 또는 서브루틴이라고도 알려진 - 는 입력을 받고, 출력을 생성하며, 데이터를 조작합니다. 현대 언어들은 루프와 조건문과 같은 구조적 프로그래밍 구성을 포함합니다.
* 모듈식 프로그래밍 지원은 구성적 목적을 위해 프로시저를 파일과 모듈로 그룹화하는 기능을 제공합니다. 모듈은 네임스페이스화되어 있어 한 모듈의 식별자가 다른 파일이나 모듈에서 같은 이름을 공유하는 프로시저나 변수와 충돌하지 않습니다.

### **객체**
객체는 필드(데이터를 포함하는 상태 변수)와 메서드(코드에서 객체의 동작을 정의하는 서브루틴 또는 프로시저)를 포함하는 데이터 구조 또는 추상 데이터 타입입니다. 필드는 멤버, 속성 또는 프로퍼티라고도 알려져 있습니다. 객체는 일반적으로 연속된 메모리 영역으로 저장됩니다. 객체는 복잡한 내부 구조를 가진 변수와 유사하게 접근되며, 많은 언어에서는 실질적으로 포인터로 작동하여 힙이나 스택 내의 메모리에 있는 해당 객체의 단일 인스턴스에 대한 실제 참조 역할을 합니다.

객체는 때때로 현실 세계에서 발견되는 것들과 일치합니다. 예를 들어, 그래픽 프로그램은 "원", "사각형", "메뉴"와 같은 객체를 가질 수 있습니다. 온라인 쇼핑 시스템은 "쇼핑 카트", "고객", "제품"과 같은 객체를 가질 수 있습니다. 때로는 객체가 열린 파일을 나타내는 객체나 미국 관습 단위에서 미터법으로 측정값을 변환하는 서비스를 제공하는 객체와 같이 더 추상적인 개체를 나타내기도 합니다.

객체는 자신의 인스턴스 변수 안에 다른 객체를 포함할 수 있습니다; 이를 객체 구성(object composition)이라고 합니다. 예를 들어, Employee 클래스의 객체는 "first_name"과 "position"과 같은 자체 인스턴스 변수 외에도 Address 클래스의 객체를 (직접 또는 포인터를 통해) 포함할 수 있습니다. 객체 구성은 "has-a" 관계를 표현하는 데 사용됩니다: 모든 직원은 주소를 가지고 있으므로, 모든 Employee 객체는 Address 객체를 저장할 장소에 접근할 수 있습니다(직접 내장되어 있거나 포인터를 통해 접근되는 별도 위치에 있음). Date와 Darwen은 RDBMS를 지원하기 위해 OOP를 일종의 사용자 정의 가능한 타입 시스템으로 사용하는 이론적 기반을 제안했지만, 이는 객체 포인터를 금지합니다.

OOP 패러다임은 소프트웨어 설계 및 모델링에 있어서 다른 중요한 측면(연산/알고리즘)을 희생시키면서 객체 사용을 과도하게 강조한다는 비판을 받아왔습니다. 예를 들어, Rob Pike는 OOP 언어가 흔히 데이터 구조와 알고리즘에서 타입으로 초점을 옮긴다고 말했습니다. Steve Yegge는 함수형 프로그래밍과 대조적으로 다음과 같이 언급했습니다:

> "객체 지향 프로그래밍은 명사를 가장 우선시합니다. 왜 특정 품사를 이런 정도로 높이 올려놓으려고 할까요? 왜 한 종류의 개념이 다른 것보다 우선시되어야 할까요? OOP가 갑자기 우리가 실제로 생각하는 방식에서 동사의 중요성을 떨어뜨린 것은 아닙니다. 이는 이상하게 왜곡된 관점입니다."

Rich Hickey, Clojure의 창시자는 객체 시스템을 현실 세계를 지나치게 단순화한 모델이라고 설명했습니다. 그는 소프트웨어 시스템이 점점 더 동시성을 갖게 됨에 따라 문제가 되고 있는 OOP의 시간을 제대로 모델링하지 못하는 한계를 강조했습니다.

Alexander Stepanov는 객체 지향을 제네릭 프로그래밍과 비교하여 부정적으로 평가했습니다:

> "나는 OOP가 기술적으로 불완전하다고 생각합니다. OOP는 단일 타입에 따라 달라지는 인터페이스 측면에서 세계를 분해하려고 시도합니다. 실제 문제를 다루기 위해서는 다중 정렬 대수학(multisorted algebras)이 필요합니다 - 여러 타입에 걸쳐 있는 인터페이스의 집합들이 필요합니다. 나는 OOP가 철학적으로도 불완전하다고 생각합니다. OOP는 모든 것이 객체라고 주장합니다. 설령 그것이 사실이라 해도 그리 흥미롭지 않습니다 - 모든 것이 객체라고 말하는 것은 사실상 아무 말도 하지 않는 것과 같습니다."

## **상속**
OOP 언어는 일반적으로 코드 재사용과 확장성을 위해 클래스 또는 프로토타입 형태의 상속을 허용합니다. 이러한 상속 형태는 상당히 다르지만, *객체*와 *인스턴스*의 개념을 정의하기 위해 유사한 용어가 사용됩니다.

### **클래스 기반**
클래스 기반 프로그래밍은 가장 인기 있는 스타일로, 각 객체는 특정 *클래스*의 인스턴스여야 합니다. 클래스는 주어진 유형이나 객체 클래스에 대한 데이터 형식이나 타입(멤버 변수와 그 타입 포함)과 사용 가능한 프로시저(클래스 메서드 또는 멤버 함수)를 정의합니다. 객체는 생성자라고 알려진 클래스의 특별한 유형의 메서드를 호출하여 생성됩니다. 클래스는 다른 클래스로부터 상속받을 수 있으므로, "is-a-type-of" 관계를 나타내는 계층 구조로 배열됩니다. 예를 들어, Employee 클래스는 Person 클래스로부터 상속받을 수 있습니다. 부모 클래스에서 사용 가능한 모든 데이터와 메서드는 동일한 이름으로 자식 클래스에도 나타납니다. 예를 들어, Person 클래스는 "first_name"과 "last_name" 변수와 "make_full_name()" 메서드를 정의할 수 있습니다. 이것들은 "position"과 "salary" 변수를 추가할 수 있는 Employee 클래스에서도 사용 가능합니다. Employee 클래스의 모든 인스턴스가 이름, 직위, 급여와 같은 동일한 변수를 가질 것이라는 것이 보장됩니다. 프로시저와 변수는 클래스나 인스턴스에 특정될 수 있습니다; 이로 인해 다음과 같은 용어가 생깁니다: