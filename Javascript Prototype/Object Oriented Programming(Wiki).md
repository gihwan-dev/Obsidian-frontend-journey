## 객체 지향 프로그래밍 (Object-oriented programming, OOP)

객체 지향 프로그래밍(OOP)은 *객체* 개념에 기반한 프로그래밍 패러다임입니다. 객체는 데이터와 코드를 포함할 수 있습니다: 데이터는 필드(흔히 속성 또는 프로퍼티라고 알려진) 형태로, 코드는 프로시저(흔히 메서드라고 알려진) 형태로 존재합니다. OOP에서 컴퓨터 프로그램은 서로 상호작용하는 객체들로 구성됩니다.

C++, Java, Python과 같은 가장 널리 사용되는 프로그래밍 언어 대부분은 다중 패러다임을 지원하며, 일반적으로 명령형 프로그래밍과 선언형 프로그래밍을 조합하여 다양한 정도로 객체 지향 프로그래밍을 지원합니다.

## 역사
현대적 의미의 객체 지향 프로그래밍에서 "객체"라는 용어는 1950년대 후반과 1960년대 초반 MIT의 인공지능 그룹에서 처음 등장했습니다. "객체"는 식별된 속성(attributes)을 가진 LISP 원자(atoms)를 의미했습니다. 또 다른 초기 MIT 사례는 1960-1961년 Ivan Sutherland가 만든 Sketchpad입니다. Sketchpad에 관한 그의 학위 논문을 기반으로 한 1963년 기술 보고서의 용어집에서, Sutherland는 "객체"와 "인스턴스"의 개념을 정의했습니다(클래스 개념은 "마스터" 또는 "정의"로 다루어짐). 다만 이는 그래픽 상호작용에 특화되어 있었습니다. 또한 1968년, MIT의 ALGOL 버전인 AED-0는 데이터 구조("plexes"라고 불림)와 프로시저 사이에 직접적인 연결을 확립했는데, 이는 나중에 "메시지", "메서드", "멤버 함수"라고 불리게 된 것을 예견했습니다. 이 시기에는 데이터 추상화와 모듈식 프로그래밍과 같은 주제가 일반적인 논의 대상이었습니다.

Simula는 AED와 같은 MIT의 후기 작업과는 독립적으로 1961-1967년 사이에 개발되었습니다. Simula는 클래스와 객체, 상속, 동적 바인딩과 같이 오늘날 객체 지향 프로그래밍의 필수적인 부분이 된 중요한 개념들을 도입했습니다. 객체 지향 Simula 프로그래밍 언어는 주로 선박과 그 화물이 항구를 통과하는 움직임을 연구하고 개선하기 위한 모델과 같은 물리적 모델링에 관여한 연구자들에 의해 사용되었습니다. Simula는 일반적으로 객체 지향 언어의 주요 특징과 프레임워크를 갖춘 최초의 언어로 인정받고 있습니다.

MIT의 작업과 Simula 언어의 영향을 받아, 1966년 11월 Alan Kay는 후에 Smalltalk 프로그래밍 언어에 통합될 아이디어에 대한 작업을 시작했습니다. Kay는 1967년만큼 이른 시기에 대화에서 "객체 지향 프로그래밍"이라는 용어를 사용했습니다. 비록 때로는 "객체 지향 프로그래밍의 아버지" 라고 불리지만, Alan Kay는 자신의 OO 개념을 더 전통적인 추상 데이터 타입 개념의 객체와 차별화했으며, 컴퓨터 과학계가 그의 개념을 채택하지 않았음을 암시했습니다. Barbara Liskov가 공동 저자로 참여한 1976년 MIT 메모는 Simula 67, CLU, Alphard를 객체 지향 언어로 나열했지만, Smalltalk는 언급하지 않았습니다.

1970년대에는 Alan Kay, Dan Ingalls, Adele Goldberg에 의해 Xerox PARC에서 Smalltalk 프로그래밍 언어의 첫 번째 버전이 개발되었습니다. Smalltalk-72는 프로그래밍 환경을 포함하고 동적 타입을 가졌으며, 처음에는 컴파일되지 않고 인터프리터 방식이었습니다. Smalltalk는 언어 수준에서의 객체 지향 적용과 그래픽 개발 환경으로 주목받게 되었습니다. Smalltalk는 다양한 버전을 거쳐 발전했고 이 언어에 대한 관심이 증가했습니다. Smalltalk는 Simula 67에서 소개된 아이디어의 영향을 받았지만, 클래스를 동적으로 생성하고 수정할 수 있는 완전한 동적 시스템으로 설계되었습니다. 다중 상속과 같은 OOP 이론의 많은 부분이 Smalltalk의 맥락에서 개발되었습니다.

1970년대 후반과 1980년대 동안 객체 지향 프로그래밍이 두각을 나타내기 시작했습니다. Flavors 객체 지향 Lisp는 1979년부터 개발되기 시작했으며, 다중 상속과 믹스인을 도입했습니다. 1981년, Goldberg는 Byte Magazine의 8월호를 편집하여 Smalltalk와 객체 지향 프로그래밍을 광범위한 독자층에 소개했습니다. Interlisp-D를 위한 객체 시스템인 LOOPS는 Smalltalk와 Flavors의 영향을 받았으며, 이에 관한 논문이 1982년에 발표되었습니다. 1986년, 미국 컴퓨터학회(ACM)는 첫 번째 *객체 지향 프로그래밍, 시스템, 언어 및 응용 프로그램 컨퍼런스*(OOPSLA)를 조직했으며, 1,000명이 참석했습니다. 다른 개발 중에는 Common Lisp Object System이 있었는데, 이는 함수형 프로그래밍과 객체 지향 프로그래밍을 통합했으며 메타-객체 프로토콜을 통한 확장을 허용했습니다. 1980년대에는 메모리 내 객체에 대한 하드웨어 지원을 포함하는 프로세서 아키텍처를 설계하려는 몇 가지 시도가 있었지만 성공하지 못했습니다. 그 예로는 Intel iAPX 432와 Linn Smart Rekursiv가 있습니다.

1980년대 중반에는 Brad Cox가 Objective-C를 개발했는데, 그는 ITT Inc.에서 Smalltalk를 사용한 경험이 있었습니다. 박사 논문에서 Simula를 사용했던 Bjarne Stroustrup은 객체 지향 언어인 C++를 만들었습니다.1985년, Bertrand Meyer는 Eiffel 언어의 첫 번째 설계를 완성했습니다. 소프트웨어 품질에 초점을 맞춘 Eiffel은 순수한 객체 지향 프로그래밍 언어이며 전체 소프트웨어 생명주기를 지원하는 표기법입니다. Meyer는 소프트웨어 공학과 컴퓨터 과학의 핵심 아이디어를 기반으로 한 Eiffel 소프트웨어 개발 방법론을 "Object-Oriented Software Construction"에서 설명했습니다. Eiffel의 품질 중심 접근방식에서 핵심적인 것은 Meyer의 신뢰성 메커니즘인 계약에 의한 설계(design by contract)로, 이는 방법론과 언어 양쪽에 통합된 부분입니다.

1990년대 초반과 중반에는 이러한 기술을 지원하는 프로그래밍 언어들이 널리 보급되면서 객체 지향 프로그래밍이 지배적인 프로그래밍 패러다임으로 발전했습니다. 이러한 언어에는 Visual FoxPro 3.0, C++, 그리고 Delphi가 포함되었습니다. 객체 지향 프로그래밍 기법에 크게 의존하는 그래픽 사용자 인터페이스의 인기가 높아지면서 그 지배력은 더욱 강화되었습니다. 관련된 동적 GUI 라이브러리와 OOP 언어의 예로는 Mac OS X의 Cocoa 프레임워크를 들 수 있는데, 이는 Smalltalk를 기반으로 한 C의 객체 지향적이고 동적 메시징 확장인 Objective-C로 작성되었습니다. OOP 툴킷은 또한 이벤트 중심 프로그래밍의 인기를 높였습니다(이 개념이 OOP에만 국한된 것은 아닙니다).

ETH Zürich에서는 Niklaus Wirth와 그의 동료들이 모듈 경계를 넘어서는 타입 검사의 개념을 연구했습니다. Modula-2(1978)는 이 개념을 포함했으며, 그들의 후속 설계인 Oberon(1987)은 객체 지향, 클래스 등에 대한 독특한 접근 방식을 포함했습니다. Wirth의 설계에서는 상속이 명확하게 드러나지 않는데, 이는 그의 명명법이 반대 방향을 바라보기 때문입니다: 이것은 타입 확장(type extension)이라고 불리며, 관점이 부모에서 상속자로 내려가는 방식입니다.

객체 지향 기능은 Ada, BASIC, Fortran, Pascal, COBOL을 포함한 많은 기존 언어에 추가되었습니다. 처음에 이러한 기능을 위해 설계되지 않은 언어에 이러한 기능을 추가하는 것은 종종 코드의 호환성과 유지보수성에 문제를 일으켰습니다.

최근에는 주로 객체 지향적이면서도 절차적 방법론과 호환되는 일부 언어들이 등장했습니다. 이러한 언어로는 Python과 Ruby가 있습니다. 아마도 상업적으로 가장 중요한 최근의 객체 지향 언어는 Sun Microsystems에서 개발한 Java와 Microsoft의 .NET 플랫폼을 위해 설계된 C# 및 Visual Basic.NET(VB.NET)일 것입니다. 이 두 프레임워크는 각각 구현에서 추상화를 생성함으로써 OOP 사용의 이점을 보여줍니다. VB.NET과 C#은 크로스 언어 상속을 지원하여 한 언어로 정의된 클래스가 다른 언어로 정의된 클래스를 서브클래싱할 수 있게 합니다.

## 특징
객체 지향 프로그래밍은 객체를 사용하지만, OOP를 지원한다고 주장하는 모든 언어에서 관련된 모든 기술과 구조가 직접 지원되는 것은 아닙니다. 아래 나열된 특징들은 강력한 클래스 및 객체 지향적(또는 OOP 지원이 있는 다중 패러다임) 언어로 간주되는 언어들 사이에 공통적이며, 주목할 만한 예외가 언급되어 있습니다. Christopher J. Date는 OOP와 다른 기술, 특히 관계형 기술 간의 중요한 비교가 OOP에 대한 합의된 엄격한 정의의 부재로 인해 어렵다고 말했습니다.

### **비-OOP 언어와 공유되는 특징**
* 정수와 영숫자 문자와 같은 소수의 내장 데이터 타입으로 포맷된 정보를 저장할 수 있는 변수들. 여기에는 문자열, 리스트, 해시 테이블과 같이 내장되어 있거나 메모리 포인터를 사용하여 변수를 결합한 결과로 얻어지는 데이터 구조가 포함될 수 있습니다.
* 프로시저 - 함수, 메서드, 루틴 또는 서브루틴이라고도 알려진 - 는 입력을 받고, 출력을 생성하며, 데이터를 조작합니다. 현대 언어들은 루프와 조건문과 같은 구조적 프로그래밍 구성을 포함합니다.
* 모듈식 프로그래밍 지원은 구성적 목적을 위해 프로시저를 파일과 모듈로 그룹화하는 기능을 제공합니다. 모듈은 네임스페이스화되어 있어 한 모듈의 식별자가 다른 파일이나 모듈에서 같은 이름을 공유하는 프로시저나 변수와 충돌하지 않습니다.

### **객체**
객체는 필드(데이터를 포함하는 상태 변수)와 메서드(코드에서 객체의 동작을 정의하는 서브루틴 또는 프로시저)를 포함하는 데이터 구조 또는 추상 데이터 타입입니다. 필드는 멤버, 속성 또는 프로퍼티라고도 알려져 있습니다. 객체는 일반적으로 연속된 메모리 영역으로 저장됩니다. 객체는 복잡한 내부 구조를 가진 변수와 유사하게 접근되며, 많은 언어에서는 실질적으로 포인터로 작동하여 힙이나 스택 내의 메모리에 있는 해당 객체의 단일 인스턴스에 대한 실제 참조 역할을 합니다.

객체는 때때로 현실 세계에서 발견되는 것들과 일치합니다. 예를 들어, 그래픽 프로그램은 "원", "사각형", "메뉴"와 같은 객체를 가질 수 있습니다. 온라인 쇼핑 시스템은 "쇼핑 카트", "고객", "제품"과 같은 객체를 가질 수 있습니다. 때로는 객체가 열린 파일을 나타내는 객체나 미국 관습 단위에서 미터법으로 측정값을 변환하는 서비스를 제공하는 객체와 같이 더 추상적인 개체를 나타내기도 합니다.

객체는 자신의 인스턴스 변수 안에 다른 객체를 포함할 수 있습니다; 이를 객체 구성(object composition)이라고 합니다. 예를 들어, Employee 클래스의 객체는 "first_name"과 "position"과 같은 자체 인스턴스 변수 외에도 Address 클래스의 객체를 (직접 또는 포인터를 통해) 포함할 수 있습니다. 객체 구성은 "has-a" 관계를 표현하는 데 사용됩니다: 모든 직원은 주소를 가지고 있으므로, 모든 Employee 객체는 Address 객체를 저장할 장소에 접근할 수 있습니다(직접 내장되어 있거나 포인터를 통해 접근되는 별도 위치에 있음). Date와 Darwen은 RDBMS를 지원하기 위해 OOP를 일종의 사용자 정의 가능한 타입 시스템으로 사용하는 이론적 기반을 제안했지만, 이는 객체 포인터를 금지합니다.

OOP 패러다임은 소프트웨어 설계 및 모델링에 있어서 다른 중요한 측면(연산/알고리즘)을 희생시키면서 객체 사용을 과도하게 강조한다는 비판을 받아왔습니다. 예를 들어, Rob Pike는 OOP 언어가 흔히 데이터 구조와 알고리즘에서 타입으로 초점을 옮긴다고 말했습니다. Steve Yegge는 함수형 프로그래밍과 대조적으로 다음과 같이 언급했습니다:

> "객체 지향 프로그래밍은 명사를 가장 우선시합니다. 왜 특정 품사를 이런 정도로 높이 올려놓으려고 할까요? 왜 한 종류의 개념이 다른 것보다 우선시되어야 할까요? OOP가 갑자기 우리가 실제로 생각하는 방식에서 동사의 중요성을 떨어뜨린 것은 아닙니다. 이는 이상하게 왜곡된 관점입니다."

Rich Hickey, Clojure의 창시자는 객체 시스템을 현실 세계를 지나치게 단순화한 모델이라고 설명했습니다. 그는 소프트웨어 시스템이 점점 더 동시성을 갖게 됨에 따라 문제가 되고 있는 OOP의 시간을 제대로 모델링하지 못하는 한계를 강조했습니다.

Alexander Stepanov는 객체 지향을 제네릭 프로그래밍과 비교하여 부정적으로 평가했습니다:

> "나는 OOP가 기술적으로 불완전하다고 생각합니다. OOP는 단일 타입에 따라 달라지는 인터페이스 측면에서 세계를 분해하려고 시도합니다. 실제 문제를 다루기 위해서는 다중 정렬 대수학(multisorted algebras)이 필요합니다 - 여러 타입에 걸쳐 있는 인터페이스의 집합들이 필요합니다. 나는 OOP가 철학적으로도 불완전하다고 생각합니다. OOP는 모든 것이 객체라고 주장합니다. 설령 그것이 사실이라 해도 그리 흥미롭지 않습니다 - 모든 것이 객체라고 말하는 것은 사실상 아무 말도 하지 않는 것과 같습니다."

## **상속**
OOP 언어는 일반적으로 코드 재사용과 확장성을 위해 클래스 또는 프로토타입 형태의 상속을 허용합니다. 이러한 상속 형태는 상당히 다르지만, *객체*와 *인스턴스*의 개념을 정의하기 위해 유사한 용어가 사용됩니다.

### **클래스 기반**
클래스 기반 프로그래밍은 가장 인기 있는 스타일로, 각 객체는 특정 *클래스*의 인스턴스여야 합니다. 클래스는 주어진 유형이나 객체 클래스에 대한 데이터 형식이나 타입(멤버 변수와 그 타입 포함)과 사용 가능한 프로시저(클래스 메서드 또는 멤버 함수)를 정의합니다. 객체는 생성자라고 알려진 클래스의 특별한 유형의 메서드를 호출하여 생성됩니다. 클래스는 다른 클래스로부터 상속받을 수 있으므로, "is-a-type-of" 관계를 나타내는 계층 구조로 배열됩니다. 예를 들어, Employee 클래스는 Person 클래스로부터 상속받을 수 있습니다. 부모 클래스에서 사용 가능한 모든 데이터와 메서드는 동일한 이름으로 자식 클래스에도 나타납니다. 예를 들어, Person 클래스는 "first_name"과 "last_name" 변수와 "make_full_name()" 메서드를 정의할 수 있습니다. 이것들은 "position"과 "salary" 변수를 추가할 수 있는 Employee 클래스에서도 사용 가능합니다. Employee 클래스의 모든 인스턴스가 이름, 직위, 급여와 같은 동일한 변수를 가질 것이라는 것이 보장됩니다. 프로시저와 변수는 클래스나 인스턴스에 특정될 수 있습니다; 이로 인해 다음과 같은 용어가 생깁니다:

* 클래스 변수 - *클래스 전체*에 속함; 각 변수의 복사본은 하나만 있으며, 클래스의 모든 인스턴스 간에 공유됨
* 인스턴스 변수 또는 속성 - 개별 *객체*에 속하는 데이터; 모든 객체는 각각의 복사본을 가짐. 위에서 언급한 4개의 변수(first_name, position 등)는 모두 인스턴스 변수임
* 멤버 변수 - 특정 클래스에 의해 정의된 클래스 변수와 인스턴스 변수를 모두 지칭함
* 클래스 메서드 - *클래스 전체*에 속하며 클래스 변수와 프로시저 호출의 입력에만 접근 가능함
* 인스턴스 메서드 - *개별 객체*에 속하며, 특정 객체에 대해 호출된 인스턴스 변수, 입력, 클래스 변수에 접근 가능함

언어의 정의에 따라, 서브클래스는 수퍼클래스에 의해 정의된 메서드를 오버라이드(재정의)할 수 있거나 없을 수 있습니다. 다중 상속은 일부 언어에서 허용되지만, 이는 오버라이드를 해결하는 것을 복잡하게 만들 수 있습니다. 일부 언어는 트레이트(traits)와 믹스인(mixins)과 같은 다른 개념에 대한 특별한 지원을 가지고 있지만, 다중 상속을 지원하는 모든 언어에서 믹스인은 단순히 is-a-type-of 관계를 나타내지 않는 클래스입니다. 믹스인은 일반적으로 동일한 메서드를 여러 클래스에 추가하기 위해 사용됩니다. 예를 들어, UnicodeConversionMixin 클래스는 공통 부모를 공유하지 않는 FileReader 클래스와 WebPageScraper 클래스에 포함될 때 unicode_to_ascii() 메서드를 제공할 수 있습니다.

추상 클래스는 객체로 인스턴스화될 수 없습니다; 이들은 인스턴스화될 수 있는 다른 "구체적인" 클래스로의 상속을 위해서만 존재합니다. Java에서는 `final` 키워드를 사용하여 클래스가 서브클래싱되는 것을 방지할 수 있습니다.

### **프로토타입 기반**
[[Prototype-based programming(Wikipedia)]]
대조적으로, 프로토타입 기반 프로그래밍에서는 *객체*가 주요 엔티티입니다. 일반적으로 "클래스"라는 개념조차 존재하지 않습니다. 오히려, 객체의 *프로토타입* 또는 *부모*는 객체가 연결된 또 다른 객체에 불과합니다. Self에서는 객체가 여러 부모를 가지거나 부모가 없을 수 있지만, 가장 인기 있는 프로토타입 기반 언어인 Javascript에서는 모든 객체가 하나의 *프로토타입* 링크(단 하나만)를 가집니다. 새로운 객체는 프로토타입으로 선택된 이미 존재하는 객체를 기반으로 생성될 수 있습니다. *fruit* 객체가 존재하고, *apple*과 *orange* 모두 *fruit*을 프로토타입으로 가진다면, 두 개의 서로 다른 객체 *apple*과 *orange*를 과일이라고 부를 수 있습니다. *fruit* 클래스의 개념은 명시적으로 존재하지 않지만, 동일한 프로토타입을 공유하는 객체들의 동치류로서, 또는 특정 인터페이스를 만족하는 객체들의 집합(덕 타이핑)으로 모델링될 수 있습니다. 클래스 기반 프로그래밍과 달리, 프로토타입 기반 언어에서는 일반적으로 다른 객체와 공유되지 않는 속성과 메서드를 정의하는 것이 가능합니다; 예를 들어, *sugar_content* 속성은 *apple*에는 정의되지만 *orange*에는 정의되지 않을 수 있습니다.

### **부재**
Go와 같은 일부 언어는 상속을 전혀 지원하지 않습니다. Go는 자신이 객체 지향적이라고 명시하며, C++의 저자인 Bjarne Stroustrup은 상속 없이도 OOP를 수행하는 것이 가능하다고 언급했습니다. 상속보다 구성(composition)을 선호하는 원칙은 상속 대신 구성을 사용하여 has-a 관계를 구현할 것을 권장합니다. 예를 들어, Person 클래스에서 상속받는 대신, Employee 클래스는 각 Employee 객체에 내부 Person 객체를 제공할 수 있으며, Person 클래스에 많은 공개 속성이나 메서드가 있더라도 이를 외부 코드로부터 숨길 기회가 있습니다. 위임(delegation)은 상속의 대안으로 사용될 수 있는 또 다른 언어 기능입니다.

Rob Pike는 간단한 3줄짜리 조회 테이블 대신 계층화된 추상화가 있는 다단계 타입 계층을 선호하는 OO 사고방식을 비판했습니다. 그는 객체 지향 프로그래밍을 "컴퓨팅의 로마 숫자"라고 불렀습니다.

Bob Martin은 소프트웨어이기 때문에 관련 클래스들이 반드시 그들이 나타내는 것들의 관계를 공유하지는 않는다고 말합니다.

### **동적 디스패치/메시지 전달**
메서드 호출에 응답하여 실행할 프로시저 코드를 선택하는 것은 외부 코드가 아닌 객체의 책임입니다. 일반적으로 실행 시간에 객체와 연관된 테이블에서 메서드를 찾아 선택합니다. 이 기능은 동적 디스패치(dynamic dispatch)라고 알려져 있습니다. 호출 가변성이 메서드가 호출되는 객체의 단일 타입에만 의존하지 않는 경우(즉, 메서드 선택에 적어도 하나 이상의 다른 매개변수 객체가 관여하는 경우), 다중 디스패치(multiple dispatch)라고 합니다. 메서드 호출은 *메시지 전달*(message passing)이라고도 알려져 있습니다. 이는 객체에 디스패치를 위해 메시지(메서드의 이름과 입력 매개변수)가 전달되는 것으로 개념화됩니다.

디스패치는 상속과 상호작용합니다; 특정 객체나 클래스에 메서드가 존재하지 않으면, 디스패치는 부모 객체나 클래스로 위임되며, 이런 식으로 상속 체인을 따라 올라갑니다.

### **데이터 추상화와 캡슐화**
데이터 추상화는 오용을 방지하기 위해 데이터가 의미적으로 관련된 함수에만 보이는 디자인 패턴입니다. 데이터 추상화의 성공으로 인해 데이터 은닉이 객체 지향 및 순수 함수형 프로그래밍의 설계 원칙으로 자주 통합되었습니다. 마찬가지로, 캡슐화는 외부 코드가 객체의 내부 작동 방식에 관여하는 것을 방지합니다. 이는 코드 리팩토링을 용이하게 합니다. 예를 들어, 클래스의 작성자가 외부 코드를 변경하지 않고도 그 클래스의 객체가 내부적으로 데이터를 표현하는 방식을 변경할 수 있게 합니다(단, "공개" 메서드 호출이 동일한 방식으로 작동하는 한). 또한 프로그래머가 특정 데이터 세트와 관련된 모든 코드를 동일한 클래스에 넣도록 장려하여 다른 프로그래머가 쉽게 이해할 수 있도록 구성합니다. 캡슐화는 디커플링(결합도 낮추기)을 장려하는 기술입니다.

객체 지향 프로그래밍에서, 객체는 내부와 외부 코드를 분리하고 추상화와 캡슐화를 구현하는 데 사용될 수 있는 계층을 제공합니다. 외부 코드는 특정 입력 매개변수 세트로 특정 인스턴스 메서드를 호출하거나, 인스턴스 변수를 읽거나, 인스턴스 변수에 쓰는 방식으로만 객체를 사용할 수 있습니다. 프로그램은 실행되면서 독립적으로 작동하는 많은 객체 인스턴스를 생성할 수 있습니다. 이 기술은 실제 세계의 관계를 직관적으로 반영할 수 있을 뿐만 아니라, 서로 다른 데이터 세트에 대해 동일한 프로시저와 데이터 정의를 쉽게 재사용할 수 있게 해준다고 주장됩니다. 개발자는 데이터베이스 테이블과 프로그래밍 서브루틴을 활용하는 대신, 사용자가 더 친숙할 수 있는 객체, 즉 애플리케이션 도메인의, 객체를 활용합니다. OOP 패러다임이 재사용성과 모듈성을 향상시킨다는 이러한 주장들은 비판을 받기도 했습니다.

초기 설계에서는 가능한 한 가장 제한적인 가시성을 사용하도록 권장됩니다. 이는 지역(또는 메서드) 변수, 비공개(private) 변수(객체 지향 프로그래밍에서), 전역(또는 공개) 변수 순으로 적용되며, 필요한 경우와 필요한 만큼만 확장해야 합니다. 이는 가시성에 대한 변경이 기존 코드를 무효화하는 것을 방지합니다.

클래스가 호출 코드가 내부 객체 데이터에 접근하는 것을 허용하지 않고 메서드를 통해서만 접근을 허용한다면, 이 또한 정보 은닉의 한 형태입니다. 일부 언어(예: Java)는 클래스가 접근 제한을 명시적으로 강제할 수 있게 합니다. 예를 들어, 내부 데이터를 `private` 키워드로 표시하고 클래스 외부의 코드에서 사용하기 위한 메서드를 `public` 키워드로 지정합니다. 메서드는 또한 public, private, 또는 `protected`와 같은 중간 수준(같은 클래스와 그 서브클래스에서는 접근을 허용하지만 다른 클래스의 객체에서는 허용하지 않음)으로 설계될 수 있습니다. 다른 언어(Python과 같은)에서는 이것이 단지 관례에 의해서만 강제됩니다(예를 들어, `private` 메서드는 밑줄로 시작하는 이름을 가질 수 있음). C#, Swift, Kotlin 언어에서는 `internal` 키워드가 클래스와 동일한 어셈블리, 패키지 또는 모듈에 있는 파일에만 접근을 허용합니다.

프로그래밍 언어, 특히 객체 지향 언어에서 추상화에 대한 강조는 매우 중요합니다. 객체 지향 언어는 데이터 추상화를 포함하도록 타입의 개념을 확장하며, 메서드를 통해 내부 데이터에 대한 접근을 제한하는 중요성을 강조합니다. Eric S. Raymond는 객체 지향 프로그래밍 언어가 투명성을 해치는 두껍게 계층화된 프로그램을 장려하는 경향이 있다고 기술했습니다. Raymond는 이를 Unix와 C 프로그래밍 언어에서 취한 접근 방식과 비교하여 좋지 않게 평가합니다.

"개방/폐쇄 원칙"은 클래스와 함수가 "확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 한다"고 주장합니다. Luca Cardelli는 OOP 언어가 "클래스 확장과 수정에 관해서는 극히 열악한 모듈성을 가지고 있으며", 극도로 복잡한 경향이 있다고 주장했습니다. 후자의 관점은 Erlang의 주요 발명가인 Joe Armstrong에 의해 다시 강조되었는데, 그는 다음과 같이 말했습니다:

> "객체 지향 언어의 문제는 그들이 주변에 암시적인 환경을 모두 가지고 다닌다는 것입니다. 당신은 바나나를 원했지만, 얻은 것은 바나나를 들고 있는 고릴라와 정글 전체였습니다."

Leo Brodie는 객체의 독립적인 특성과 소프트웨어 개발의 DRY(Don't Repeat Yourself) 원칙\을 위반하는 코드 중복 경향 사이의 연관성을 제시했습니다.

### **다형성**
서브타이핑(Subtyping) - 다형성의 한 형태 - 은 호출 코드가 지원되는 계층 구조 내에서 어떤 클래스에 대해 작동하는지(부모 클래스 또는 그 자손 중 하나)와 독립적일 수 있을 때를 의미합니다. 동시에, 상속 계층 내의 객체들 간에 동일한 연산 이름이 서로 다르게 동작할 수 있습니다.

예를 들어, Circle과 Square 타입의 객체들은 Shape라는 공통 클래스에서 파생됩니다. 각 Shape 타입에 대한 Draw 함수는 자신을 그리는 데 필요한 것을 구현하는 반면, 호출 코드는 그려지고 있는 Shape의 특정 타입에 무관심할 수 있습니다.

이는 클래스 계층 외부의 코드를 단순화하고 관심사의 강력한 분리를 가능하게 하는 또 다른 유형의 추상화입니다.

### **열린 재귀**
객체의 일반적인 특징은 메서드가 객체에 연결되어 있고 객체의 데이터 필드에 접근하고 수정할 수 있다는 것입니다. 이러한 유형의 OOP에서는 일반적으로 현재 객체를 참조하기 위해 `this` 또는 `self`와 같은 특별한 이름이 사용됩니다. 열린 재귀를 지원하는 언어에서는 객체 메서드가 이 이름을 사용하여 동일한 객체의 다른 메서드(자기 자신 포함)를 호출할 수 있습니다. 이 변수는 *지연 바인딩*(late-bound)됩니다; 이는 한 클래스에서 정의된 메서드가 나중에 정의된, 즉 해당 클래스의 서브클래스에서 정의된 다른 메서드를 호출할 수 있게 합니다.