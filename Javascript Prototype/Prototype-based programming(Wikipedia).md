> [원문](https://en.wikipedia.org/wiki/Prototype-based_programming)
> 관련 자료: [[Prototype based programming(번역)]]


**프로토타입 기반 프로그래밍**은 프로토타입 역할을 하는 기존 객체를 재사용하는 프로세스를 통해 동작 재사용(상속이라고 함)이 수행되는 객체 지향 프로그래밍 스타일이다. 이 모델은 프로토타입, 프로토타입 지향, 클래스리스 또는 인스턴스 기반 프로그래밍이라고도 한다.

프로토타입 기반 프로그래밍은 프로세스를 일반화한 객체를 사용하며, 이를 복제하고 확장할 수 있다. 과일을 예로 들면, "과일" 객체는 일반적인 과일의 속성과 기능을 나타낸다. "바나나" 객체는 "과일" 객체에서 복제되고 바나나에 특정한 일반적인 속성이 추가된다. 각각의 개별 "바나나" 객체는 일반 "바나나" 객체에서 복제된다. "과일" 클래스가 "바나나" 클래스로 확장되는 클래스 기반 패러다임과 비교해봐라.

최초의 프로토타입 기반 프로그래밍 언어는 1976년 ~ 1979년 MIT의 케네스 마이클 칸과 스탠포드의 앨런 해밀턴 보닝이 각각 박사 학위 프로젝트로 만든 ThingLab(Smalltalk 기반)(1977~1981)과 독립적이지는 않았지만 동시대에 개발된 디렉터 일명 Ani(MacLisp 기반)였다. Borning은 1981년 TOPLAS 논문에서 "프로토타입"이라는 단어를 소개했다. 구현자나 사용자가 둘 이상인 최초의 프로토타입 기반 프로그래밍 언어는 아마다 Yale T Scheme(1981 ~ 1984)이었으나, 초기에는 Director 및 ThingLab과 마찬가지로 클래스 없이 객체만 표현했다. 프로토타입이라는 이름과 개념을 대중화시킨 언어는 David Ungar와 Randall Smith가 객체 지향 언어 설계의 주제를 연구하기 위해 개발한 Self(1985 ~ 1995)였다.

1990년대 후반부터 클래스 없는 패러다임이 점점 인기를 얻고 있습니다. 현재 프로토타입을 지향하는 언어로는 JavaScript(및 JScript 및 Flash의 ActionScript 1.0과 같은 기타 ECMAScript 구현), Lua, Cecil, NewtonScript, Io, loke, MOO, REBOL 및 AHK가 있습니다.

2010년대 이후 OOP를 핵심으로 축소하는 순수 함수형 프로토타입을 갖춘 새로운 세대의 언어가 등장했다. Jsonnet은 믹스인 상속을 사용하는 프로토타입 객체 시스템이 내장된 동적 지연 순수 함수형 언어이고, Nix는 단 두개의 짧은 함수 정의(기타 많은 편의 기능)로 동등한 객체 시스템(Nix "확장")을 구축하는 동적 지연 순수 함수형 언어이다. 두언어 모두 대규모 분산 소프트웨어 구성을 정의하는데 사용된다(Jsonnet은 Google이 모든 배포를 정의하는 Google 구성 언어인 GCL에서 직접 영감을 받았으며, 변수의 동작 바인딩이 있지만 의미는 비슷하다). 그 이후로 Gerbil Scheme과 같은 다른 언어에서도 유사한 원칙에 따라 순수 기능적 게으른 프로토타입 시스템을 구현했다.

## Design and implementation(디자인과 구현)
어원적으로 "프로토타입"은 "첫 번째 주조"(제조된다는 의미의 "주조")를 의미한다. 프로토타입은 복사 및 수정을 통해 다른 개체를 만들 수 있는 구체적인 사물이다. 예를 들어, 킬로그램의 국제 프로토타입은 실제로 존재하는 실제 객체로, 이를 복사해 새로운 킬로그램 객체를 만들 수 있다. 이에 비해 "클래스"는 객체가 속할 수 있는 추상적인 개념이다. 예를 들어, 모든 킬로그램 객체는 MetricObject의 하위 클래스일 수 있는 KilogramObject 클래스에 속한다.

더글로스 크록포드는 자바스크립트에서 프로토타입 상속을 다음과 같이 말한다.

> 프로토타입 객체를 만든 다음... 새 인스턴스를 만듭니다. 자바스크립트에서 객체는 변경 가능하므로 새 인스턴스를 보강하여 새로운 필드와 메서드를 부여할 수 있습니다. 그런 다음 더 새로운 객체의 프로토타입 역할을 할 수 있습니다. 비슷한 객체를 많이 만들기 위해 클래스가 필요하지 않습니다. 객체는 객체로부터 상속을 받으니까요. 이보다 더 객체 지향적인 것이 있을까요?

프로토타입 기반 프로그래밍의 지지자들은 이 방식이 프로그래머 하여금 먼저 실제 예제들의 동작에 집중하고, 나중에 이러한 객체들을 클래스와 유사한 방식으로 사용될 원형 객체들로 분류하는 것을 고민하도록 장려한다고 주장한다. 많은 프로토타입 기반 시스템들은 실행 중에 프로토타입을 수정하는 것을 장려한다. 반면에 클래스 기반 객체지향 시스템 중에서는 (Common Lisp, Dylan, Object-C, Perl, Python, Ruby, Smalltalk와 같은 동적 객체 지향 시스템들) 극소수만이 프로그램 실행 중에 클래스를 수정할 수 있도록 허용한다.

거의 모든 프로토타입 기반 시스템들은 인터프리터 방식과 동적 타입 언어를 기반으로 한다. 하지만 정적 타입 언어를 기반으로 한 시스템도 기술적으로는 구현 가능하다. `Prototype-Based Programming`에서 논의된 `Omega`언어가 그러한 시스템의 예시이다. 다만 `Omega`의 웹사이트에 따르면, `Omega`조차도 완전히 정적이지는 않으며, 대신 "컴파일러가 프로그램의 효율성을 향상시킬 수 있는 곳에서 정적 바인딩을 사용하도록 선택할 수 있다"고 한다.

## 객체 생성자
프로토타입 기반 언어에는 클래스가 없다. 객체는 프로토타입 속성을 통해 다른 객체에서 직접 상속한다. 프로토타입 프로퍼티는 Self와 JavaScript에서는 `prototype`, lo에서는 `proto`라고 불린다. 새 객체를 구성하는 방법에는 *ex nihilo("무"로부터의 창조)* 객체 생성 또는 기존 객체를 복사하는 방법이 있다. 전자는 `{...}`와 같은 특수 구문을 통해 런타임에 객체를 정의하고 변수에 직접 전달할 수 있는 일종의 객체 리터럴, 선언을 통해 지원된다. 대부분의 시스템에서 다양한 복제를 지원하지만, *ex nihilo* 객체 생성은 좋은 방식은 아니다.

클래스 기반 언어에서 새로운 인스턴스는 클래스 생성자 함수, 즉 객체의 멤버(속성 및 메서드)를 위한 메모리 블록을 예약하고 해당 블록에 대한 참조를 반환하는 특수 함수를 통해 구성된다. 생성자 인수의 선택적 집합은 함수에 전달될 수 있으며 일반적으로 프로퍼티에 보관된다. 결과 인스턴스는 클래스에 정의된 모든 메서드와 프로퍼티를 상속하며, 이는 유사한 타입의 객체를 생성할 수 있는 일종의 템플릿 역할을 한다.

빈 객체 생성을 지원하는 시스템을 사용하면 기존 프로토타입에서 복제하지 않고도 새 객체를 처음부터 만들 수 있다. 이러한 시스템은 기존 객체를 참조하지 않고 새 객체의 속성과 동작을 지정하기 위한 특수한 구문을 제공한다. 많은 프로토타입 언어에는 런타임에 생성되는 다른 모든 객체에 대한 기본 프로토타입으로 설정되고 객체에 대한 설명을 문자열로 변환하는 `toString()` 함수 등 일반적으로 필요한 메서드를 포함하는 루트 객체(종종 `Object`라고 함)가 존재한다. 임시 객체 생성의 한 가지 유용한 측면은 새 객체의 슬록(속성 및 메서드) 이름이 최상위 객체와 네임스페이스 충돌을 일으키지 않도록 하는 것이다. JavaScript 언어에서는 `null` 프로토타입, 즉 `Object.create(null)`을 사용해 이 작업을 수행할 수 있다.

복제는 기존 객체(프로토타입)의 동작을 복사해 새 객체를 만드는 프로세스를 말한다. 그러면 새 객체는 원본의 모든 특성을 갖게 된다. 이 시점부터 새 객체를 수정할 수 있다. 일부 시스템에서는 결과 자식 객체가 위임 또는 유사성을 통해 프로토타입에 대한 명시적인 링크를 유지하며, 프로토타입의 변경 사항은 이를 복제한 객체에도 적용된다. Forth(스택 기반 프로그래밍 언어)와 유사한 언어에서는 프로토타입의 변경이 이러한 방식처럼 전파되지 않는 좀 더 연쇄적인 모델을 따른다.

```js
// Example of true prototypal inheritance style in JavaScript.

// Object creation using the literal object notation {}.
const foo = { name: "foo", one: 1, two: 2 };

// Another object.
const bar = { two: "two", three: 3 };

// Object.setPrototypeOf() is a method introduced in ECMAScript 2015.
// For the sake of simplicity, let us pretend that the following
// line works regardless of the engine used:
Object.setPrototypeOf(bar, foo); // foo is now the prototype of bar.

// If we try to access foo's properties from bar from now on, 
// we'll succeed. 
bar.one; // Resolves to 1.

// The child object's properties are also accessible.
bar.three; // Resolves to 3.

// Own properties shadow prototype properties.
bar.two; // Resolves to "two".
bar.name; // Unaffected, resolves to "foo".
foo.name; // Resolves to "foo".
```

또다른 예제:
```js
const foo = { one: 1, two: 2 };

// bar.[[[prototype]]](https://en.wikipedia.org/wiki/Prototype "Prototype") = foo
const bar = Object.create(foo);

bar.three = 3;

bar.one; // 1
bar.two; // 2
bar.three; // 3
```

## 위임(Delegation)
위임을 사용하는 프로토타입 기반 언어에서는, 언어 런타임이 객체에서 프로토타입으로 이어지는 일련의 위임 포인터들을 따라가면서 일치하는 것을 찾을 때까지 탐색하여 올바른 메서드를 실행하거나 적절한 데이터를 찾을 수 있다. 객체들 간의 얼한 동작 공유를 설정하는 데 필요한 것은 오직 위임 포인터뿐이다. 클래스 기반 객체 지향 언어에서의 인스턴스 간의 관계와는 달리, 프로토타입과 그 파생 객체 간의 관계는 이 링크 외에는 자식 객체가 프로토타입과 메모리 구조적 유사성을 가질 필요가 없다. 따라서 클래스 기반 시스템과는 달리 자식 객체는 연관된 프로토타입의 구조를 재배열 할 필요 없이 시간이 지나면서 계속해서 수정되고 보완될 수 있다. 데이터뿐만 아니라 메서드도 추가하거나 변경할 수 있다는 점에 주목하는 것이 중요하다. 이러한 이유로, 일부 프로토타입 기반 언어들은 데이터와 메서드를 모두 "슬롯" 또는 "멤버"라고 부른다.

## 연결(Concatenation)
Kevo 프로그래밍 언어에서 구현된 연결형 프로토타입 방식에서는, 객체가 복제된 원본 프로토타입에 대한 가시적인 포인터나 링크가 존재하지 않는다. 프로토타입(부모) 객체는 링크되는 대신 복사되며, 위임이 존재하지 않는다. 결과적으로, 프로토타입의 변경사항이 복제된 객체들에 반영되지 않는다. 흥미롭게도, Cosmos 프로그래밍 언어는 영속성 데이터 구조를 사용해 동일한 결과를 달성한다.

이러한 구성에서의 주요 개념적 차이점은 프로토타입 객체에 대한 변경사항이 복제본들에 자동으로 전파되지 않는다는 것이다. 이는 장점이 될 수도 있고 단점이 될 수도 있다. 하지만 Kevo는 위임 모델에서 일반적인 분류학적 출처가 아닌, '가족 유사성' 또는 '복제 패밀리' 메커니즘이라 불리는 객체들의 유사성을 기반으로 변경사항을 전파하기 위한 추가적인 기본 기능을 제공한다. 때때로 위임 기반 프로토타이핑은 자식 객체의 변경이 부모의 이후 동작에 영향을 미칠 수 있다는 추가적인 단점이 있다고 주장되기도 한다. 하지만 이 문제는 위임 기반 모델의 본질적인 문제가 아니며, JavaScript와 같은 위임 기반 언어들에서는 존재하지 않는다. 이러한 언어들은 자식 객체의 변경사항이 항상 자식 객체 자체에만 기록되고 부모에는 절대 기록되지 않도록 보장ㅎ나다(즉, 자식의 값이 부모의 값을 변경하는 것이 아니라 가리는 방식으로 동작한다).

단순한 구현에서는, 연결형 프로토타입이 위임 기반 프로토타입보다 멤버 조회가 더 빠르다(부모 객체들의 체인을 따라갈 필요가 없기 때문이다). 하지만 반대로 더 많은 메모리를 사용한다(부모 객체를 가리키는 단일 슬롯 대신 모든 슬롯이 복사되기 때문이다). 하지만 더 정교한 구현에서는 이러한 문제를 피할 수 있다. 다만 속도와 메모리 사이의 절충이 필요하다. 예를 들어, 연결형 프로토타입 시스템은 복사-시-쓰기(copy-on-write) 구현을 사용해 내부적인 데이터 공유를 가능하게 할 수 있으며, Kevo가 실제로 이러한 접근 방식을 따른다. 반대로, 위임 기반 프로토타입 시스템은 캐싱을 사용해 데이터 조회 속도를 높일 수 있다.

> [!question] 그럼 사실상 자바스크립트는 프로토타입 이론을 충실하게 따르는 언어는 아닌건가?
> JavaScript의 프로토타입 시스템을 Kevo와 비교해볼 때 흥미로운 관점을 제시하셨네요.
[^1]
JavaScript의 프로토타입 시스템은 다음과 같은 특징이 있습니다:
> 
> 1. 단방향 위임 - JavaScript는 프로토타입 체인을 통해 상위 객체의 속성을 찾아가는 단방향 위임만 지원합니다. Kevo처럼 '가족 유사성' 기반의 양방향 변경 전파는 지원하지 않죠.
> 
> 1. 클래스 기반 추상화 - ES6부터 도입된 class 문법은 프로토타입 기반 상속을 클래스처럼 보이게 추상화했습니다. 이는 순수한 프로토타입 이론과는 거리가 있습니다.
> 
> 간단한 예시를 들어보겠습니다:
> 
> ```javascript
> // 프로토타입 방식
> const parent = { greet() { console.log('Hello!') } };
> const child = Object.create(parent);
> 
> // parent 수정은 child에 영향을 미침
> parent.greet = () => console.log('Hi!');
> child.greet(); // 'Hi!' 출력
> 
> // child 수정은 parent에 영향을 미치지 않음
> child.greet = () => console.log('Hey!');
> parent.greet(); // 'Hi!' 출력
> ```
> 
> 실제로 JavaScript는 실용성을 위해 순수 프로토타입 이론에서 벗어난 부분이 있습니다. 특히:
> 
> - 프로토타입 체인의 단방향성
> - class 문법을 통한 클래스 기반 추상화 도입
> - 프로토타입 수정의 제한적인 전파
> 
> 이런 점에서 볼 때, JavaScript는 프로토타입 개념을 채택하되 실용적인 타협을 한 언어라고 볼 수 있습니다. 완전한 프로토타입 이론을 구현했다기보다는, 프로토타입의 장점을 취하면서 개발자들에게 친숙한 방식으로 발전했다고 할 수 있죠.

## 비평(Criticism)
클래스 기반 객체 모델을 지지하는 사람들이 프로토타입 기반 시스템을 비판할 때 제기하는 우려사항들은, 정적 타임 시스템 지지자들이 동적 타임 시스템에 대해 가지는 우려와 비슷하다. 일반적으로 이러한 우려는 정확성, 안정성, 예측 가능성, 효율성 및 프로그래머의 생소함과 관련이 있다.

처음 세 가지 측면에서, 클래스는 종종 타입과 유사하게 여겨지며(대부분의 정적 타입 객체 지향 언어에서 그러한 역할을 수행한다), 인스턴스들이 특정한 방식으로 동작할 것이라는 계약적 보장을 인스턴스들과 그 사용자들에게 제공하도록 제안된다.

효율성 측면에서, 클래스를 선언하는 것은 메서드와 인스턴스 변수 조회를 효율적으로 개발할 수 있게 하는 많은 컴파일러 최적화를 단순화한다.Self 언어의 경우, 프로토타입 기반 시스템의 성능을 클래스 기반 시스템과 비교하여 향상시키기 위한 개발, 컴파일, 해석 기술을 개발하는데 많은 시간을 소요했다.

JavaScript의 인기와 시장 침투에도 불구하고, 소프트웨어 개발자 커뮤니티가 프로토타입 기반 언어에 익숙하지 않다는 것이 일반적인 비판이다. 하지만 월드 와이드 웹(Web)이 성숙해감에 따라 JavaScript 프레임워크의 확산과 JavaScript의 복잡한 사용으로 인해 프로토타입 기반 시스템에 대한 지식이 증가하고 있다. ECMAScript6는 JavaScript의 기존 프로토타입 기반 상속에 대한 문법적 설탕으로 클래스를 도입해, 객체를 생성하고 상속을 관리하는 대안적인 방법을 제공했다.

