> [원문](https://medium.com/javascript-scene/the-forgotten-history-of-oop-88d71b9b2d9f)
> 관련 자료:
> [[Object Oriented Programming]]

> **Note:** This is part of the "Composing Software" serie**s** [**(now a book!)**](https://leanpub.com/composingsoftware) on learning functional programming and compositional software techniques in JavaScript ES6+ from the ground up. Stay tuned. There's a lot more of this to come!  
> [Buy the Book](https://leanpub.com/composingsoftware) | [Index](https://medium.com/javascript-scene/composing-software-the-book-f31c77fc3ddc) | [< Previous](https://medium.com/javascript-scene/javascript-monads-made-simple-7856be57bfe8) | [Next >](https://medium.com/javascript-scene/the-hidden-treasures-of-object-composition-60cd89480381)

오늘날 우리가 사용하는 함수형 및 명령형 프로그래밍 패러다임은 1930년대에 람다 계산법(lambda calculus)과 튜링 머신(Turing machine)을 통해 수학적으로 처음 탐구되었습니다. 이 두 가지는 범용 계산(일반적인 계산을 수행할 수 있는 형식화된 시스템)의 대안적 공식화입니다. 처치-튜링 논제(Church Turing Thesis)는 람다 계산법과 튜링 머신이 기능적으로 동등함을 보여주었습니다. 즉, 튜링 머신을 사용하여 계산할 수 있는 모든 것은 람다 계산법을 사용하여 계산할 수 있으며, 그 반대도 마찬가지입니다.

> _참고: 튜링 머신이 계산 가능한 모든 것을 계산할 수 있다는 일반적인 오해가 있습니다. 일부 경우에는 계산 가능하지만 모든 경우에 대해 튜링 머신을 사용하여 일반적으로 계산할 수 없는 문제 클래스(예: 정지 문제(halting problem))가 있습니다. 이 글에서 "계산 가능한(computable)"이라는 단어를 사용할 때, 저는 "튜링 머신으로 계산 가능한"이라는 의미로 사용하고 있습니다._

람다 계산법은 계산에 대한 하향식(top-down), 함수 적용 접근 방식을 나타내는 반면, 튜링 머신의 티커 테이프/레지스터 머신 공식화는 상향식(bottom-up), 명령형(단계별) 계산 접근 방식을 나타냅니다.

기계어(machine code)와 어셈블리(assembly)와 같은 저수준 언어는 1940년대에 등장했으며, 1950년대 말에는 최초의 인기 있는 고수준 언어들이 등장했습니다. Lisp 계열 언어는 Clojure, Scheme, AutoLISP 등을 포함하여 오늘날에도 여전히 널리 사용되고 있습니다. FORTRAN과 COBOL은 모두 1950년대에 등장했으며 오늘날에도 여전히 사용되고 있는 명령형 고수준 언어의 예시입니다. 다만 대부분의 애플리케이션에서는 C 계열 언어가 COBOL과 FORTRAN을 대체하게 되었습니다.

명령형 프로그래밍과 함수형 프로그래밍은 모두 디지털 컴퓨터가 등장하기 이전의 계산 이론 수학에 뿌리를 두고 있습니다. "객체 지향 프로그래밍"(Object-Oriented Programming, OOP)이라는 용어는 Alan Kay가 대학원에 있던 1966년 또는 1967년경에 만들어졌습니다.

Ivan Sutherland의 획기적인 Sketchpad 애플리케이션은 OOP의 초기 영감이었습니다. 이는 1961년과 1962년 사이에 개발되었으며 1963년 그의 Sketchpad 논문에서 발표되었습니다. 객체들은 오실로스코프 화면에 표시된 그래픽 이미지를 나타내는 데이터 구조였으며, Ivan Sutherland이 그의 논문에서 "masters"라고 부른 동적 위임(dynamic delegates)을 통한 상속 기능을 갖추고 있었습니다. 어떤 객체든 "master"가 될 수 있었고, 객체의 추가 인스턴스는 "occurrences"라고 불렸습니다. Sketchpad의 masters는 JavaScript의 프로토타입 상속(prototypal inheritance)과 많은 공통점을 공유합니다.

>_**참고:**_* MIT 링컨 연구소(Lincoln Laboratory)의 TX-2는 광펜(light pen)을 사용한 직접적인 화면 상호작용을 통해 그래픽 컴퓨터 모니터를 활용한 초기 사례 중 하나였습니다. 1948년부터 1958년까지 운영되었던 EDSAC는 화면에 그래픽을 표시할 수 있었습니다. MIT의 Whirlwind는 1949년에 작동하는 오실로스코프 디스플레이를 갖추고 있었습니다. 이 프로젝트의 목적은 여러 항공기의 계기 피드백을 시뮬레이션할 수 있는 범용 비행 시뮬레이터를 만드는 것이었습니다. 이는 SAGE 컴퓨팅 시스템의 개발로 이어졌습니다. TX-2는 SAGE를 위한 테스트 컴퓨터였습니다.

일반적으로 "객체 지향적"이라고 널리 인정받은 최초의 프로그래밍 언어는 1965년에 명세된 Simula였습니다. Sketchpad와 마찬가지로 Simula는 객체를 특징으로 했으며, 결국 클래스(classes), 클래스 상속(class inheritance), 서브클래스(subclasses) 및 가상 메서드(virtual methods)를 도입했습니다.

> **참고:** _가상 메서드(virtual method)는 서브클래스에 의해 재정의(override)되도록 설계된 클래스에 정의된 메서드입니다. 가상 메서드를 사용하면 프로그램이 코드 컴파일 시점에는 존재하지 않을 수 있는 메서드를 호출할 수 있으며, 런타임에 어떤 구체적인 메서드를 호출할지 결정하기 위해 동적 디스패치(dynamic dispatch)를 사용합니다. JavaScript는 동적 타입을 특징으로 하고 어떤 메서드를 호출할지 결정하기 위해 위임 체인(delegation chain)을 사용하므로, 프로그래머에게 가상 메서드라는 개념을 노출할 필요가 없습니다. 다시 말해, JavaScript의 모든 메서드는 런타임 메서드 디스패치를 사용하므로, JavaScript의 메서드는 이 기능을 지원하기 위해 "virtual"로 선언될 필요가 없습니다._


## 큰 아이디어(The Big Idea)

> "제가 '객체 지향적'이라는 용어를 만들었는데, C++를 염두에 둔 것은 아니었습니다." ~ Alan Kay, OOPSLA '97_

Alan Kay는 1966년 또는 1967년 대학원에서 "객체 지향 프로그래밍"이라는 용어를 만들었습니다. 이 큰 아이디어는 직접적인 데이터 공유가 아닌 메시지 전달(message passing)을 통해 통신하는 소프트웨어에서 캡슐화된 미니 컴퓨터를 사용하는 것이었습니다 - 프로그램을 별도의 "데이터 구조(data structures)"와 "프로시저(procedures)"로 분리하는 것을 중단하기 위함이었습니다.

"재귀적 설계의 기본 원칙은 부분이 전체와 동일한 능력을 갖도록 만드는 것입니다." ~ Bob Barton, Algol-60을 실행하기 위해 최적화된 메인프레임 B5000의 주요 설계자.

Smalltalk은 Alan Kay, Dan Ingalls, Adele Goldberg 및 Xerox PARC의 다른 연구원들에 의해 개발되었습니다. Smalltalk은 Simula보다 더 객체 지향적이었습니다 - Smalltalk에서는 클래스, 정수, 블록(클로저) 등 모든 것이 객체입니다. 원래 Smalltalk-72는 서브클래싱(subclassing) 기능을 갖추지 않았습니다. 이 기능은 Dan Ingalls에 의해 Smalltalk-76에서 도입되었습니다.

Smalltalk은 클래스와 결국에는 서브클래싱을 지원했지만, Smalltalk의 핵심은 클래스나 사물의 서브클래싱이 아니었습니다. 그것은 Lisp과 Simula에서 영감을 받은 함수형 언어였습니다. Alan Kay는 업계가 서브클래싱에 집중하는 것이 객체 지향 프로그래밍의 진정한 이점으로부터 주의를 분산시키는 것이라고 생각합니다.

> _"저는 오래 전에 이 주제에 대해 '객체(objects)'라는 용어를 만든 것에 대해 유감입니다. 이는 많은 사람들이 더 작은 아이디어에 집중하게 만들기 때문입니다. 큰 아이디어는 메시징(messaging)입니다." ~ Alan Kay_

2003년 이메일 교환에서 Alan Kay는 Smalltalk를 "객체 지향적"이라고 불렀을 때 무엇을 의미했는지 명확히 설명했습니다:

> _"OOP는 제게 오직 메시징(messaging), 상태-프로세스의 지역적 유지 및 보호와 숨김, 그리고 모든 것의 극단적인 지연 바인딩(extreme late-binding)만을 의미합니다." ~ Alan Kay_

다시 말해, Alan Kay에 따르면 OOP의 필수 요소는 다음과 같습니다:

- 메시지 전달(Message passing)
- 캡슐화(Encapsulation)
- 동적 바인딩(Dynamic binding)

주목할 점은, 이 용어를 만들고 OOP를 대중화한 Alan Kay는 상속(inheritance)과 서브클래스 다형성(subclass polymorphism)을 OOP의 필수 요소로 간주하지 않았다는 것입니다.

## OOP의 본질
메시지 전달과 캡슐화의 조합은 몇 가지 중요한 목적을 제공합니다:

- **공유 가능한 상태(shared mutable state) 방지** - 상태를 캡슐화하고 다른 객체들을 지역 상태 변경으로부터 격리시킵니다. 다른 객체의 상태에 영향을 미치는 유일한 방법은 메시지를 보내서 그 객체에게 변경하도록 요청(명령이 아닌)하는 것입니다. 상태 변경은 공유 접근에 노출되기보다는 지역적, 셀룰러 수준에서 제어됩니다.
- **디커플링(Decoupling)** - 객체들을 서로 분리합니다. 메시지 발신자는 메시징 API를 통해 메시지 수신자와 느슨하게 결합되어 있습니다.    
- **런타임에서의 적응성과 변화에 대한 탄력성** - 지연 바인딩(late binding)을 통해 제공됩니다. 런타임 적응성은 Alan Kay가 OOP에 필수적이라고 생각한 많은 중요한 이점을 제공합니다.

이러한 아이디어들은 Alan Kay의 생물학 배경과 Arpanet(인터넷의 초기 버전) 디자인의 영향을 통해 생물학적 세포 및/또는 네트워크상의 개별 컴퓨터에서 영감을 받았습니다. 그 초기에도 Alan Kay는 거대한 분산 컴퓨터(인터넷)에서 실행되는 소프트웨어를 상상했습니다. 여기서 개별 컴퓨터는 생물학적 세포처럼 작동하여 자체적인 격리된 상태에서 독립적으로 작동하고 메시지 전달을 통해 통신합니다.

> _"저는 세포/전체-컴퓨터 은유가 데이터를 제거할 것이라는 점을 깨달았습니다[...]" ~ Alan Kay_

Alan Kay가 "데이터를 제거한다"라고 한 것은 그가 공유 데이터로 인해 발생하는 공유 가능한 상태 문제(shared mutable state problems)와 강한 결합(tight coupling)을 분명히 인식하고 있었다는 것을 보여줍니다 - 이는 오늘날에도 일반적인 주제입니다.

그러나 1960년대 후반, ARPA 프로그래머들은 소프트웨어를 구축하기 전에 프로그램을 위한 데이터 모델 표현을 미리 선택해야 하는 필요성에 좌절했습니다. 특정 데이터 구조에 너무 강하게 결합된 프로시저들은 변화에 대응하는 탄력성이 부족했습니다. 그들은 데이터에 대한 더 균일한 처리 방식을 원했습니다.

> _"[...] OOP의 핵심은 객체 내부에 대해 걱정할 필요가 없다는 것입니다. 서로 다른 기계에서 서로 다른 언어로 만들어진 객체들도 서로 대화할 수 있어야 합니다 [...]" ~ Alan Kay_

객체는 데이터 구조 구현을 추상화하고 숨길 수 있습니다. 객체의 내부 구현은 소프트웨어 시스템의 다른 부분을 손상시키지 않고 변경될 수 있습니다. 사실, 극단적인 지연 바인딩(extreme late binding)을 통해 완전히 다른 컴퓨터 시스템이 객체의 책임을 대신할 수 있고, 소프트웨어는 계속 작동할 수 있습니다. 한편, 객체는 내부적으로 사용하는 데이터 구조와 상관없이 작동하는 표준 인터페이스를 노출할 수 있습니다. 동일한 인터페이스가 연결 리스트(linked list), 트리(tree), 스트림(stream) 등과 함께 작동할 수 있습니다.

Alan Kay는 또한 객체를 수학적으로 증명 가능한 행동에 대한 특정 보증을 제공하는 대수적 구조(algebraic structures)로 보았습니다:

> _"제 수학적 배경 덕분에 각 객체가 여러 대수(algebras)와 연관될 수 있고, 이들의 집합이 있을 수 있으며, 이것들이 매우 매우 유용할 것이라는 점을 깨달았습니다." ~ Alan Kay_

이는 사실로 입증되었으며, 카테고리 이론(category theory)에서 영감을 받은 프로미스(promises)와 렌즈(lenses)와 같은 객체의 기초를 형성합니다.

앨런 케이의 객체에 대한 대수적 특성 비전은 객체가 공식적인 검증, 결정론적 행동, 그리고 향상된 테스트 가능성을 제공할 수 있게 합니다. 이는 대수가 본질적으로 방정식 형태의 몇 가지 규칙을 따르는 연산이기 때문입니다.

프로그래머 용어로 말하자면, 대수는 함수(연산)로 구성된 추상화와 비슷하며, 이 함수들은 반드시 통과해야 하는 단위 테스트(공리/방정식)에 의해 시행되는 특정 법칙을 동반합니다.

이러한 아이디어들은 C++, Java, C# 등 대부분의 C 계열 객체 지향 언어에서 수십 년 동안 잊혀졌지만, 최근에는 가장 널리 사용되는 객체 지향 언어의 최신 버전들에서 다시 자리를 찾아가고 있습니다.

프로그래밍 세계는 객체 지향 언어의 맥락에서 함수형 프로그래밍과 합리적 사고의 이점을 재발견하고 있다고 말할 수 있습니다.

JavaScript 및 그 이전의 Smalltalk처럼, 대부분의 현대 객체 지향 언어들은 점점 더 "다중 패러다임 언어(multi-paradigm languages)"가 되어가고 있습니다. 함수형 프로그래밍과 OOP 사이에서 선택해야 할 이유는 없습니다. 각각의 역사적 본질을 살펴보면, 이들은 서로 호환될 뿐만 아니라 상호 보완적인 아이디어입니다.

JavaScript와 Smalltalk는 많은 기능을 공유하기 때문에, 저는 JavaScript가 세상이 OOP를 오해한 것에 대한 Smalltalk의 복수라고 말하곤 합니다. Smalltalk와 JavaScript 모두 다음을 지원합니다:

- 객체(Objects)
- 일급 함수(First-class functions)와 클로저(closures)
- 동적 타입(Dynamic types)
- 지연 바인딩(Late binding) (런타임에 함수/메서드 변경 가능)
- 클래스 상속 없는 OOP

OOP의 필수 요소(앨런 케이에 따르면)?

- 캡슐화(Encapsulation)
- 메시지 전달(Message passing)
- 동적 바인딩(Dynamic binding) (프로그램이 런타임에 진화/적응하는 능력)

OOP의 비필수 요소는?
- 클래스(Classes)
- 클래스 상속(Class inheritance)
- 객체/함수/데이터에 대한 특별 취급
- `new` 키워드
- 다형성(Polymorphism)
- 정적 타입(Static types)
- 클래스를 "타입"으로 인식하는 것

만약 당신의 배경이 Java나 C#이라면, 정적 타입과 다형성이 필수 요소라고 생각할 수 있지만, Alan Kay는 대수적 형태로 일반적인 동작을 다루는 것을 선호했습니다. 예를 들어, Haskell에서:

```haskell
fmap :: (a -> b) -> f a -> f b
```

이는 함수자 맵 시그니처(functor map signature)로, 지정되지 않은 타입 `a`와 `b`에 대해 일반적으로 작동하며, `a`에서 `b`로의 함수를 `a`의 함수자 컨텍스트에 적용하여 `b`의 함수자를 생성합니다. 함수자(Functor)는 기본적으로 "맵 연산을 지원하는 것"을 의미하는 수학적 전문 용어입니다. JavaScript에서 `[].map()`에 익숙하다면, 이미 그 의미를 알고 있을 것입니다.

여기 자바스크립트 예제 두가지가 있습니다:
```javascript
// isEven = Number => Boolean
const isEven = n => n % 2 === 0;

const nums = [1, 2, 3, 4, 5, 6];

// map takes a function `a => b` and an array of `a`s (via `this`)
// and returns an array of `b`s.
// in this case, `a` is `Number` and `b` is `Boolean`
const results = nums.map(isEven);

console.log(results);
// [false, true, false, true, false, true]
```

`.map()` 메서드는 `a`와 `b`가 어떤 타입이든 될 수 있다는 점에서 일반적(generic)이며, 배열이 대수적 `functor` 법칙을 구현하는 데이터 구조이기 때문에 `.map()`은 이를 아주 잘 처리합니다. `.map()`은 타입을 직접 조작하려 하지 않고 대신 애플리케이션에 맞는 올바른 타입을 기대하고 반환하는 함수를 적용하기 때문에 타입은 `.map()`에게 중요하지 않습니다.

이러한 일반적인 타입 관계는 TypeScript와 같은 언어에서 올바르고 철저하게 표현하기 어렵지만, 고차 유형 타입(higher kinded types, 타입의 타입)을 지원하는 Haskell의 Hindley Milner 타입 시스템에서는 꽤 쉽게 표현할 수 있습니다.

대부분의 타입 시스템은 함수 합성(function composition), 자유로운 객체 합성(free object composition), 런타임 객체 확장(runtime object extension), 조합기(combinators), 렌즈(lenses) 등과 같은 동적이고 함수적인 아이디어를 자유롭게 표현하기에는 너무 제한적이었습니다. 다시 말해, 정적 타입은 종종 조합 가능한(composable) 소프트웨어를 작성하기 어렵게 만듭니다.

만약 타입 시스템이 너무 제한적이라면(예: TypeScript, Java), 동일한 목표를 달성하기 위해 더 복잡한 코드를 작성해야 합니다. 이것이 정적 타입이 나쁜 아이디어라거나 모든 정적 타입 구현이 똑같이 제한적이라는 의미는 아닙니다. 저는 Haskell의 타입 시스템에서는 훨씬 적은 문제를 경험했습니다.

만약 당신이 정적 타입의 팬이고 그 제한에 개의치 않는다면, 당신에게 더 많은 힘을 실어드립니다. 하지만 만약 합성된 함수와 복합 대수 구조를 타입화하기 어렵기 때문에 이 텍스트의 일부 조언이 어렵다고 느낀다면, 아이디어가 아니라 타입 시스템을 탓하세요. 사람들은 SUV의 편안함을 좋아하지만, 그것이 당신을 날게 해주지 않는다고 불평하지는 않습니다. 그것을 위해서는 더 많은 자유도를 가진 차량이 필요합니다.

제한이 당신의 코드를 더 단순하게 만든다면, 훌륭합니다! 하지만 제한이 당신에게 더 복잡한 코드를 작성하도록 강요한다면, 아마도 그 제한이 잘못된 것일 수 있습니다.

## 객체란 무엇인가?
객체는 수년에 걸쳐 많은 의미를 가지게 되었습니다. JavaScript에서 우리가 "객체"라고 부르는 것은 단순히 복합 데이터 타입일 뿐이며, 클래스 기반 프로그래밍이나 Alan Kay의 메시지 전달 개념에서 비롯된 함의는 없습니다.

JavaScript에서 이러한 객체들은 캡슐화, 메시지 전달, 메서드를 통한 동작 공유, 심지어 서브클래스 다형성(타입 기반 디스패치가 아닌 위임 체인을 사용하지만)을 지원할 수 있으며 자주 지원합니다. 어떤 함수든 어떤 속성에든 할당할 수 있습니다. 객체 동작을 동적으로 구축하고 런타임에 객체의 의미를 변경할 수 있습니다. JavaScript는 또한 구현 비공개를 위해 클로저를 사용한 캡슐화를 지원합니다. 하지만 이 모든 것은 선택적으로 사용할 수 있는 동작입니다.

객체에 대한 우리의 현재 개념은 단순히 복합 데이터 구조일 뿐이며, 객체로 간주되기 위해 그 이상의 것을 필요로 하지 않습니다. 하지만 이러한 종류의 객체를 사용하여 프로그래밍한다고 해서 함수로 프로그래밍하는 것이 코드를 "함수형"으로 만들지 않는 것처럼, 코드를 "객체 지향적"으로 만들지는 않습니다.

## OOP는 더 이상 진짜 OOP가 아니다
현대 프로그래밍 언어에서 "객체"는 Alan Kay에게 의미했던 것보다 훨씬 적은 의미를 가지기 때문에, 저는 _진짜 OOP_의 규칙을 설명하기 위해 "객체" 대신 "컴포넌트"라는 용어를 사용하고 있습니다. JavaScript에서 많은 _객체_는 다른 코드에 의해 직접 소유되고 조작되지만, **컴포넌트**는 자신의 상태를 캡슐화하고 제어해야 합니다.

**진정한 OOP의 의미:**
- **컴포넌트**(Alan Kay의 "객체")로 프로그래밍하기
- 컴포넌트 상태는 반드시 캡슐화되어야 함
- 객체 간 통신에 메시지 전달 사용하기
- 컴포넌트는 런타임에 추가/변경/대체될 수 있음

대부분의 컴포넌트 동작은 대수적 데이터 구조를 사용하여 일반적으로 지정될 수 있습니다. 여기서는 상속이 필요하지 않습니다. 컴포넌트는 자신의 데이터를 공유하지 않고도 공유 함수와 모듈 가져오기에서 동작을 재사용할 수 있습니다.

_객체_를 조작하거나 JavaScript에서 _클래스 상속_을 사용한다고 해서 "OOP를 하고 있다"는 의미는 아닙니다. 이런 방식으로 컴포넌트를 사용하는 것이 진정한 OOP입니다. 하지만 용어는 대중적 사용에 의해 정의되기 때문에, 아마도 우리는 OOP를 포기하고 "객체 지향 프로그래밍(OOP)" 대신 "메시지 지향 프로그래밍(MOP)"이라고 부르는 것이 좋을지도 모릅니다.

걸레가 지저분한 곳을 청소하는 데 사용되는 것이 우연일까요?

## 좋은 MOP의 모습
대부분의 현대 소프트웨어에는 사용자 상호작용을 관리하는 UI, 애플리케이션 상태(사용자 데이터)를 관리하는 코드, 그리고 시스템 또는 네트워크 I/O를 관리하는 코드가 있습니다.

이러한 각 시스템은 이벤트 리스너, 네트워크 연결 상태, UI 요소 상태, 애플리케이션 상태 자체와 같은 것들을 추적하기 위한 상태 등 장기적으로 실행되는 프로세스가 필요할 수 있습니다.

좋은 MOP는 이러한 모든 시스템이 서로의 상태를 직접 조작하는 대신, 시스템이 메시지 디스패치를 통해 다른 컴포넌트와 통신한다는 것을 의미합니다. 사용자가 저장 버튼을 클릭하면 `"SAVE"` 메시지가 디스패치될 수 있으며, 이를 애플리케이션 상태 컴포넌트가 해석하여 상태 업데이트 핸들러(예: 순수 리듀서 함수)에 전달할 수 있습니다. 아마도 상태가 업데이트된 후에는 상태 컴포넌트가 UI 컴포넌트에 `"STATE_UPDATED"` 메시지를 디스패치할 수 있으며, 이는 차례로 상태를 해석하고, UI의 어떤 부분이 업데이트되어야 하는지 조정한 다음, 업데이트된 상태를 해당 UI 부분을 처리하는 서브컴포넌트에 전달합니다.

한편, 네트워크 연결 컴포넌트는 사용자와 네트워크상의 다른 기기 간의 연결을 모니터링하고, 메시지를 수신하며, 원격 기기에 데이터를 저장하기 위해 업데이트된 상태 표현을 디스패치할 수 있습니다. 이는 내부적으로 네트워크 하트비트 타이머, 연결이 현재 온라인인지 오프라인인지 등을 추적하고 있습니다.

이러한 시스템들은 시스템의 다른 부분들에 대한 세부 사항을 알 필요가 없습니다. 오직 그들의 개별적이고 모듈화된 관심사에 대해서만 알면 됩니다. 시스템 컴포넌트는 분해 가능하고 재구성 가능합니다. 이들은 서로 상호 운용될 수 있도록 표준화된 인터페이스를 구현합니다. 인터페이스만 충족된다면, 같은 일을 다른 방식으로 수행하거나 동일한 메시지로 완전히 다른 일을 수행하는 대체품을 사용할 수 있습니다. 심지어 런타임에도 이렇게 할 수 있으며, 모든 것이 계속 제대로 작동할 것입니다.

동일한 소프트웨어 시스템의 컴포넌트가 반드시 같은 기기에 위치할 필요는 없습니다. 시스템은 분산화될 수 있습니다. 네트워크 스토리지는 IPFS와 같은 분산 저장 시스템에 데이터를 샤딩(sharding)할 수 있으므로, 사용자는 데이터가 안전하게 백업되고 해커들로부터 보호되기 위해 특정 기기의 상태에 의존할 필요가 없습니다.

OOP는 부분적으로 Arpanet에서 영감을 받았으며, Arpanet의 목표 중 하나는 원자폭탄과 같은 공격에도 탄력적으로 대응할 수 있는 분산 네트워크를 구축하는 것이었습니다. Arpanet 개발 당시 DARPA의 디렉터였던 Stephen J. Lukasik("왜 Arpanet이 만들어졌는가")에 따르면:

> _"그 목표는 핵 위협에 대한 군사 명령 및 통제의 필요성을 충족시키기 위해 새로운 컴퓨터 기술을 활용하고, 미국 핵전력의 생존 가능한 통제를 달성하며, 군사적 전술 및 관리 의사 결정을 개선하는 것이었습니다."_

_**참고:**_ Arpanet의 주요 동기는 핵 위협보다는 편의성이었으며, 그 명백한 방어 이점은 나중에 드러났습니다. ARPA는 세 개의 별도 컴퓨터 연구 프로젝트와 통신하기 위해 세 개의 별도 컴퓨터 터미널을 사용하고 있었습니다. Bob Taylor는 각 프로젝트를 다른 프로젝트와 연결하는 단일 컴퓨터 네트워크를 원했습니다.

좋은 MOP 시스템은 애플리케이션이 실행 중인 동안에도 핫스왑(hot-swappable) 가능한 컴포넌트를 사용하여 인터넷의 견고성을 공유할 수 있습니다. 사용자가 휴대폰을 사용하다가 터널에 들어가서 오프라인 상태가 되더라도 계속 작동할 수 있습니다. 허리케인으로 인해 서버가 위치한 데이터 센터 중 하나의 전력이 끊어지더라도 계속 기능할 수 있습니다.

소프트웨어 세계가 실패한 클래스 상속 실험을 포기하고, 원래 OOP의 정신을 정의했던 수학과 과학 원칙을 받아들일 때가 되었습니다.

이제 우리가 MOP와 함수형 프로그래밍이 조화롭게 작동하는, 더 유연하고, 더 탄력적이며, 더 잘 구성된 소프트웨어를 구축하기 시작할 때입니다.

> _참고: MOP 약어는 이미 "모니터링 지향 프로그래밍(monitoring-oriented programming)"을 설명하는 데 사용되고 있으며, OOP가 조용히 사라질 가능성은 낮습니다. MOP가 프로그래밍 용어로 널리 사용되지 않더라도 실망하지 마세요. OOP를 MOP로 닦아내세요._