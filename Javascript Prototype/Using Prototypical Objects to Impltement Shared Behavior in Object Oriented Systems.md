> [원문](https://web.media.mit.edu/~lieber/Lieberary/OOP/Delegation/Delegation.html)
> 
> Artificial Intelligence Laboratory
> Massachusetts Institute of Technology
> Cambridge, Mass. 02139 USA
> 
> Electronic mail: Henry@AI.AI.MIT.Edu
> 
  

**요약**

일반적인 개념을 추상적인 _집합_(set)이나 _클래스_(class)로 표현하는 것과 구체적인 _프로토타입_(prototype)으로 표현하는 것 사이의 전통적인 철학적 논쟁은 객체 지향 프로그래밍 언어에서 객체 간 동작을 공유하는 두 메커니즘 사이의 논쟁에 반영되어 있습니다. _상속_(Inheritance)은 객체 세계를 _클래스_와 _인스턴스_로 나눕니다. 클래스는 그룹 내 _인스턴스_ 간에 공유되는 동작을 인코딩하고, 인스턴스는 이러한 집합의 개별 멤버를 나타냅니다. 프로토타입 접근 방식을 채택하면 클래스/인스턴스 구분이 필요하지 않습니다. 프로토타입은 개념에 대한 _기본_ 동작을 나타내며, 새 객체는 프로토타입과의 차이점을 명시함으로써 프로토타입에 저장된 지식의 일부를 재사용할 수 있습니다. 프로토타입 접근 방식은 기본 지식을 표현하고, 개념을 점진적이고 동적으로 수정하는 데 몇 가지 이점을 제공하는 것으로 보입니다. _위임_(Delegation)은 객체 지향 언어에서 이를 구현하는 메커니즘입니다. 객체는 자신만의 특별한 동작을 확인한 후, 더 일반적인 지식을 호출하기 위해 프로토타입에 메시지를 전달할 수 있습니다. 클래스 객체는 인스턴스를 사용하기 전에 생성되어야 하고 동작은 클래스에만 연결될 수 있기 때문에, 상속은 인스턴스 생성 시점에 객체 간 통신 패턴을 고정합니다. 모든 객체를 프로토타입으로 사용할 수 있고 언제든지 모든 메시지를 전달할 수 있기 때문에, 위임은 두 기술 중 더 유연하고 일반적인 방법입니다.

**1. 집합 vs. 프로토타입: 실질적 결과를 가져오는 철학적 딜레마**

사람들은 구체적인 상황에서의 경험으로부터 일반화한 지식을 어떻게 표현할까요? 인식론을 연구하는 철학자들은 이 질문에 대해 오랫동안 논쟁해왔습니다. 앞으로 살펴보겠지만, 이 문제는 객체 지향 시스템에서 지식을 표현하는 작업에 실질적인 영향을 미칩니다. 객체 지향 프로그래밍의 상당 부분이 실제 세계의 객체를 표현하는 것을 포함하기 때문에, 실제 세계 지식을 저장하고 사용하는 우리의 메커니즘이 컴퓨터 언어에서 객체를 다루는 메커니즘에 반영됩니다. 우리는 개념을 집합(sets)으로 표현하는 것과 프로토타입(prototypes)으로 표현하는 것 사이의 전통적인 논쟁이 어떻게 객체 지향 언어에서 관련 객체 간의 동작을 공유하는 두 가지 메커니즘인 _상속_(inheritance)과 _위임_(delegation)을 탄생시키는지 살펴볼 것입니다.

사람이 특정 상황, 예를 들어 Clyde라는 특정 코끼리에 관한 경험을 했다면, Clyde에 관한 사실들은 Fred라는 다른 코끼리를 만났을 때도 유용할 수 있습니다. 우리가 Clyde에 대한 개념과 Fred에 대한 개념에 대한 정신적 표현을 가지고 있다면, 질문은 다음과 같습니다: Clyde와 Fred의 표현은 어떻게 지식을 공유할까요? 우리는 Fred의 색상, 다리 수, 크기 등과 같은 질문에 대해 Clyde에 대해 이미 알고 있는 것을 참조하여 어떻게 답할 수 있을까요? 관련 개념 간 지식을 공유하는 메커니즘이 없다면, Fred의 표현에 Clyde에 관한 모든 지식을 반복해야 할 것입니다.

우리가 채택할 수 있는 두 가지 관점이 있습니다. 첫 번째는 추상적인 집합의 개념에 기반합니다. Clyde에 대해 배우면서, 우리는 *코끼리의 집합[또는 클래스]*이라는 개념을 구성할 수 있습니다. 이는 Clyde와 충분히 유사하여 코끼리라고 불릴 수 있는 모든 개별 동물에 대해 참이라고 믿는 것을 추상화합니다. 집합의 설명은 코끼리의 모든 "필수적" 속성을 열거할 수 있습니다. Clyde를 이 클래스의 _멤버_ 또는 _인스턴스_로 볼 수 있습니다. 객체 지향 시스템에서 집합 접근 방식은 코끼리 집합을 나타내는 객체를 생성하고, Clyde를 나타내는 객체와 집합 객체 사이에 멤버십 관계를 나타내는 링크를 설정하는 것을 포함합니다. 집합의 설명은 모든 멤버에 대해 참인 것을 나타내므로, 집합의 설명을 참조하여 Clyde에 관한 질문에 답할 수 있습니다. Fred와 코끼리 집합 사이에 동일한 종류의 멤버십 링크를 설정하면 Fred와 Clyde가 동일한 지식의 일부를 공유할 수 있습니다. Fred와 Clyde가 인도 코끼리라는 추가적인 속성을 공유하며, 다른 일부 코끼리는 이 속성을 공유하지 않는 경우, 이러한 속성은 코끼리 집합의 모든 속성을 공유하면서 인도와 관련된 추가 속성을 연결하는 하위 클래스(subclass) 객체에 구현될 수 있습니다.

하지만 다른 관점도 있습니다. Clyde를 _전형적인 코끼리_의 개념을 대표하는 것으로 볼 수 있습니다. "코끼리를 생각해보세요"라고 하면, 의심할 여지 없이 회색, 코끼리 코 등의 특징을 갖춘 특정 코끼리의 정신적 이미지가 떠오를 것입니다. Clyde가 가장 친숙한 코끼리였다면, 전형적인 코끼리는 Clyde 자체의 이미지일 수 있습니다. "코끼리는 다리가 몇 개인가요?"와 같은 질문을 받으면, 이 질문에 답하는 방법은 특별한 이유가 없는 한 Clyde의 다리 수와 동일하다고 가정하는 것입니다. Fred의 개념은 두 거대한 코끼리 사이에 정보를 공유하는 메커니즘으로, Clyde를 프로토타입으로 표시하는 연결을 가질 수 있습니다. Fred의 설명은 Fred 자체에 고유한 모든 정보를 저장할 수 있습니다. "Fred는 다리가 몇 개인가요?"라고 물으면, 반대 증거가 없는 한 Fred의 답이 Clyde와 동일하다고 가정합니다. 만약 Fred가 세 다리 코끼리라는 것을 알게 되면, 그 지식은 Fred와 함께 저장되며 프로토타입 참조 전에 항상 먼저 검색됩니다.

**2. 프로토타입이 개념의 점진적 학습에 갖는 이점**

집합의 개념이 수학에서 유용한 것으로 증명되었지만, 프로토타입 접근 방식은 어떤 면에서 사람들이 구체적인 상황에서 지식을 습득하는 방식에 더 가깝습니다. 집합이 갖는 어려움은 그 추상성에서 비롯됩니다. 사람들은 먼저 추상적인 일반 원칙을 흡수한 다음 특정 사례에 적용하는 것보다, 먼저 구체적인 예시를 다루고 그로부터 일반화하는 것에 더 능숙한 것으로 보입니다. 프로토타입 시스템은 먼저 개별 개념을 만든 다음, 개념의 어떤 측면이 변할 수 있는지를 명시함으로써 일반화할 수 있게 합니다. 집합 지향 시스템은 개별 인스턴스를 멤버로 설치하기 전에 먼저 집합의 추상적 설명을 만들어야 합니다.

수학에서 집합은 구성원을 열거하거나 집합의 구성원임을 식별하는 통일된 원칙을 설명함으로써 정의됩니다. 우리는 모든 코끼리를 열거할 수도 없고, 코끼리의 필수적인 속성 목록을 명확하게 만드는 데도 능숙하지 않습니다. 그럼에도 불구하고 새로운 개념을 만드는 주요 원동력은 항상 예시와의 경험인 것으로 보입니다. Clyde가 코끼리와의 유일한 경험이라면, 코끼리에 대한 우리의 개념은 Clyde의 개념과 다를 수 없습니다. 다른 코끼리들을 만난 후에야, Fred와 Clyde 같은 개념 사이에서 우리가 만드는 유사성이 코끼리의 중요한 특성을 선별하는 데 도움을 줍니다.

프로토타입은 기본값(defaults)에 관한 지식을 표현하는 데 더 적합한 것으로 보입니다. 회색이 코끼리 집합의 구성원임을 식별하는 특성 중 하나라고 주장한다면, 모순의 위험 없이 예외적인 흰 코끼리가 있다고 말할 수 없습니다. 그러나 흰 코끼리인 Fred가 흰색이라는 점을 제외하고는 Clyde와 똑같다고 말하는 것은 쉽습니다. Wittgenstein이 관찰했듯이, 어떤 특성이 개념에 필수적인지 미리 정확히 말하기는 어렵습니다. 새로운 예시가 생겨남에 따라 사람들은 항상 이전 개념과 새로운 유사성을 만들어 내어 해당 개념의 일부 "기본값"은 유지하고 다른 것은 무시할 수 있는 것으로 보입니다.

**3. 상속은 집합을 구현하고, 위임은 프로토타입을 구현한다**

개념 표현의 철학적 논의로 배경을 설정했으니, 이제 이러한 문제가 객체 지향 프로그래밍 시스템의 더 세속적인 구현 세부사항에 어떤 영향을 미치는지 살펴보겠습니다.

객체 지향 시스템에서 집합 이론적 접근 방식을 구현하는 것은 전통적으로 _상속_(inheritance)이라는 메커니즘을 통해 이루어집니다. 이는 처음에 Simula 언어에서 개척되었고, 나중에 SmallTalk, Flavors, Loops 등에서 채택되었습니다. _클래스_(class)라고 불리는 객체는 객체 집합에 대한 공통 동작을 인코딩합니다. 클래스는 또한 집합의 구성원 간에 어떤 특성이 달라질 수 있는지에 대한 설명을 포함합니다. 클래스는 집합의 구성원을 나타내는 _인스턴스_(instance) 객체를 생성하는 능력을 가지고 있습니다. 한 클래스의 모든 인스턴스는 동일한 동작을 공유하지만, 클래스에 의해 미리 선언된 상태 변수 집합에 대해 고유한 값을 유지할 수 있습니다. Clyde를 표현하기 위해, 코끼리의 이름을 위한 인스턴스 변수를 가진 코끼리 클래스에 대한 설명을 만듭니다. 이 값은 Clyde와 Fred를 구별하는 데 사용될 수 있습니다. 클래스는 클래스에 추가 변수와 동작을 더하는 _하위 클래스_(subclasses)를 만들 수 있습니다.

객체 지향 시스템에서 지식 공유에 대한 프로토타입 접근 방식을 구현하는 대안적 메커니즘은 _위임_(delegation)이라고 불립니다. 이는 액터(actor) 언어와 Director [Kahn 79], T [Rees 85], Orbit [Steels 82] 등 여러 Lisp 기반 객체 지향 시스템에 등장합니다. 위임은 클래스와 인스턴스 간의 구분을 제거합니다. 어떤 객체든 프로토타입으로 사용될 수 있습니다. 프로토타입과 지식을 공유하는 객체를 만들기 위해, 프로토타입 목록을 포함하는 _확장_(extension) 객체를 구성합니다. 이 프로토타입은 다른 객체와 _공유_(shared)될 수 있으며, 객체 자체에 특유한 _개인적_(personal) 동작도 포함됩니다. 확장 객체가 메시지를 받으면, 먼저 개인적 부분에 저장된 동작을 사용하여 메시지에 응답하려고 시도합니다. 만약 객체의 개인적 특성이 메시지에 답하는 데 관련이 없다면, 객체는 메시지를 프로토타입에 전달하여 하나가 메시지에 응답할 수 있는지 확인합니다. 이러한 전달 과정을 메시지를 _위임_(delegating)한다고 합니다. 코끼리 Fred는 개인적 부분에 Fred에 고유한 동작을 저장하고, 공유 부분에서 프로토타입 Clyde를 참조하는 확장 객체가 될 것입니다.

**4. 동작과 내부 상태를 표현하는 도구는 객체 지향 시스템의 구성 요소이다**

각 객체 지향 시스템은 객체의 동작을 정의하기 위한 언어적 메커니즘을 제공해야 합니다. 객체 지향 프로그래밍의 철학은 객체 표현을 사용하여 기존 언어의 절차와 데이터를 모두 인코딩하는 것입니다. 객체의 절차적 동작이나 데이터 내용을 한 번에 모두 정의하는 대신, 객체의 두 측면을 모두 이름으로 개별적으로 접근하거나 수정할 수 있는 부분 집합으로 나누는 것이 편리합니다.

객체의 내부 상태는 _변수_(variables) 또는 _지인_(acquaintances)으로 구성되며, 대부분의 객체 지향 시스템에서는 변수 이름으로 구성된 메시지를 객체에 보내 접근할 수 있습니다. 메시지에 응답하는 객체의 절차[액터에서는 이를 _스크립트_(script)라고 함]는 _메서드_(methods)라고 불리는 절차 집합으로 구성될 수 있습니다. 각 메서드는 이름으로 식별되는 객체가 수신하는 메시지의 특정 하위 집합만 처리하도록 특화되어 있습니다. 객체의 상태를 명명된 변수로 나누는 것은 다른 부분에 영향을 주지 않고 상태의 다른 부분을 점진적으로 수정할 수 있음을 의미합니다. 객체의 동작을 명명된 메서드로 나누는 것은 다른 부분에 영향을 주지 않고 동작의 다른 부분을 점진적으로 수정할 수 있음을 의미합니다. 그러면 언어는 메서드와 변수 그룹을 결합하여 객체를 형성하는 방법과 객체가 이전에 정의된 객체에 있는 동작[메서드 및 변수로 구현됨]을 공유할 수 있는 수단을 제공해야 합니다. 이러한 복합 객체를 _확장_(extensions)이라고 부를 것입니다. 이러한 구성 요소는 "_지식 공유를 위한 도구_" 그림에 추가 논의에 사용될 "아이콘"과 함께 표현되어 있습니다.

많은 객체 지향 언어는 메서드, 변수 및 확장이 있는 객체를 생성하기 위한 기본적인 언어 메커니즘을 제공합니다. 액터 형식에서 권장하는 대안적 접근 방식은 메서드, 변수 및 확장을 자체적으로 객체로 정의하고, 그들 간의 메시지 전달 프로토콜에 의해 동작이 결정되도록 하는 것입니다. 분명히, 메서드를 나타내는 객체는 그 자체가 메서드를 가질 수 없습니다. 그렇지 않으면 무한 재귀가 발생할 것입니다. 시스템에 기본적인 단순 객체를 사용하여, 변수는 이름과 값을 기억하고 접근 및 수정 메시지에 응답하는 객체로 정의됩니다. 메서드는 설계된 메시지에만 응답하고 다른 메시지는 거부합니다. 확장 객체는 위임을 사용하여 적절한 응답을 찾기 위해 객체의 한 부분에서 다른 부분으로 메시지를 전달합니다.

이미 객체 지향 프로그래밍의 유용성을 확신하는 모든 사람은 지식 공유 메커니즘의 구현에 객체 지향 프로그래밍을 사용하는 이점을 식별하는 데 큰 어려움이 없을 것입니다. 그 중 가장 중요한 것은 표준 버전에 대한 대안을 구현하는 다른 종류의 객체를 정의할 수 있는 능력입니다. 일반 변수 대신, 변경될 때 조치를 취하는 "활성" 변수, "읽기 전용" 변수, 심지어 "쓰기 전용" 변수를 갖고 싶을 수 있으며, 각각은 다른 유형의 변수 객체로 정의될 수 있습니다. 대안적인 종류의 메서드 객체는 기여 구성 요소에서 동작을 결합하는 데 다른 전략을 사용할 수 있으며, 소위 플레이버스(flavors) 시스템의 "메서드 결합" 기능을 대체하고 "다중 상속"을 더 쉽게 만듭니다. 다른 종류의 확장 객체는 복사와 공유의 문제에 대해 다른 효율성 절충을 할 수 있습니다.

![[Pasted image 20250304091242.png]]

객체 지향 언어에서 지식을 공유하는 메커니즘은 이제 너무 복잡해져서 최상의 메커니즘에 대한 보편적인 합의에 도달하는 것이 불가능해졌습니다. 상태와 동작이라는 기본 구성 요소를 구현하는 데 객체 지향 프로그래밍 자체를 사용하는 것이 경쟁하는 형식주의 간의 실험과 공존을 가능하게 하는 최선의 접근법입니다.

**5. Logo 예제로 위임과 상속의 차이점 설명**

Logo 터틀 그래픽 영역의 예제를 통해 위임과 상속 중 선택이 객체 지향 시스템의 제어 및 데이터 구조에 어떤 영향을 미치는지 설명하겠습니다. 위임 접근 방식은 "_위임을 통한 지식 공유_"라는 제목의 그림에 설명되어 있습니다. 우리가 먼저 하고 싶은 것은 펜을 나타내는 객체를 만드는 것입니다. 이 펜은 화면상의 위치를 기억하고, 이전 위치와 새 위치 사이에 선을 그리면서 다른 위치로 이동할 수 있습니다.

![[Pasted image 20250304091321.png]]

우리는 화면상에 특정 위치(x=200, y=50)를 가지고 draw 메시지에 응답하는 동작을 가진 원형적인(prototypical) 펜 객체를 만드는 것으로 시작합니다. 새로운 펜 객체를 만들고 싶을 때, 우리는 단지 첫 번째 펜과 다른 점만 설명하면 됩니다. 이 경우에는 x 변수입니다. y값과 draw 메시지에 대한 동작이 같기 때문에, 이들을 반복할 필요가 없습니다.

draw 메서드는 x 변수의 값을 사용해야 할 것이고, 올바른 x 값이 사용되는 것이 중요합니다. draw 메서드가 새 펜에서 이전 펜으로 위임될 때, 원래 펜의 draw 메서드가 호출되더라도 새 펜의 x 값이 사용되어야 합니다.

이를 보장하기 위해, 메시지가 위임될 때마다 원래 메시지를 받은 객체도 함께 전달해야 합니다. 이것은 Simula, SmallTalk 및 Flavors에서 SELF 변수라고 불립니다. 비록 제가 "self"라는 용어가 약간 오해의 소지가 있다고 생각하긴 합니다. 한 종류의 객체를 위해 원래 정의된 메서드가 종종 다른 종류의 "self"에게 보내지게 되기 때문입니다. 액터 용어에서 이 객체는 client라고 불립니다. 위임받는 객체가 원래 객체를 위해 서비스를 수행한다고 생각할 수 있기 때문입니다. 펜이 원형적인 펜에 draw 메시지를 위임할 때, 그것은 "나는 draw 메시지를 처리하는 방법을 모른다. 가능하다면 당신이 나를 위해 답변해 주었으면 한다. 하지만 내 x 변수의 값이 무엇인지와 같은 추가 질문이 있거나 무언가 필요하다면, 나에게 돌아와서 물어봐야 한다"고 말하는 것입니다. 메시지가 더 위임된다면, 변수 값에 관한 모든 질문이나 메시지에 응답하라는 요청은 모두 처음에 메시지를 위임한 객체에게 추론됩니다.

이제 원래 펜과 같은 위치에 터틀을 만들고 싶다고 가정해 봅시다. 원래 펜을 프로토타입으로 사용합니다. 터틀은 펜과 어떻게 다른가요? 터틀은 펜의 일부 동작을 공유하지만 추가적인 상태, 즉 방향(heading)을 가집니다. 방향을 기억하는 것은 draw 메시지에 대한 응답 동작에 의존하여 forward와 back 메시지에 응답할 수 있는 추가 동작을 구현하는 데 필수적입니다. 우리는 터틀의 draw 작업에 대한 새로운 동작을 제공하거나, 원래 펜이 제공하는 draw 작업에 의존하도록 선택할 수 있습니다.

이제 위임 대신 Simula와 SmallTalk에서 볼 수 있는 지식 공유에 대한 상속 접근 방식으로 동일한 예제를 살펴보겠습니다. 이는 "상속을 통한 지식 공유"라는 제목의 그림에 설명되어 있습니다. 상속을 사용하면 클래스를 나타내는 객체를 만들어야 합니다. 펜을 만들기 위해서는 먼저 동작과 변수 이름을 모두 지정하는 펜 클래스 객체를 만들어야 합니다.

개별 펜은 펜 클래스의 모든 인스턴스 변수에 값을 제공하여 인스턴스 객체를 생성함으로써 만들어집니다. 인스턴스에 고유한 값이 없더라도 모든 변수에 대한 값을 지정해야 합니다. 개별 펜에 새로운 동작을 연결할 수 없습니다. 동작을 확장하는 것은 새로운 하위 클래스를 생성하는 다른 작업으로 수행됩니다. 인스턴스에서 해당 클래스에 저장된 동작으로 이동하는 단계는 위임 접근 방식처럼 메시지 전달이 아니라 Simula 및 SmallTalk와 같은 시스템에서 "하드 와이어드" 조회 루프에 의해 수행됩니다.

새로운 동작으로 펜을 확장하려면 먼저 새로운 클래스 객체를 만들어야 합니다. 여기서 터틀 클래스는 forward 메시지에 대한 새로운 동작과 함께 새로운 방향(heading)을 추가합니다. 펜 클래스의 변수인 x와 y가 터틀 클래스로 복사되었음을 주목하세요. 개별 터틀 인스턴스는 해당 클래스, 상위 클래스 등의 모든 변수에 대한 값을 제공해야 합니다. 이러한 복사로 인해 상속 계층에서 점점 더 아래로 내려가는 클래스의 인스턴스 객체가 더 커집니다. 원시적이고 변경할 수 없는 루틴에 의해 수행되는 메서드 조회는 객체의 클래스에서 메서드 검색을 시작하고 하위 클래스에서 상위 클래스 체인으로 진행됩니다.

펜 클래스에서 터틀 클래스로 상속된 메서드는 터틀 클래스에서 구현된 메서드에 어떻게 접근할까요? 상속 시스템은 일반적으로 하위 클래스에서 상위 클래스로 통신하기 위해 메시지 전달을 사용하지 않기 때문에, 위임에서처럼 메시지에 터틀 객체를 함께 전달할 수 없습니다.

![[Pasted image 20250304091443.png]]

펜 클래스에서 터틀 클래스로 상속된 메서드는 터틀 클래스에서 구현된 메서드에 어떻게 접근할까요? 상속 시스템은 일반적으로 하위 클래스에서 상위 클래스로 통신하기 위해 메시지 전달을 사용하지 않기 때문에, 위임에서처럼 메시지에 터틀 객체를 함께 전달할 수 없습니다. 대신 대부분의 시스템은 메시지를 원래 받는 객체에 특별한 변수 self를 바인딩하기 위해 변수 바인딩을 사용합니다. 나중에 이것이 문제를 야기한다는 것을 볼 것입니다.

또한, 상속 시스템은 인스턴스의 모든 변수를 바인딩하는 "지름길"을 허용하여 메서드의 코드에서 자유 변수로 직접 참조할 수 있게 합니다. 이것이 때로는 더 효율적이지만, 메시지 전달 메커니즘을 우회하여 객체 지향 프로그래밍의 특징인 내부 표현의 독립성을 무력화합니다. 변수 참조는 메시지 전송과 다른 언어적 구문을 사용하기 때문에, 좌표 표현을 x와 y에서 rho와 theta를 사용하는 극좌표로 변경하고 싶다면 모든 참조 메서드를 변경해야 합니다. x와 y에 접근하기 위해 메시지 전달 방식을 고수한다면, 좌표가 극좌표로 변경되더라도 우리는 여전히 극좌표에서 직교좌표를 계산하는 메서드를 제공할 수 있으며, 이러한 변경은 투명하게 이루어질 것입니다.

이 다이어그램들이 위임 접근 방식이 더 간단하다는 인상을 남겼기를 바랍니다. 두 개의 펜과 하나의 터틀을 만들기 위해, 상속 접근 방식은 펜 클래스 객체와 터틀 클래스 객체를 만드는 추가 단계가 필요합니다. 또한, 우리는 하위 클래스 링크와 인스턴스 링크라는 두 가지 다른 종류의 객체 간 링크가 필요한 반면, 위임 접근 방식은 연결된 객체 간의 메시지 전달 관계만 필요로 합니다.

**6. 상속과 위임은 동일한 표현력을 가지고 있는가?**

상속과 위임에 관한 앞선 논의에서 당연히 제기되는 질문은 두 기술이 동일한 표현력을 가지고 있는지 여부입니다. 그 답은 _아니오_입니다.

위임이 주어진다면, 우리는 상속의 기능을 어떻게 구현할 수 있는지 쉽게 알 수 있습니다. 새로운 인스턴스를 생성하라는 메시지에 응답하는 특별한 클래스 객체를 만들 수 있습니다. 클래스 객체가 인스턴스를 생성할 때 상위 클래스 체인에서 변수를 복사하는 것을 관찰하도록 배치하기만 하면 됩니다. 인스턴스 객체에는 대략 다음과 같이 조회 메서드를 구현하는 동작이 주어집니다.

```
만약 내가 인스턴스(INSTANCE) 객체이고

메시지를 받는다면

선택자(SELECTOR)와 일부 인수(ARGUMENTS)와 함께:

만약 선택자가 

내 클래스[또는 상위 클래스 등]의

변수(VARIABLE) 이름 중 하나와 일치한다면,

나는 자신에게 저장된 

해당 값을 반환합니다.

그렇지 않으면, 나는 메서드를 찾습니다

그 이름(NAME)이

메시지의 선택자와 일치하는

내 클래스의 

로컬 메서드 목록에서.

만약 하나를 찾는다면,

나는 변수 SELF를 나 자신에게 바인딩합니다

[인스턴스 객체에게].

나는 내 클래스의 

변수 이름들을 바인딩합니다,

[그리고 상위 클래스 체인 위로 

모든 변수들을]

인스턴스에 있는 그들의 값에.

그런 다음 나는 메서드를 호출합니다.

만약 내 클래스의 메서드 목록에 

메서드가 없다면,

나는 상위 클래스에서 

메서드를 찾으려고 시도합니다,

그리고 상위 클래스 체인을 계속 올라갑니다.
```

반대로는 어떨까요? 상속이 위임을 구현할 수 있을까요? 불행히도 그렇지 않습니다. 그 이유는 이해하기 약간 까다롭지만, self 변수의 처리와 관련이 있으며, 이는 메시지 전달의 적절한 구현을 방해합니다.

종종, 메시지를 처리하는 메서드는 원래 메시지를 받은 객체에게 어떤 서비스를 수행하도록 요청해야 할 수 있습니다. back 메시지를 받은 터틀 객체는 그것을 forward 메시지로 변환하여 동일한 객체에게 보내고 싶지만, 단계 수를 부정하여 back 100이 forward -100과 같아지게 하고 싶습니다. 위임에서는 메서드가 메시지를 위임받을 때, 위임 메시지에 client라고 불리는 컴포넌트를 받게 됩니다. 이 컴포넌트는 원래 메시지를 받은 객체를 가지고 있습니다.

상속 시스템에서는 self라는 특별한 변수가 메서드의 코드가 실행되는 동안 메시지 수신자에게 자동으로 바인딩됩니다. 메서드 검색이 원래 클래스에서 상위 클래스로 진행될 때, self 변수의 값은 변경되지 않습니다. 그래서 상위 클래스 메서드는 마치 원래 객체의 메서드인 "것처럼" 메시지에 응답할 수 있습니다. 그러나 사용자가 메시지를 보낼 때, self 변수는 항상 다시 바인딩되므로, 사용자가 원래 메시지를 받은 객체 대신 다른 객체가 응답하도록 지정하는 것은 일반적으로 _불가능_합니다. 이러한 시스템에서는 진정한 위임을 구현할 수 없습니다.

"SELF 문제"라는 그림에 설명된 예제를 통해 이를 명확히 할 수 있습니다. 특정 터틀 객체를 확장하여 실선 대신 점선을 그리는 터틀을 만들고 싶다고 가정해 봅시다. 이를 수행하는 명백한 방법은 점선 터틀이 forward 메시지를 가로채서 간격을 여러 조각으로 나누고, 일련의 더 짧은 선을 그리라는 메시지를 실선 터틀에게 위임하는 것입니다. 상속 시스템에서 점선 터틀이 단순히 실선 터틀에게 forward 메시지를 보내면, self는 실선 터틀에 바인딩될 것입니다. 우리가 이전에 forward를 기반으로 구현한 back은 더 이상 작동하지 않게 됩니다. 점선 터틀에게 뒤로 가라는 메시지를 보내면 self에게 forward 메시지를 보내려고 시도하여 점선 대신 실선을 그릴 것이기 때문입니다!

이 예제를 상속 시스템을 사용한 대안적 구현과 혼동하지 않도록 주의하세요. 대안적 구현에서는 실선 터틀 클래스의 하위 클래스로 점선 터틀 클래스를 만들 것입니다. 이러한 구현은 back 메시지에 관해서는 올바른 동작을 할 수 있지만, 여전히 위임의 구현으로 간주되지 않을 것입니다. 우리가 시도하던 것은 객체가 어떤 다른 _이미 존재하는_ 객체에게 메시지를 전달할 수 있는지 확인하는 것이었음을 기억하세요. 점선 터틀 인스턴스는 실선 터틀의 인스턴스에 어떤 메시지도 전달하지 않을 것입니다. 단지 실선 터틀로부터 변수와 메서드의 복사본을 상속받을 뿐입니다.

**7. 효율성은 어떨까?**

위임과 상속 사이의 효율성 비교는 결국 시간/공간 트레이드오프로 귀결됩니다. 일부는 상속이 더 적은 메시지를 필요로 하기 때문에 더 효율적이라고 주장했지만, 이는 객체 크기를 증가시키는 대가로 이루어집니다. 변수가 상위 클래스에서 하위 클래스로 복사되기 때문에, 상속 계층에서 아래로 내려갈수록 인스턴스는 점점 커지게 됩니다. 위임을 사용하면 각 객체는 이미 존재하는 프로토타입과 다른 점만 지정하면 되므로, 객체의 크기는 반드시 공유 객체 계층의 깊이에 의존하지 않습니다. 펜과 터틀 객체의 데이터 구조를 보여주는 다이어그램을 살펴보면 상속의 속도 이점과 위임의 공간 이점을 확인할 수 있습니다.

작은 객체는 객체 생성 시간을 더 빠르게 만들며, 이는 수명이 긴 적은 수의 큰 객체가 아닌 수명이 짧은 많은 수의 작은 객체를 생성하는 시스템에서 중요할 수 있습니다. 객체 크기를 줄이면 참조의 지역성을 개선하여 주 메모리에 자주 참조되는 객체의 밀도를 높임으로써 가상 메모리의 효율성도 향상될 수 있습니다. [Lieberman and Hewitt 83]에 설명된 것과 같은 복사 가비지 컬렉터를 사용하면, 작은 객체는 복사 오버헤드를 줄여 가비지 컬렉션의 효율성을 향상시킬 수 있습니다.

구현자들은 위임 접근 방식에서 메서드와 변수를 찾는 데 필요한 검색에 겁먹지 말아야 합니다. 검색 시간을 줄이기 위한 간단하고 효과적인 요령이 있습니다: 조회 결과를 _캐싱_(caching)하는 것입니다. 캐시는 공간을 속도로 교환하는 방법으로, 위임이 만드는 속도-공간 트레이드오프의 부정적 영향을 완화합니다. 캐시는 인스턴스 변수를 무차별적으로 복사하는 것보다 여분의 메모리를 더 효과적으로 사용합니다. 왜냐하면 그들이 사용하는 메모리는 반드시 지속적으로 사용되기 때문입니다. 캐시는 복사 및 컴파일 최적화가 하는 방식으로 프로그래밍 환경을 대화식으로 수정하는 유연성을 제한하지 않습니다.

![[Pasted image 20250304091724.png]]

기존 머신에서는 아마도 위임의 어떤 구현도 레지스터와 스택 인덱싱을 통한 변수 조회의 순수한 속도를 능가하지 못할 것입니다. 그러나 변수 조회 속도를 높이려는 열정으로 인해, 구현자들은 객체 지향 언어에 큰 객체 크기와 같은 결정을 강요했으며, 이는 효율성에 부정적인 영향을 미칩니다. 큰 주소 공간을 가진 병렬 머신은 그러한 레지스터 지향 최적화의 매력을 퇴색시킬 것입니다.

SmallTalk [Krasner 84]는 중간 크기의 캐시, 1000개 객체에 대해 93%의 "히트율"을 보고합니다. 이는 조회에서 위임보다 상속으로 인한 절약이 기껏해야 나머지 7%에만 영향을 미칠 수 있음을 의미합니다. 가장 좋은 방법은 전역 캐시를 유지하고, 공유 계층에 어떤 변경이 이루어질 때마다 캐시를 무효화하는 것 같습니다. 그러면 변경으로 인해 다음 1000개의 메시지 동안, 또는 캐시가 다시 채워지는 데 걸리는 시간 동안 시스템이 느려질 것입니다. 객체별 캐시와 같은 "더 똑똑한" 대안은 전역 캐시의 히트율이 매우 높기 때문에, 점진적 소프트웨어 수정에 문제를 일으킬 수 있어 추가적인 수고를 할 가치가 없을 것입니다. 상속과 위임 모두 거의 동등하게 효율적으로 구현될 수 있기 때문에, 효율성을 이유로 위임의 추가적인 유연성을 희생할 이유가 거의 없어 보입니다.

**8. I/O 스트림 재지정이 위임의 중요한 응용을 보여준다**

많은 객체 지향 시스템은 입출력 스트림을 구현하기 위해 객체 지향 프로그래밍 기법을 잘 활용합니다. 이러한 스트림은 문자, 텍스트 한 줄, 표현식을 입력하거나 출력하라는 메시지를 받는 객체입니다. 시스템은 일반적으로 입력과 출력의 "현재" 소스를 지정하는 전역 변수를 가지고 있으며, 이는 기본적으로 인터랙티브 디스플레이 화면의 창에 표시되는 문자 스트림을 나타내는 객체에 바인딩됩니다.

"스트림"이라는 이름은 사용자와 시스템 사이의 문자나 픽셀의 지속적인 흐름을 암시합니다. 매우 유용한 종류의 객체는 스트림을 다른 목적지로 전환하는 "댐"이나 한 스트림을 다른 스트림과 연결하는 "배관"을 구현하는 것입니다. 드리블 파일(dribble file)은 일시적인 픽셀의 깜빡임보다 더 영구적인 상호작용 기록을 제공하기 위해 입출력 상호작용의 이력을 디스크에 기록하는 순차 파일입니다. 드리블 파일은 터미널에서의 상호작용을 나타내는 스트림을 디스크에도 쓰는 스트림으로 대체하여 구현할 수 있습니다.

드리블 스트림은 터미널 스트림으로 가장할 수 있는 능력이 필요합니다. 일반 터미널 스트림이 가진 모든 메시지에 대해 동일한 응답을 해야 하며, 디스크에 쓰는 추가 동작도 제공해야 합니다. 입출력을 수행하는 모든 프로그램의 관점에서 스트림은 구별할 수 없어야 합니다.

드리블 스트림을 깔끔하게 구현하기 위해, 드리블 스트림의 구현이 대체하는 스트림의 정확한 구현 세부 사항을 알 필요가 없도록 하고 싶습니다. 예를 들어, 직접 연결된 인터랙티브 터미널에 대한 스트림과 네트워크를 통해 상호작용하는 스트림 모두에 단일 드리블 스트림을 사용하고 싶을 수 있습니다.

![[Pasted image 20250304091956.png]]

위임을 사용한 구현은 편리하고 간단합니다. 문자 출력을 수행하는 메시지가 가로채어지고 디스크 출력이 중간에 삽입됩니다.

```
DRIBBLE-STREAM은 STREAM에서의 
 상호작용을 기록하고, 
 FILE-NAME을 사용하여 디스크에 
 기록하는 객체입니다.

만약 내가 DRIBBLE-STREAM이고 
 CHARACTER를 입력하거나 출력하라는 
 메시지를 받는다면,
나는 FILE-NAME에 대한 디스크 스트림에 
 CHARACTER를 출력합니다.
그런 다음 CHARACTER를 출력하라는 
 메시지를 원래 STREAM에 위임합니다.

만약 내가 DRIBBLE-STREAM이고 
 다른 메시지를 받는다면, 
 나는 단순히 그 메시지를 
 STREAM에 위임합니다.
```

단일 문자 입력 및 출력 메시지만 처리하는 것이 작동하는 이유는, 객체 출력과 같은 모든 상위 수준 메시지가 결국 단일 문자 버전으로 구현되기 때문입니다. 상위 수준 출력 작업을 수행하는 메서드는 결국 문자 출력 메시지를 클라이언트에게 보낼 것입니다[self에게 보냄].

놀랍게도, 많은 상속 시스템은 스트림 동작의 이러한 단순한 확장을 구현하기 어렵게 만듭니다. 한 가지 문제는 Flavors나 SmallTalk와 같은 시스템이 각 유형의 메시지를 처리하기 위한 별도의 절차를 정의하는 것을 고집한다는 점입니다. 이런 종류의 시스템에서 드리블 스트림을 스트림의 하위 클래스로 구현하려고 시도하면, "...그리고 모든 관련 없는 메시지를 원래 스트림으로 전달하라"고 말할 쉬운 방법이 없다는 것을 알게 될 것입니다. 디스크에 쓰기 위해 문자 출력 메시지를, print 메시지를 가로채기 위한 또 다른 메서드, print-line 메시지를 가로채기 위한 또 다른 메서드 등, 모든 관련 메시지에 대해 하나씩 메서드를 정의해야 할 것입니다. 원래 스트림에 다른 메시지가 추가될 때마다 지루하게 반복되는 코드로 드리블 스트림에 또 다른 메서드를 추가해야 합니다. 이는 또한 드리블 스트림의 구현이 이제 내장된 스트림이 정확히 어떤 메시지를 수락하는지에 대한 세부 사항에 민감하게 만들어, 다른 유형의 스트림과 함께 구현을 재사용하는 능력을 저해하는 불행한 효과를 가집니다.

시스템에 드리블 스트림 클래스나 Flavor의 정의를 추가하는 것은 드리블 스트림 객체의 새 인스턴스를 만드는 능력만 제공할 것입니다. 이전에 존재하던 스트림 객체를 사용하는 드리블 스트림을 만드는 것은 불가능할 것입니다. 그러면 기록 기능을 활용하기 위해 새로운 터미널 스트림, 네트워크 스트림 또는 다른 종류의 스트림을 만들어야 할 것입니다. 드리블 기능을 갖기 위해 시스템의 모든 종류의 스트림을 복제할 필요는 없어야 합니다!

대신, 상호작용 스트림을 인스턴스 변수 중 하나로 보유하는 드리블 스트림을 만들려고 하면, 드리블 스트림이 print와 같은 메시지를 변수의 값에 올바르게 전달할 방법이 없다는 문제에 직면합니다. 이러한 시스템이 self 변수를 처리하는 방식 때문에, 원래 스트림에 메시지를 전달하는 것은 터틀 예제와 같은 이유로 작동하지 않을 것입니다. 인스턴스 변수에 print 메시지를 보내면 self 변수가 다시 바인딩되므로, 하위 수준 메시지를 드리블 스트림이 아닌 직접 상호작용 스트림에 보내는 결과가 될 것입니다. 따라서 많은 상속 시스템에서 드리블 스트림을 단순한 동작 확장으로 구현하려는 어떤 직관적인 시도도 실패할 것으로 보입니다.

**9. 병렬성은 SELF 변수로 인해 상속 시스템에 문제를 일으킨다**

스트림이 둘 이상의 병렬 프로세스로부터 메시지를 받을 수 있는 경우에 추가적인 문제가 있습니다. 스트림이 수정 가능한 상태[화면 비트맵과 같은]를 가지고 있기 때문에, 스트림은 두 프로세스가 동시에 스트림에 쓰려고 시도하는 데서 발생하는 타이밍 오류로부터 보호되어야 합니다. 직렬화 객체[Hewitt, Attardi, Lieberman 79] 또는 모니터와 같은 기술을 사용해야 합니다. 이는 스트림이 쓰기 메시지를 받을 때 "잠금"되어, 스트림에 대한 후속 메시지가 스트림이 첫 번째 쓰기 메시지 처리를 마칠 때까지 대기열에서 기다려야 함을 의미합니다.

이제, 드리블 스트림에 대한 메시지가 self 변수에 문자 출력 메시지를 보내어 print 메시지를 처리하려고 하면, self가 바로 그 print 메시지가 완료되기를 기다리며 잠겨 있는 스트림에 바인딩되어 있음을 발견하게 됩니다! 교착 상태(Deadlock)입니다!

위임은 메시지 전달을 사용하기 때문에, 드리블 스트림이 터미널 시스템에 위임할 때 [위임 메시지의 클라이언트로] _직렬화되지 않은_ 버전의 자신을 제공할 수 있으며, 이는 기다리지 않고 메시지를 처리할 수 있습니다.

**10. 위임은 여러 소스에서 동작을 결합하는 데 상속보다 더 유연하다**

종종, 객체는 이미 존재하는 둘 이상의 다른 객체에 나타나는 동작을 활용하고자 합니다. 시스템이 특정 "기능"을 구현하는 데 필요한 동작은 단일 객체로 패키징될 수 있으며, 때로는 객체가 동작을 구현하기 위해 이러한 기능 중 여러 개를 결합하려고 할 수 있습니다. 예를 들어, 창(window) 객체는 제목, 테두리, 크기 조정 등을 가질 수 있습니다. 특정 창 객체는 이러한 기능 중 일부를 선택하고 다른 것은 선택하지 않을 수 있습니다. 기능은 서로 독립적일 수도 있고, 상호작용할 수도 있습니다.

상속 시스템에서의 해결책은 공유하고 싶은 동작을 가진 다른 클래스의 목록을 언급하는 클래스 객체를 만드는 것입니다. 클래스에 언급된 모든 메서드와 변수는 결합된 객체에 의해 상속됩니다. Flavors와 같은 시스템은 메서드별로 선택적으로 둘 이상의 컴포넌트가 메서드를 기여할 때 동작을 결합하는 방법에 대한 옵션을 제공합니다. 일반적인 옵션은 모든 기여 메서드를 호출하거나, 순서를 부과하거나, 결과 목록을 반환하는 것입니다.

여러 소스에서 동작을 결합하는 이 스타일의 문제점은 인스턴스 객체가 생성되기 전에 객체 간의 통신 패턴을 고정한다는 것입니다. 이는 이전에 존재하는 객체의 동작이 동적으로 사용될 수 있는 범위를 제한합니다. 반면에, 위임을 사용하면 객체가 메시지를 받는 시점에 통신 패턴을 결정할 수 있습니다.

위임을 사용하면, 확장 객체의 메서드는 공유 목록에서 동작을 파생시키는 원형적인 객체에 간단히 접근할 수 있습니다. 테두리 역할을 하는 이전에 정의된 직사각형 객체의 draw 동작을 호출하려는 창은 단순히 draw 메시지를 직사각형 객체에 위임할 수 있습니다. 따라서 위임은 "메서드 결합"이나 비통상적인 결합 연산의 인벤토리를 필요로 하지 않습니다. 동작은 단순히 결합된 확장 객체에 대한 메서드에 프로그래밍됩니다. 프로그래머가 공통 결합 기술의 라이브러리를 구축하고자 한다면, 표준 메서드 객체의 변형을 구성함으로써 쉽게 할 수 있으므로, 위임은 상속 시스템의 메서드 결합만큼 간결하게 만들 수 있습니다. 상속을 사용하면, 창 클래스가 "테두리 믹스인(borders mixin)"을 포함하는 경우, 창은 테두리를 나타내는 독립적인 객체를 포함하지 않으므로 창 객체 자체와 독립적으로 창의 테두리에 메시지를 보내는 것이 불가능합니다. 창 클래스는 단지 테두리 및 다른 기여 컴포넌트에서 상속된 메서드와 변수의 혼합물을 포함합니다.

높은 반응성을 가진 인터랙티브 시스템에서는 종종 메시지가 수신될 때까지 기다렸다가 컴포넌트 객체의 동작을 어떻게 활용할지 결정해야 할 필요가 있습니다. 다음은 여러 소스에서 동작의 동적 활용이 필요한 간단한 예로, "_위임은 런타임에 통신 패턴을 결정할 수 있게 한다_"라는 그림에 설명되어 있습니다.

테두리가 있는 비트맵(bordered bitmap)은 테두리를 표시할 수 있는 직사각형과 픽셀 배열을 화면으로 전송할 수 있는 비트맵으로 구성될 수 있습니다. 테두리가 있는 비트맵의 draw 응답은 어떻게 해야 할까요? 상속을 사용하면 직사각형과 비트맵 모두에서 상속받는 테두리가 있는 비트맵 클래스를 만들고, 두 draw 메서드를 모두 사용한다고 명시합니다. 이는 괜찮습니다.

그러나 이제 사용자에게 어떤 동작이 사용될지 동적으로 변경할 수 있는 옵션을 제공하고 싶다고 가정해 봅시다. 비트맵이 화면을 가로질러 드래그될 때, 모든 마우스 움직임마다 전체 배열을 전송하는 것은 너무 느릴 수 있으므로, 대신 비트맵의 윤곽선만 드래그하는 옵션을 사용자에게 제공하는 것이 바람직할 수 있습니다. 합리적인 방법은 사용자에게 동작을 결정할 수 있는 화면상의 토글 스위치를 제공하는 것이며, 사용자는 언제든지 동작을 변경할 수 있습니다. 따라서 테두리가 있는 비트맵의 동작은 객체가 생성되기 전에 결정될 수 없습니다. 위임을 사용하면, 테두리가 있는 비트맵이 draw 메시지를 받았을 때, 포함하고 있는 직사각형 객체에 메시지를 위임할지, 비트맵 객체에 위임할지, 또는 둘 다에 위임할지 결정할 수 있습니다.

![[Pasted image 20250304092216.png]]

상속 시스템은 제가 _단일 인스턴스 클래스 문제_라고 부르는 것으로도 골치를 앓고 있습니다. 시스템이 약간씩 다른 동작을 가진 많은 수의 객체로 구성될 때, 단지 하나 또는 몇 개의 인스턴스를 갖기 위해 새로운 클래스 객체를 자주 만들어야 하는 상황에 처하게 됩니다. "넓은 테두리, 타임스 로만 폰트, 제목 없음"과 같은 특성을 가진 창을 단일 인스턴스를 위해 특성을 결합하는 애드혹(ad-hoc) 클래스를 만들어야 합니다.

**11. 위임은 고도로 인터랙티브하고 점진적인 소프트웨어 개발에 유리하다**

상속과 위임 사이의 트레이드오프를 평가할 때 고려해야 할 중요한 문제는 점진적 소프트웨어 개발에 미치는 영향입니다. 위에서 보았듯이, 상속은 변수와 메서드의 복사를 장려하는 반면, 위임은 공유를 장려합니다. 원형적인 객체가 동작을 변경하면, 공유 목록에 해당 프로토타입을 언급하는 모든 객체는 자동으로 변경을 "느낄" 것입니다. 새로운 인스턴스 변수를 추가하거나 클래스 구조를 변경하는 등 상속 계층에 변경이 이루어지면, 이전 데이터 구조에서 복사된 정보가 쓸모없게 될 수 있습니다. 변경 결과를 복사본에 브로드캐스팅하는 것은 소프트웨어 환경에서 점진적 변경을 수행하는 작업에 부담을 줍니다. 이의 극단적인 예는 Flavors 시스템에서 발생하는데, 상속 계층의 뿌리인 vanilla-flavor에 단순히 메서드를 추가하는 것이 전체 시스템의 모든 flavor를 재컴파일해야 하는 결과를 가져옵니다! 이는 사실상 상속 계층의 상단에 있는 객체에 대한 어떠한 수정도 금지합니다.

위임은 객체 지향 언어에서 소수 의견이었지만, 추가된 힘과 유연성 때문에 점차 중요하게 인식되고 있습니다. 위임 접근 방식이 간과된 이유 중 일부는 역사적입니다. 최초의 객체 지향 언어 중 하나인 Simula는 상속 기법을 채택했습니다. 이는 Algol 계열의 컴파일 언어에 적합했던 것처럼, 컴파일 시간에 객체 간 통신 패턴을 고정했습니다. 이러한 특정 메커니즘은 이후 접근 방식이 더 높은 인터랙티브 프로그래밍 환경에서 해석적 언어에 여전히 적합한지 재고하지 않고 SmallTalk 및 다른 언어에 의해 "상속"되었습니다. 앞선 논의가 프로토타입을 사용하여 개념을 모델링하고 위임을 사용하여 객체 지향 언어에서 동작을 구현하는 접근 방식이 클래스와 상속을 사용하는 대안적 관점보다 뚜렷한 이점을 가지고 있다는 것을 여러분에게 확신시켰기를 바랍니다.

**12. 감사의 글**

이 논문에서 설명한 연구에 대한 주요 지원은 System Development Foundation에서 제공되었습니다. MIT 인공지능 연구소의 다른 관련 연구는 ONR 계약 N00014-80-C-0505에 따라 DARPA의 일부 지원을 받았습니다.

Carl Hewitt의 액터(actors)에 관한 아이디어, 그리고 특히 병렬성이 객체 지향 프로그래밍에 미치는 영향에 관한 그의 견해는 중요한 영향을 주었습니다. Kenneth Kahn과 Luc Steels는 위임 메커니즘을 채택한 객체 지향 언어를 구현했으며 이러한 아이디어에 영향을 주었습니다. Alan Borning은 SmallTalk로 구현된 ThingLab 시스템의 맥락에서 유사한 결론에 도달했습니다. Koen de Smedt는 네덜란드 나이메헨에서 이러한 문제에 관해 제가 발표한 강연에 대해 유용한 비평을 제공했습니다.