문법적으로 부정확하고 어쩌면 이상한 질문처럼 들릴 수 있지만, 제가 의미하는 다음과 같습니다: JavaScript에서 `prototype` 개념을 이해하려고 할 때, 다음과 같은 예제의 조금 더 복잡하거나 덜 복잡한 버전들을 발견했습니다:
```javascript
//Guitar function constructor
function Guitar(color, strings) {
    this.color = color;
    this.strings = strings;
}

//Create a new instance of a Guitar
var myGuitar = new Guitar('Black', ['D', 'A', 'D', 'F', 'A', 'E']);

//Adding a new method to Guitar via prototype
Guitar.prototype.play = function (chord) {
    alert('Playing chord: ' + chord);
};

//Now make use of this new method in a pre-declared instance
myGuitar.play('D5');
```

그래서 문제는: 도대체 왜 이렇게 해야하나요? 왜 처음부터 그냥 `play` 함수를 `Guitar`에 넣지 않는 건가요? 왜 인스턴스를 선언하고 나서 나중에 메서드를 추가하기 시작하나요? 제가 볼 수 있는 유일한 이유는 `myGuitar`가 처음 생성될 때 `play`에 접근하지 못하게 하고 싶은 경우인데, 왜 이런것을 원하는지에 대한 이유를 설명하는 예시를 전혀 떠올릴 수 없습니다.

다음과 같이 하는게 훨씬 더 말이 된다고 생각합니다:
```javascript
function Guitar(color, string) {
    this.color = color;
    this.strings = strings;
    this.play = function (chord) {
        alert('Playing chord: ' + chord);
    };
}
var myGuitar = new Guitar('White', ['E', 'A', 'D', 'G', 'B', 'E']);
myGuitar.play('E7#9');
```

실제로는 첫 번째 예제가 어떤 이유로 더 나은 방법일 텐데, 제게는 오히려 두 번째 에제가 이해가 되고 첫 번째 예제는 이해가 되지 않는다는 것이 진짜 문제입니다. 안타깝게도, 제가 지금까지 찾은 모든 튜토리얼들은 단지 `prototyp`을 사용하는 방법만 설명할 뿐, 애초에 왜 `prototype` 패러다임이 존재하는지는 설명하지 않습니다.

`prototype`은 다른 방법으로는 할 수 없는 일들을 할 수 있게 해주는 것 같은데, 왜 그런 일들을 하고 싶어할지에 대한 좋은 이유를 떠올릴 수가 없습니다.

## 답변 1

JavaScript는 '고전적인' 상속 언어가 아닙니다. 프로토타입 상속을 사용합니다. 그냥 그렇게 설계되어 있습니다. 이러한 경우, '클래스'에 메서드를 생성하는 올바른 방법은 프로토타입에 메서드를 넣는 것입니다. 엄밀히 말해서 JS에는 '클래스'라는 개념이 없기 때문에 '클래스'를 따옴표로 표시했습니다. JS에서는 함수로 정의되는 객체들을 다룹니다. 

Guitar를 정의하는 함수 안에 메서드를 선언할 수 있지만, 그렇게 하면 새로운 guitar마다 play 메서드의 *자체* 복사본을 갖게 됩니다. Guitar를 생성하기 시작할 때 프로토타입에 메서드를 넣는 것이 런타임 환경에서 더 효율적입니다. 모든 인스턴스가 동일한 play 메서드를 공유하지만, 호출될 때 컨텍스트/스코프가 설정되므로 고전적인 상속 언어에서 익숙한 적절한 인스턴스 메서드처럼 작동합니다.

차이점을 주목하세요. 귀하가 게시한 '이렇게 하면 안 될까요' 예제에서는 새로운 Guitar를 생성할 때마다 다른 모든 play 메서드와 동일한 새로운 play 메서드를 생성해야 합니다. 하지만 play가 프로토타입에 있다면, 모든 Guitar들이 같은 프로토타입을 빌려 쓰므로 모두 동일한 play 코드를 공유합니다. 이는 각각 동일한 play 코드를 가진 *x*개의 기타들(따라서 play의 *x*개 복사본을 가짐)과 동일한 play 코드를 공유하는 *x*개의 기타들(기타가 몇 개이든 play의 복사본은 1개) 사이의 차이입니다. 물론 트레이드오프는 런타임에 play가 스코핑을 위해 호출되는 객체와 연결되어야 한다는 것이지만, 자바스크립트는 이를 매우 효율적이고 쉽게 수행할 수 있는 메서드들을 가지고 있습니다(즉, `call`과 `apply` 메서드).

많은 자바스크립트 프레임워크들이 '클래스'를 생성하기 위한 자체 유틸리티들을 정의합니다. 일반적으로 그들은 귀하가 보고 싶다고 말씀하신 예제와 같은 코드를 작성할 수 있게 해줍니다. 내부적으로는 그들이 당신을 위해 함수들을 프로토타입에 넣고 있습니다.

## 답변 2
### 시작하기 전 참고사항
ActionScript 1과 2가 런타임에서 동일한 동작을 보이기 때문에, 여기서는 JavaScript 대신 ECMAScript를 사용하고 있습니다.

### "전통적인" OOP와의 차이점
Java, C#, PHP와 같은 "전통적인" 객체 지향 세계에서 일하는 우리에게 런타임에 클래스를 확장한다는 개념은 매우 생소합니다. 우리가 알던 OBJECT는 이미 정해진 일을 수행하고, 자식 클래스는 다른 CLASS를 EXTEND하는 것이 전부였습니다. 이는 매우 구조화되고 견고하며 변경 불가능한 느낌을 줍니다. 대체로 이러한 방식은 잘 작동하며, 이것이 바로 Gosling이 주장했던(그리고 대부분이 동의하는) 대규모 시스템에 적합한 이유입니다.

### ECMAScript의 OOP 접근 방식
반면 ECMAScript는 훨씬 더 원시적인 OOP 개념을 따릅니다. ECMAScript에서 클래스 상속은 믿기 힘들겠지만 거대한 데코레이터 패턴(decorator pattern)입니다. 이는 C++이나 Python에서 볼 수 있는 일반적인 데코레이터 패턴과는 다릅니다. ECMAScript는 인스턴스에 클래스 프로토타입을 할당할 수 있게 해줍니다.

Java에서 다음과 같은 코드를 상상해보세요:

```java
class Foo {
    Foo(){}
}

class Bar extends new Foo() {
    // 이런 미친 짓이!
}
```

하지만 이것이 바로 ECMAScript에서 가능한 일입니다(Io 언어도 이와 비슷한 것을 허용하는 것으로 알고 있지만, 확실하지는 않습니다).

### Lambda 계산과의 연관성
이러한 설계 철학이 원시적이라고 말한 이유는 McCarthy가 Lisp를 구현하기 위해 Lambda 계산을 사용한 방식과 매우 밀접하게 연관되어 있기 때문입니다. 이는 Java OOP보다 클로저(closure)의 개념과 더 관련이 있습니다.

### Lambda 계산의 역사적 맥락
과거 Alonzo Church는 'The Calculi Lambda Conversion'이라는 Lambda 계산의 기념비적인 저작에서 다중 인자 함수를 바라보는 두 가지 방식을 제안했습니다. 

1. **첫 번째 접근법**
   - 함수가 단일항(singleton), 이중항(tuple), 삼중항(triple) 등을 받는 것으로 간주
   - f(x,y,z)는 매개변수 (x,y,z)를 받는 f로 이해됨
   - (참고로, 이것이 Python 인자 리스트 구조의 주요 동기라고 개인적으로 생각합니다만, 이는 추측일 뿐입니다)

2. **두 번째 접근법**
   - McCarthy가 채택한 이 방식이 우리의 목적에 더 중요합니다
   - f(x,y,z)는 f(x g(y h(z)))로 해석됨
   - 가장 바깥쪽 메서드의 해결은 내부 함수 호출들이 생성한 일련의 상태들로부터 도출됨
   - 이 저장된 내부 상태가 바로 클로저의 기반이며, 이는 현대 OOP의 기초 중 하나입니다
   - 클로저는 캡슐화된 실행 가능한 상태를 다른 지점으로 전달할 수 있게 해줍니다

### Land Of Lisp 책의 예시
```lisp
; 이것이 무엇을 하는지 아시나요? 여러분이 즐겨 사용하는 DB의 시퀀스와 같습니다!
; (getx)는 X의 현재 값을 반환합니다. (increment)는 x에 1을 더합니다
; 아름다운 점은? let 괄호가 닫히면 x는 오직 두 함수의 스코프 내에만 존재합니다!
; 전달 가능한 캡슐화된 실행 상태입니다! 정말 흥미진진하죠!
(let (x 0)
  ; 문법이 잘못되었다면 죄송합니다
  (defun increment ()(setf x (+ 1 x)))
  (defun getx ()(x)))
```

### ECMAScript vs Java: 차이점의 의미
ECMAScript에서 객체가 생성될 때 거의 동일한 패턴을 따를 수 있습니다:
```javascript
function getSequence() {
    var x = 0;
    function getx() { return x }
    function increment() { x++ }
    // 다시 말하지만, 전달 가능하고, 캡슐화되고, 실행 가능한 상태입니다
    return { getX: getX, increment: increment}
}
```

여기서 프로토타입이 등장합니다. ECMAScript에서 상속은 "객체 A로 시작해서 거기에 추가한다"는 의미입니다. 복사하는 것이 아닙니다. 이 마법 같은 상태를 가져와서 ECMAScript가 거기에 추가합니다. 이것이 바로 `MyClass.prototype.foo = 1`과 같은 문법이 허용되어야 하는 근본적인 이유입니다.

### "사후" 메서드 추가의 이유
메서드를 "나중에" 추가하는 이유는 대부분 스타일 선호도의 문제입니다. 원래 정의 내부에서 일어나는 모든 것은 외부에서 일어나는 것과 동일한 종류의 데코레이션을 수행할 뿐입니다.

일반적으로 모든 정의를 한 곳에 두는 것이 스타일적으로 유리하지만, 때로는 그것이 불가능할 수 있습니다. 예를 들어:

- jQuery 확장은 jQuery 객체 프로토타입에 직접 추가하는 방식으로 동작합니다
- Prototype 라이브러리는 클래스 정의를 확장하는 특별한 방식을 일관되게 사용합니다

네, 계속해서 번역하겠습니다.

### Prototype.js의 구현 예시
제가 Prototype.js를 올바르게 기억한다면, 다음과 같은 방식으로 구현됩니다:

```javascript
var Sequence = function(){}

// Object.extend는 오른쪽 객체의 모든 키와 값을 왼쪽 객체에 추가합니다.
Object.extend( Sequence.prototype, (function()
{
    var x = 0;
    function getx(){ return x }
    function increment(){ x++ }
    return { getX: getX, increment:increment}
})());
```

### 원본 정의 내의 prototype 키워드 사용
원본 정의 내에서 prototype 키워드를 사용하는 것은 대부분의 경우 작동하지 않습니다. 그 이유는 "this"가 정의되고 있는 객체의 인스턴스를 참조하기 때문입니다(인스턴스가 생성되는 시점에). 해당 인스턴스에 "prototype" 속성이 없다면, this.prototype은 필연적으로 undefined가 됩니다!

원본 정의 내의 모든 this는 해당 객체의 인스턴스가 될 것이므로, this를 수정하는 것으로 충분할 것입니다. 하지만 (프로토타입과 관련해 미소 짓게 되는 부분인데) 각 this는 constructor 속성을 가지고 있습니다.

```javascript
// 이 "클래스"의 모든 인스턴스의 id를 설정합니다. 이미 인스턴스화된 것들도 포함해서...
this.constructor.prototype.id = 2
console.log( this.id );
```

## 답변 3
### 프로토타입 언어로서의 JavaScript
JavaScript는 매우 특이한 부류인 프로토타입 기반 언어입니다. 이는 임의적인 선택이 아닌, 실시간 평가(live evaluated)되고 "eval", 동적 수정, REPL이 가능한 언어의 필수적인 요구사항입니다.

**프로토타입 상속은 정적으로 미리 정의된 클래스 대신 런타임의 "실시간" 클래스 정의에 기반한 객체 지향 프로그래밍과 비교하여 이해할 수 있습니다.**

### 프로토타입 상속의 다른 관점
객체 지향 언어에서는 (Class -> Object/Instance) 특정 X의 모든 가능한 속성들이 Class X에 열거되어 있고, 인스턴스는 각각의 속성에 대해 자신만의 특정 값을 채웁니다. 반면 프로토타입 상속에서는 실존하는 X와 비슷하지만 다른 Y 사이의 **차이점**만을 설명하며, '마스터 사본'이라는 것이 존재하지 않습니다.

### JavaScript의 특성과 맥락
JavaScript는 실시간 환경에서 실행되고 수정될 수 있는 인터프리터 언어입니다. 프로그램의 내부 구조 자체가 런타임에 수정될 수 있습니다. 이는 컴파일 언어나 .Net과 같은 CLR 연결 언어와는 다른 제약과 이점을 가져옵니다.

"eval"/REPL의 개념은 동적 변수 타이핑을 필요로 합니다. 미리 정의된 단일체적 클래스 기반 상속 구조를 가진 환경에서는 효과적인 실시간 편집이 불가능합니다. 그런 환경에서는 차라리 어셈블리나 바이트코드로 미리 컴파일하는 것이 낫습니다.

### 프로토타입 상속의 장점
대신 우리는 객체의 인스턴스의 속성들을 연결하는 프로토타입 상속을 가지고 있습니다. 모든 것이 "실시간"인 환경에서는 클래스(정적이고 미리 정의된 구조)가 불필요하게 제한적이라는 개념입니다. 클래스는 JavaScript에 존재하지 않는 제약에 기반을 두고 있습니다.

이 전략으로 JavaScript는 기본적으로 모든 것이 "실시간"이라는 점에 베팅합니다. 아무것도 제한되지 않으며, 절대 건드릴 수 없는 "정의되고 완료된" 클래스는 없습니다. 여러분이 오늘 작성하기로 결정한 코드와 동일한 규칙을 따르지 않는 "진정한 스코틀랜드인"과 같은 변수는 없습니다.

### 결과와 영향
이러한 특성의 결과는 뚜렷하며, 매우 인간 중심적입니다:

1. 네이티브 객체 제공에 있어 언어 구현자들이 가볍고 효율적인 접근을 하도록 유도합니다.
2. 구현이 불완전할 경우 커뮤니티가 플랫폼을 장악하고 재구축할 수 있습니다(MooTools의 소스를 보면 Function과 Object부터 시작해서 모든 것을 재정의/재구현합니다).
3. 이는 Internet Explorer의 구버전과 같은 플랫폼에 호환성을 가져오는 방식입니다.
4. 얕고 좁지만 기능이 풍부한 라이브러리를 촉진합니다.

### 마이크로 라이브러리의 번성
마이크로 라이브러리의 개념은 JavaScript에서 독특하게 번성하고 있으며, 이는 확실히 언어의 기본 원칙으로 거슬러 올라갈 수 있습니다. 다른 어떤 언어도 보여주지 않는 방식으로 인간의 소비 측면에서 효율성과 간결성을 장려합니다.