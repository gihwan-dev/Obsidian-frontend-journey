> [원문](https://enterprisecraftsmanship.com/posts/cohesion-coupling-difference/)

아마 코딩을 하면서 코드베이스의 높은 응집도와 낮은 결합도를 목표로 해야 한다는 말을 많이 들어봤을거다. 이 글에서는 그런 말들이 실제로 무엇을 의미하는지 코드 예제와 함께 설명한다. 또한 이 두 개념 사이의 경계를 그리고 그들 간의 차이점을 보여주고자 한다.

## 1. 응집도와 결함도: 그 차이

결합도는 거의 모든 사람들이 이해하는데 어려움이 없는 꽤 직관적인 개념인 반면, 응집도라는 개념은 이해하기가 더 어렵다. 게다가, 이 둘 사이의 차이점은 종종 모호해 보인다. 이는 놀라운 일이 아니다: 이 용어들 뒤에 있는 아이디어들은 실제로 비슷하기 때문이다. 그럼에도 불구하고, 이 개념들은 차이가 있다.

**응집도**는 코드베이스의 한 부분이 얼마나 논리적으로 단일하고 원자적인지를 의미한다.

이는 어떤 코드 단위(unit) 내부의 연결 수로도 표현될 수 있다. 만약 그 수가 적다면 코드의 경계가 잘못 선택된것일 수 있고, 선택한 코드 단위 내부가 논리적으로 연관되어 있지 않은 것이다.

단위는 반드시 클래스일 필요는 없다. 메소드일 수 있고, 클래스 그룹, 모듈 또는 어셈블리 일 수도 있다: 응집도(그리고 결합도)의 개념은 서로 다른 수준에서 적용 가능하다. 이에 대해 곧 이야기 하겠다.

반면에 **결합도**는 한 코드 단위가 다른 것들로부터 얼마나 독립적인가를 나타낸다. 다시 말해, 이는 두 개 이상의 코드 단위간의 연결 수를 의미한다. 그 수가 적을수록 결합도가 낮다.

## 2. 높은 응집도, 낮은 결합도 지침

본질적으로, 높은 응집도는 **서로 관련된 코드베이스의 부분들을 한 곳에 모아두는 것**을 의미한다. 동시에, 낮은 결합도는 **관련되지 않은 코드베이스의 부분들을 최대한 분리하는 것**에 관한 것이다.

이론적으로, 가이드라인은 꽤 단순해 보인다. 하지만, 실제로는 코드베이스의 어떤 부분들이 서로 연관되어 있는지 이해하기 위해 소프트웨어의 도메인 모델을 깊게 파악해야 한다.

이는 [순환 복잡도](https://en.wikipedia.org/wiki/Cyclomatic_complexity)와 같은 측정 지표들과는 달리, 코드가 얼마나 높은 응집도와 낮은 결합도를 가졌는지 직접적으로 측정할 수 없다는 것을 의미한다. 도메인 모델의 속성인 코드의 의미에 크게 의존한다.

아마 이 가이드라인의 객관성 부족이 이를 따르기 어려운 이유일 것이다.

높은 응집도, 낮은 결합도 가이드라인과 크게 관련된 원칙이 있다: 관심사의 분리다. 이 둘은 제안하는 모법 사례들 측면에서 상당히 유사하다. 관심사 분리 원칙에 대해 더 자세히 알아보려면 [이 글](https://enterprisecraftsmanship.com/2014/12/06/separation-of-concerns-in-orm/)(번역 본은 아래 참고 링크 확인)을 확인하자.

## 3. 응집도와 결합도 관점에서 본 코드의 유형들

높은 응집도와 낮은 결합도를 모두 가진 코드 외에도, 스펙트럼의 다른 부분에 해당하는 세 가지 형이 있다. 다음은 모든 4가지 유형이다:
![[Pasted image 20250212200808.png]]

하나씩 살펴보자.

**1. 이상적인** 코드는 가이드라인을 따르는 코드다. 이런 코드는 결합도가 낮고 응집도가 높다. 그림으로 그려보면 다음과 같을 수 있다:
![[Pasted image 20250212201015.png]]

여기서, 같은 색상의 원은 서로 연관된 코드를 의미한다.

**2. 신의 객체**는 높은 응집도와 높은 결합도를 가진 코드를 의미한다. 안티패턴이며, 주로 하나의 모듈이 모든 책임을 담당하는 경우를 의미한다:
![[Pasted image 20250212201210.png]]

다른 이름으로는 진흙 덩어리(Big Ball of Mud) 같은 것이 있다.

**3.** 세 번째 유형은 서로 다른 클래스나 모듈 간의 경계가 잘못 선택되었을 때 발생한다:
![[Pasted image 20250212201536.png]]

God Object(신의 객체)와는 다르게, 이러한 종류의 코드는 바운더리를 가지고 있다. 문제는 경계들이 부적절하게 선택되었고, 종종 도메인의 실제 의미를 반영하지 못한다는 것이다. 이러한 코드는 보통 단일 책임 원칙을 위반한다.

**4. 파괴적 디커플링(Destructive decoupling)**은 가장 흥미로운 유형이다. 주로 프로그래머가 코드베이스를 과도하게 분리하려다가 초점을 잃어버릴때 발생한다:
![[Pasted image 20250212201922.png]]

마지막 타입은 조금 더 알아볼 가치가 있다.

## 응집도와 결합도: 함정들

종종, 개발자가 낮은 결합도, 높은 응집도 지침을 구현하려고 할 때 지침의 결합도 측면에만 너무 많은 노력을 기울이고 다른 한 측면은 완전히 잊어버린다. 이는 코드가 실제로는 분리되어 있지만 동시에 명확한 초점이 없는 상황으로 이어진다.


## 참고
[[Separation of Concerns in ORM]]