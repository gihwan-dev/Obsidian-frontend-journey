## 소개

대규모 언어 모델의 입력과 출력을 생각할 때, 텍스트 프롬프트(때로는 이미지 프롬프트와 같은 다른 모달리티와 함께)는 모델이 특정 출력을 예측하는 데 사용하는 입력입니다. 데이터 과학자나 기계 학습 엔지니어가 아니어도 누구나 프롬프트를 작성할 수 있습니다. 그러나 가장 효과적인 프롬프트를 만드는 것은 복잡할 수 있습니다. 프롬프트의 효과에 영향을 미치는 여러 측면이 있습니다: 사용하는 모델, 모델의 학습 데이터, 모델 구성, 단어 선택, 스타일과 어조, 구조, 그리고 맥락이 모두 중요합니다. 따라서 프롬프트 엔지니어링은 반복적인 과정입니다. 불충분한 프롬프트는 모호하고 부정확한 응답을 초래할 수 있으며, 모델이 의미 있는 출력을 제공하는 능력을 저해할 수 있습니다.

> 데이터 과학자나 기계 학습 엔지니어가 아니어도 누구나 프롬프트를 작성할 수 있습니다.

Gemini 챗봇과 대화할 때, 기본적으로 프롬프트를 작성하는 것입니다. 그러나 이 백서는 Vertex AI 내에서 또는 API를 사용하여 Gemini 모델에 프롬프트를 작성하는 데 초점을 맞추고 있습니다. 왜냐하면 모델에 직접 프롬프트를 작성함으로써 온도 등의 구성에 접근할 수 있기 때문입니다.

이 백서는 프롬프트 엔지니어링에 대해 자세히 논의합니다. 우리는 다양한 프롬프팅 기법을 살펴보고 시작하는 데 도움이 되는 팁과 모범 사례를 공유하여 프롬프팅 전문가가 되는 방법을 알려드립니다. 또한 프롬프트를 작성하는 동안 직면할 수 있는 몇 가지 도전 과제에 대해서도 논의합니다.

## 프롬프트 엔지니어링

LLM이 어떻게 작동하는지 기억해 보세요. 이는 예측 엔진입니다. 모델은 순차적 텍스트를 입력으로 받아 이전 토큰과 학습 데이터 사이의 관계를 기반으로 다음 토큰이 무엇이어야 하는지 예측합니다. LLM은 이 과정을 반복적으로 수행하도록 작동하며, 이전에 예측된 토큰을 순차적 텍스트의 끝에 추가하여 다음 토큰을 예측합니다. 다음 토큰 예측은 이전 토큰과 LLM이 학습 중에 본 것 사이의 관계를 기반으로 합니다.

프롬프트를 작성할 때, 여러분은 LLM이 올바른 토큰 시퀀스를 예측하도록 설정하려고 시도합니다. 프롬프트 엔지니어링은 LLM이 정확한 출력을 생성하도록 고품질 프롬프트를 설계하는 과정입니다. 이 과정에는 최상의 프롬프트를 찾기 위한 조정, 프롬프트 길이 최적화, 그리고 작업과 관련하여 프롬프트의 작성 스타일과 구조를 평가하는 것이 포함됩니다. 자연어 처리와 LLM의 맥락에서, 프롬프트는 모델에 응답이나 예측을 생성하도록 제공되는 입력입니다.

이러한 프롬프트는 텍스트 요약, 정보 추출, 질문 및 답변, 텍스트 분류, 언어 또는 코드 번역, 코드 생성, 코드 문서화 또는 추론과 같은 다양한 이해 및 생성 작업을 수행하는 데 사용될 수 있습니다.

Google의 프롬프팅 가이드를 참조하시면 간단하고 효과적인 프롬프팅 예시를 확인하실 수 있습니다.

프롬프트 엔지니어링을 할 때, 먼저 모델을 선택하게 됩니다. Vertex AI의 Gemini 언어 모델, GPT, Claude 또는 Gemma나 LLaMA와 같은 오픈 소스 모델을 사용하든, 프롬프트는 특정 모델에 맞게 최적화되어야 할 수 있습니다.

프롬프트 외에도 LLM의 다양한 구성을 조정해야 합니다.

## LLM 출력 구성
모델을 선택하고 나면 모델 구성을 파악해야 합니다. 대부분의 LLM은 LLM 출력을 제어하는 다양한 구성 옵션을 제공합니다. 효과적인 프롬프트 엔지니어링을 위해서는 이러한 구성을 작업에 맞게 최적으로 설정해야 합니다.

### 출력 길이
중요한 구성 설정 중 하나는 응답에서 생성할 토큰 수입니다. 더 많은 토큰을 생성하려면 LLM에서 더 많은 계산이 필요하며, 이는 더 높은 에너지 소비, 잠재적으로 더 느린 응답 시간 및 더 높은 비용으로 이어집니다.

LLM의 출력 길이를 줄이면 LLM이 생성하는 출력에서 스타일적으로나 텍스트적으로 더 간결해지지는 않습니다. 단지 제한에 도달하면 LLM이 더 많은 토큰을 예측하는 것을 중단하게 합니다. 짧은 출력 길이가 필요한 경우, 프롬프트를 수정하여 이를 수용해야 할 수도 있습니다.

출력 길이 제한은 ReAct와 같은 일부 LLM 프롬프팅 기법에서 특히 중요합니다. 이 기술에서는 원하는 응답 이후에도 LLM이 계속해서 불필요한 토큰을 방출할 수 있기 때문입니다.

주의할 점은, 더 많은 토큰을 생성하면 LLM에서 더 많은 계산이 필요하므로 에너지 소비가 증가하고 응답 시간이 잠재적으로 느려질 수 있으며, 이는 더 높은 비용으로 이어진다는 것입니다.

### 샘플링 제어
LLM은 공식적으로 단일 토큰을 예측하지 않습니다. 오히려 LLM은 다음 토큰이 무엇일 수 있는지에 대한 확률을 예측하며, LLM의 어휘에 있는 각 토큰은 확률을 얻습니다. 이러한 토큰 확률은 다음에 생성될 토큰을 결정하기 위해 샘플링됩니다. 온도(temperature), top-K 및 top-P는 예측된 토큰 확률이 단일 출력 토큰을 선택하기 위해 처리되는 방식을 결정하는 가장 일반적인 구성 설정입니다.

#### 온도
온도는 토큰 선택의 무작위성 정도를 제어합니다. 낮은 온도는 더 결정적인 응답이 예상되는 프롬프트에 적합하며, 높은 온도는 더 다양하거나 예상치 못한 결과로 이어질 수 있습니다. 0의 온도(탐욕적 디코딩)는 결정적입니다: 가장 높은 확률의 토큰이 항상 선택됩니다(단, 두 토큰이 동일한 가장 높은 예측 확률을 가질 경우, 타이브레이킹이 어떻게 구현되었는지에 따라 온도 0에서도 항상 동일한 출력을 얻지 못할 수 있습니다).

최대에 가까운 온도는 더 무작위한 출력을 생성하는 경향이 있습니다. 그리고 온도가 점점 높아질수록, 모든 토큰이 다음에 예측될 토큰이 될 가능성이 동일해집니다.

Gemini 온도 제어는 기계 학습에서 사용되는 softmax 함수와 유사한 방식으로 이해될 수 있습니다. 낮은 온도 설정은 낮은 softmax 온도(T)를 반영하여 높은 확실성으로 단일 선호 온도를 강조합니다. 높은 Gemini 온도 설정은 높은 softmax 온도와 같아서, 선택된 설정 주변의 더 넓은 범위의 온도가 허용 가능하게 만듭니다. 이러한 불확실성 증가는 창의적인 출력을 실험할 때와 같이 엄격하고 정확한 온도가 필수적이지 않은 시나리오를 수용합니다.

#### Top-K 및 top-P
Top-K 및 top-P(핵 샘플링이라고도 함)는 예측된 다음 토큰이 상위 예측 확률을 가진 토큰에서 나오도록 제한하는 두 가지 샘플링 설정입니다. 온도와 마찬가지로, 이러한 샘플링 설정은 생성된 텍스트의 무작위성과 다양성을 제어합니다.

- **Top-K** 샘플링은 모델의 예측 분포에서 가장 가능성이 높은 상위 K개의 토큰을 선택합니다. Top-K가 높을수록 모델의 출력이 더 창의적이고 다양해집니다. Top-K가 낮을수록 모델의 출력이 더 제한적이고 사실적입니다. Top-K가 1이면 탐욕적 디코딩과 동일합니다.
    
- **Top-P** 샘플링은 누적 확률이 특정 값(P)을 초과하지 않는 상위 토큰을 선택합니다. P의 값은 0(탐욕적 디코딩)부터 1(LLM 어휘의 모든 토큰)까지 범위입니다.
    

Top-K와 top-P 중에서 선택하는 가장 좋은 방법은 두 방법(또는 두 방법을 함께) 모두 실험해보고 원하는 결과를 얻는 방법을 확인하는 것입니다.

## 모두 통합하기
top-K, top-P, 온도 및 생성할 토큰 수 중에서 선택하는 것은 특정 응용 프로그램과 원하는 결과에 따라 달라지며, 이러한 설정은 서로에게 영향을 미칩니다. 또한 선택한 모델이 다양한 샘플링 설정을 어떻게 결합하는지 이해하는 것이 중요합니다.

온도, top-K 및 top-P가 모두 사용 가능한 경우(Vertex Studio에서와 같이), top-K와 top-P 기준을 모두 충족하는 토큰은 다음 예측 토큰의 후보가 되고, 그 다음 온도가 적용되어 top-K와 top-P 기준을 통과한 토큰 중에서 샘플링됩니다. top-K 또는 top-P만 사용 가능한 경우, 동작은 동일하지만 하나의 top-K 또는 P 설정만 사용됩니다.

온도를 사용할 수 없는 경우, top-K 및/또는 top-P 기준을 충족하는 모든 토큰 중에서 무작위로 선택하여 단일 다음 예측 토큰을 생성합니다.

하나의 샘플링 구성 값을 극단적으로 설정하면, 그 하나의 샘플링 설정이 다른 구성 설정을 취소하거나 무관해집니다.

- 온도를 0으로 설정하면 top-K와 top-P는 무관해지며, 가장 확률이 높은 토큰이 다음 예측 토큰이 됩니다. 온도를 극도로 높게 설정하면(1 이상, 일반적으로 10 정도) 온도가 무관해지고 top-K 및/또는 top-P 기준을 통과한 토큰은 다음 예측 토큰을 선택하기 위해 무작위로 샘플링됩니다.
    
- top-K를 1로 설정하면 온도와 top-P가 무관해집니다. 오직 하나의 토큰만 top-K 기준을 통과하고, 그 토큰이 다음 예측 토큰이 됩니다. top-K를 LLM 어휘 크기만큼 극도로 높게 설정하면, 다음 토큰이 될 확률이 0이 아닌 모든 토큰이 top-K 기준을 충족하고 아무것도 선택되지 않습니다.
    
- top-P를 0(또는 매우 작은 값)으로 설정하면, 대부분의 LLM 샘플링 구현은 가장 확률이 높은 토큰만 top-P 기준을 충족하는 것으로 간주하여 온도와 top-K를 무관하게 만듭니다. top-P를 1로 설정하면, 다음 토큰이 될 확률이 0이 아닌 모든 토큰이 top-P 기준을 충족하고 아무것도 선택되지 않습니다.
    

일반적인 시작점으로, 온도 0.2, top-P 0.95, top-K 30은 지나치게 창의적이지 않으면서도 창의적일 수 있는 비교적 일관된 결과를 제공합니다. 특히 창의적인 결과를 원한다면, 온도 0.9, top-P 0.99, top-K 40으로 시작해 보세요. 그리고 덜 창의적인 결과를 원한다면, 온도 0.1, top-P 0.9, top-K 20으로 시작해 보세요. 마지막으로, 작업에 항상 하나의 정답만 있는 경우(예: 수학 문제 해결), 온도 0으로 시작하세요.

> [!note] 참고
> 더 많은 자유도(높은 온도, top-K, top-P 및 출력 토큰)로 인해 LLM은 관련성이 낮은 텍스트를 생성할 수 있습니다.

> [!danger] 경고
응답 끝에 많은 채움 단어가 있는 것을 본 적이 있나요? 이는 "반복 루프 버그"라고도 알려진 대형 언어 모델의 일반적인 문제입니다. 모델이 동일한 (채움) 단어, 구문 또는 문장 구조를 반복적으로 생성하는 사이클에 빠지는 현상으로, 부적절한 온도와 top-k/top-p 설정에 의해 악화됩니다. 이는 낮은 온도와 높은 온도 설정 모두에서 발생할 수 있으며, 다른 이유로 발생합니다. 낮은 온도에서는 모델이 과도하게 결정적이 되어 이전에 생성된 텍스트를 다시 방문하는 경로가 있을 경우 가장 높은 확률 경로에 엄격하게 고착됩니다. 반대로, 높은 온도에서는 모델의 출력이 과도하게 무작위가 되어 우연히 이전 상태로 돌아가는 단어나 구문이 무작위로 선택될 확률이 증가하며, 사용 가능한 옵션이 많기 때문에 루프가 발생합니다. 두 경우 모두, 모델의 샘플링 프로세스가 "막혀" 출력 창이 채워질 때까지 단조롭고 도움이 되지 않는 출력을 생성합니다. 이 문제를 해결하려면 결정론과 무작위성 사이의 최적 균형을 찾기 위해 온도와 top-k/top-p 값을 신중하게 조정해야 합니다.

## 프롬프팅 기법
LLM은 지시를 따르도록 조정되고 대량의 데이터로 학습되어 프롬프트를 이해하고 답변을 생성할 수 있습니다. 하지만 LLM은 완벽하지 않습니다. 프롬프트 텍스트가 명확할수록 LLM이 다음에 올 텍스트를 예측하는 데 더 유리합니다. 또한 LLM이 학습되고 작동하는 방식을 활용하는 특정 기법은 LLM에서 관련 결과를 얻는 데 도움이 됩니다.

이제 프롬프트 엔지니어링이 무엇이고 어떤 요소가 필요한지 이해했으니, 가장 중요한 프롬프팅 기법의 예를 살펴보겠습니다.

### 일반 프롬프팅 / 제로 샷
제로 샷 프롬프트는 가장 간단한 유형의 프롬프트입니다. 작업에 대한 설명과 LLM이 시작할 수 있는 일부 텍스트만 제공합니다. 이 입력은 질문, 이야기의 시작 또는 지시 사항 등 무엇이든 될 수 있습니다. 제로 샷이라는 이름은 '예제 없음'을 의미합니다.

Vertex AI의 언어를 위한 Vertex AI Studio를 사용해 보겠습니다. 이는 프롬프트를 테스트할 수 있는 플레이그라운드를 제공합니다. 표 1에서 영화 리뷰를 분류하는 제로 샷 프롬프트 예제를 볼 수 있습니다.

아래 표 형식은 프롬프트를 문서화하는 좋은 방법입니다. 프롬프트는 코드베이스에 들어가기 전에 많은 반복을 거치게 될 것이므로, 프롬프트 엔지니어링 작업을 규율적이고 구조적인 방식으로 추적하는 것이 중요합니다. 이 표 형식, 프롬프트 엔지니어링 작업 추적의 중요성 및 프롬프트 개발 프로세스에 대한 자세한 내용은 이 장의 뒷부분에 있는 모범 사례 섹션("다양한 프롬프트 시도 문서화")에서 다룹니다.

창의성이 필요하지 않으므로 모델 온도는 낮게 설정해야 하며, 두 설정을 효과적으로 비활성화하는 gemini-pro 기본 top-K 및 top-P 값을 사용합니다(위의 'LLM 출력 구성' 참조). 생성된 출력에 주목하세요. disturbing(불안한)과 masterpiece(걸작)라는 단어는 같은 문장에서 사용되므로 예측을 약간 더 복잡하게 만들어야 합니다.

| 이름    | 1_1_movie_classification                                                                                                                     |
| ----- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| 목표    | 영화 리뷰를 긍정적, 중립 또는 부정적으로 분류하기                                                                                                                 |
| 모델    | gemini-pro                                                                                                                                   |
| 온도    | 0.1                                                                                                                                          |
| Top-K | N/A                                                                                                                                          |
| 프롬프트  | 영화 리뷰를 POSITIVE, NEUTRAL 또는 NEGATIVE로 분류하세요.<br>리뷰: "Her"는 AI가 계속 발전하도록 허용된다면 인류가 향하는 방향을 보여주는 불안한 연구입니다. 이런 걸작과 같은 영화가 더 많았으면 좋겠습니다.<br>감정: |
| 출력    | POSITIVE                                                                                                                                     |

제로 샷이 작동하지 않을 때, 프롬프트에 데모나 예시를 제공할 수 있으며, 이는 "원샷" 및 "퓨샷" 프롬프팅으로 이어집니다.

### 원샷 & 퓨샷
AI 모델을 위한 프롬프트를 만들 때, 예시를 제공하는 것이 도움이 됩니다. 이러한 예시는 모델이 요청하는 내용을 이해하는 데 도움이 됩니다. 예시는 특히 모델을 특정 출력 구조나 패턴으로 유도하고자 할 때 유용합니다.

**원샷 프롬프트**는 단일 예시를 제공하므로 원샷이라는 이름이 붙었습니다. 이 아이디어는 모델이 작업을 가장 잘 수행하기 위해 모방할 수 있는 예시를 가지게 되는 것입니다.

**퓨샷 프롬프트**는 모델에 여러 예시를 제공합니다. 이 접근 방식은 모델에 따라야 할 패턴을 보여줍니다. 아이디어는 원샷과 유사하지만, 원하는 패턴의 여러 예시는 모델이 패턴을 따를 가능성을 높입니다.

퓨샷 프롬프팅에 필요한 예시 수는 작업의 복잡성, 예시의 품질, 사용하는 생성형 AI(gen AI) 모델의 능력 등 여러 요소에 따라 달라집니다. 일반적인 경험칙으로, 퓨샷 프롬프팅에는 최소 3~5개의 예시를 사용해야 합니다. 그러나 더 복잡한 작업에는 더 많은 예시가 필요할 수 있으며, 모델의 입력 길이 제한으로 인해 더 적은 수의 예시가 필요할 수도 있습니다.

아래 표는 퓨샷 프롬프트 예시를 보여줍니다. 이전과 같은 gemini-pro 모델 구성 설정을 사용하되, 더 긴 응답에 대한 필요를 수용하기 위해 토큰 제한을 늘려보겠습니다.

| 목표    | 피자 주문을 JSON으로 파싱하기                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 모델    | gemini-pro                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 온도    | 0.1                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Top-K | N/A                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 프롬프트  | 고객의 피자 주문을 유효한 JSON으로 파싱하세요:<br><br>예시:<br>I want a small pizza with cheese, tomato sauce, and pepperoni.<br>JSON 응답:<br>![[Pasted image 20250413145624.png]]<br><br>예시:<br>Can I get a large pizza with tomato sauce, basil and mozzarella<br><br>![[Pasted image 20250413145641.png]]<br><br>Now, I would like a large pizza, with the first half cheese and mozzarella. And the other tomato sauce, ham and pineapple.<br>JSON 응답: |
| 출력    | ![[Pasted image 20250413145648.png]]                                                                                                                                                                                                                                                                                                                                                                                                  |

프롬프트에 예시를 선택할 때는 수행하려는 작업과 관련된 예시를 사용하세요. 예시는 다양하고, 고품질이며, 잘 작성되어야 합니다. 작은 실수 하나가 모델을 혼란스럽게 하고 원치 않는 출력을 초래할 수 있습니다.

다양한 입력에 견고한 출력을 생성하려고 한다면, 예시에 엣지 케이스를 포함하는 것이 중요합니다. 엣지 케이스는 모델이 여전히 처리할 수 있어야 하는 특이하거나 예상치 못한 입력입니다.

## 시스템, 맥락 및 역할 프롬프팅
시스템, 맥락 및 역할 프롬프팅은 모두 LLM이 텍스트를 생성하는 방식을 안내하는 데 사용되는 기법이지만, 다른 측면에 초점을 맞춥니다:

- **시스템 프롬프팅**은 언어 모델의 전체적인 맥락과 목적을 설정합니다. 모델이 해야 할 '큰 그림'을 정의합니다. 예를 들어 언어 번역, 리뷰 분류 등의 작업을 수행하도록 합니다.
    
- **맥락 프롬프팅**은 현재 대화나 작업과 관련된 특정 세부 정보나 배경 정보를 제공합니다. 모델이 질문의 뉘앙스를 이해하고 그에 따라 응답을 맞춤화하는 데 도움이 됩니다.
    
- **역할 프롬프팅**은 언어 모델이 채택할 특정 캐릭터나 정체성을 할당합니다. 이는 모델이 할당된 역할과 관련된 지식 및 행동과 일관된 응답을 생성하는 데 도움이 됩니다.
    

시스템, 맥락 및 역할 프롬프팅 사이에는 상당한 중복이 있을 수 있습니다. 예를 들어, 시스템에 역할을 할당하는 프롬프트는 맥락도 가질 수 있습니다.

그러나 각 유형의 프롬프트는 약간 다른 주요 목적을 제공합니다:

- 시스템 프롬프트: 모델의 기본 기능과 전반적인 목적을 정의합니다.
- 맥락 프롬프트: 응답을 안내하기 위한 즉각적이고 작업별 정보를 제공합니다. 현재 작업이나 입력에 매우 특화되어 있어 동적입니다.
- 역할 프롬프트: 모델의 출력 스타일과 목소리를 구성합니다. 특수성과 개성의 계층을 추가합니다.

시스템, 맥락 및 역할 프롬프트를 구분하는 것은 명확한 의도로 프롬프트를 설계하기 위한 프레임워크를 제공하고, 유연한 조합을 허용하며, 각 프롬프트 유형이 언어 모델의 출력에 어떻게 영향을 미치는지 분석하기 쉽게 만듭니다.

이 세 가지 다른 종류의 프롬프트를 자세히 살펴보겠습니다.

### 시스템 프롬프팅
아래 표는 출력을 반환하는 방법에 대한 추가 정보를 지정하는 시스템 프롬프트를 포함하고 있습니다. 더 높은 창의성 수준을 얻기 위해 온도를 높였고, 더 높은 토큰 제한을 지정했습니다. 그러나 출력을 반환하는 방법에 대한 명확한 지시 덕분에 모델은 추가 텍스트를 반환하지 않았습니다.

| 목표    | 영화 리뷰를 긍정적, 중립 또는 부정적으로 분류하기                                                                                                           |
| ----- | -------------------------------------------------------------------------------------------------------------------------------------- |
| 모델    | gemini-pro                                                                                                                             |
| 온도    | 1                                                                                                                                      |
| Top-K | 40                                                                                                                                     |
| 프롬프트  | 영화 리뷰를 긍정적, 중립 또는 부정적으로 분류하세요. 레이블만 대문자로 반환하세요.<br>리뷰: "Her"는 AI가 계속 발전하도록 허용된다면 인류가 향하는 방향을 보여주는 불안한 연구입니다. 너무 불안해서 볼 수 없었습니다.<br>감정: |
| 출력    | NEGATIVE                                                                                                                               |

시스템 프롬프트는 특정 요구 사항을 충족하는 출력을 생성하는 데 유용할 수 있습니다. '시스템 프롬프트'라는 이름은 실제로 '시스템에 추가 작업 제공'을 의미합니다. 예를 들어, 특정 프로그래밍 언어와 호환되는 코드 스니펫을 생성하거나 특정 구조를 반환하기 위해 시스템 프롬프트를 사용할 수 있습니다. 아래 표를 살펴보세요. 여기서는 출력을 JSON 형식으로 반환합니다.

| 목표    | 영화 리뷰를 긍정적, 중립 또는 부정적으로 분류하고 JSON으로 반환하기                                                                                                                                                            |
| ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 모델    | gemini-pro                                                                                                                                                                                          |
| 온도    | 1                                                                                                                                                                                                   |
| Top-K | 40                                                                                                                                                                                                  |
| 프롬프트  | 영화 리뷰를 긍정적, 중립 또는 부정적으로 분류하세요. 유효한 JSON을 반환하세요:<br><br>리뷰: "Her"는 AI가 계속 발전하도록 허용된다면 인류가 향하는 방향을 보여주는 불안한 연구입니다. 너무 불안해서 볼 수 없었습니다.<br><br>스키마:<br>![[Pasted image 20250413145706.png]]<br>JSON 응답: |
| 출력    | ![[Pasted image 20250413145721.png]]                                                                                                                                                                |

데이터를 추출하는 프롬프트에서 JSON 객체를 반환하는 것은 여러 가지 이점이 있습니다. 실제 응용 프로그램에서는 이 JSON 형식을 수동으로 만들 필요가 없고, 데이터를 정렬된 순서로 이미 반환할 수 있으며(datetime 객체로 작업할 때 매우 유용), 가장 중요한 것은 JSON 형식을 프롬프팅함으로써 모델이 구조를 만들고 환각(hallucination)을 제한하도록 강제합니다.

시스템 프롬프트는 안전성과 유해성 방지에도 매우 유용할 수 있습니다. 출력을 제어하려면 프롬프트에 '답변에서 존중적이어야 합니다'와 같은 추가 라인을 간단히 추가하면 됩니다.

### 역할 프롬프팅
역할 프롬프팅은 생성형 AI 모델에 특정 역할을 할당하는 프롬프트 엔지니어링 기법입니다. 이는 모델이 할당된 역할에 맞는 더 관련성 있고 유익한 출력을 생성하는 데 도움이 될 수 있습니다.

예를 들어, 생성형 AI 모델에 책 편집자, 유치원 교사 또는 동기 부여 연설가의 역할을 부여할 수 있습니다. 모델에 역할이 할당되면 해당 역할에 특화된 프롬프트를 제공할 수 있습니다. 예를 들어, 교사에게 검토할 수 있는 수업 계획을 만들도록 프롬프트할 수 있습니다. 아래 표에서 모델이 여행 가이드 역할을 맡는 예제를 살펴보겠습니다.

| 목표    | 여행 가이드로 활동하고 3가지 여행 제안 제공하기                                                                                                                                                                                                                                                                                                                                 |
| ----- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 모델    | gemini-pro                                                                                                                                                                                                                                                                                                                                                  |
| 온도    | 1                                                                                                                                                                                                                                                                                                                                                           |
| Top-K | 40                                                                                                                                                                                                                                                                                                                                                          |
| 프롬프트  | 여행 가이드로 활동해주세요. 제가 내 위치에 대해 알려드리면 내 근처에 방문할 3곳을 추천해주세요. 경우에 따라 방문할 장소 유형도 알려드리겠습니다.<br>내 제안: "저는 암스테르담에 있고 박물관만 방문하고 싶습니다."<br>여행 제안:                                                                                                                                                                                                                       |
| 출력    | 1. 레이크스뮤지엄(Rijksmuseum): 렘브란트의 "야간 경비대"와 같은 네덜란드 걸작으로 유명한 세계적으로 유명한 박물관입니다. 네덜란드 예술과 역사를 보여주는 놀라운 그림과 유물 컬렉션을 놓치지 마세요.<br><br>2. 반 고흐 박물관: 빈센트 반 고흐의 매력적인 작품에 몰입해보세요. 이 박물관에는 "별이 빛나는 밤"과 "해바라기"를 포함한 그의 그림과 드로잉의 가장 큰 컬렉션이 있습니다.<br><br>3. 스테델리크 박물관 암스테르담: 세계 각지의 현대 및 현대 미술을 발견하세요. 이 박물관의 컬렉션에는 피카소, 칸딘스키, 리트벨트의 작품이 포함되어 있으며, 눈에 띄는 현대적인 건물에 위치해 있습니다. |

위의 예는 여행 에이전트 역할을 맡는 예를 보여줍니다. 역할을 지리 교사로 변경하면 다른 응답을 받게 될 것입니다.

AI 모델에 역할 관점을 정의하면 원하는 톤, 스타일 및 집중된 전문성의 청사진을 제공하여 출력의 품질, 관련성 및 효과를 향상시킵니다.

| 프롬프트 | 여행 가이드로 활동해주세요. 제가 내 위치에 대해 알려드리면 내 근처에 방문할 3곳을 유머러스한 스타일로 추천해주세요.<br>내 제안: "저는 맨해튼에 있습니다."<br>여행 제안:                                                                                                                                                                                                                                                       |
| ---- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 출력   | 1. 엠파이어 스테이트 오브 마인드 감상하기: 엠파이어 스테이트 빌딩에 올라가 맨해튼의 스카이라인의 영광에 몸을 담그세요. 거대한 바나나 없이도 빅 애플 위에서 킹콩처럼 느껴질 준비를 하세요.<br><br>2. MoMA에서 예술 좀 해보기: 현대 미술 박물관(MoMA)에서 내면의 예술 애호가를 발휘하세요. 당신의 막대기 그림이 예술적 가치가 있는지 의문을 갖게 만드는 걸작품들을 응시하세요.<br><br>3. 5번가에서 쇼핑 폭풍 즐기기: 상징적인 5번가에서 소매 테라피에 빠져보세요. 디자이너 부티크에서의 가격표 충격에 대비하세요(창문 쇼핑이든 실제 쇼핑이든). 하지만 맨해튼에 있으니 화려함을 받아들이는 게 좋겠죠! |

### 맥락 프롬프팅
맥락 프롬프트를 제공함으로써 AI 상호작용이 가능한 한 원활하고 효율적이도록 할 수 있습니다. 모델이 요청을 더 빠르게 이해하고 더 정확하고 관련성 있는 응답을 생성할 수 있게 됩니다. 표 7의 예시를 참조하세요.

| 목표    | 레트로 게임에 관한 블로그 기사 제안하기                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 모델    | gemini-pro                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 온도    | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Top-K | 40                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 프롬프트  | 맥락: 당신은 80년대 레트로 아케이드 비디오 게임에 관한 블로그를 작성하고 있습니다.<br>글을 쓸 기사 주제 3가지를 제안하고, 각 기사에 포함되어야 할 내용에 대한 간략한 설명을 몇 줄 추가해주세요.                                                                                                                                                                                                                                                                                                                               |
| 출력    | 1. **아케이드 캐비닛 디자인의 진화:**<br>이 기사는 1970년대 초기 나무와 금속 캐비닛에서 1980년대 이후의 세련되고 네온이 빛나는 디자인에 이르기까지 아케이드 캐비닛 디자인의 진화를 탐구할 것입니다.<br><br>2. **과거로부터의 폭발: 80년대의 상징적인 아케이드 게임들:**<br>- 이 기사는 1980년대의 가장 상징적이고 영향력 있는 아케이드 게임들의 역사, 영향, 그리고 유산에 대한 일별을 제공하며, 그들의 혁신, 인기 있는 메커니즘, 그리고 지속적인 매력을 강조할 것입니다.<br><br>3. **픽셀 아트의 부상과 레트로 부활:**<br>- 이 기사는 초기 아케이드 게임의 정의적인 시각적 스타일로서 픽셀 아트의 진화를 파헤치고, 그 뿌리를 추적하고, 기법을 탐구하며, 현대 게임과 디지털 아트에서 픽셀 아트의 부활에 대해 논의할 것입니다. |

## 스텝백 프롬프팅

스텝백 프롬프팅은 먼저 특정 작업과 관련된 일반적인 질문을 고려하도록 LLM에 프롬프트하고, 그 다음 그 일반적인 질문에 대한 답변을 특정 작업에 대한 후속 프롬프트에 피드백함으로써 성능을 향상시키는 기술입니다. 이 '한 발 물러서기'는 LLM이 특정 문제를 해결하려고 시도하기 전에 관련 배경 지식과 추론 과정을 활성화할 수 있게 합니다.

더 광범위하고 기본적인 원칙을 고려함으로써, LLM은 더 정확하고 통찰력 있는 응답을 생성할 수 있습니다. 스텝백 프롬프팅은 LLM이 비판적으로 생각하고 새롭고 창의적인 방식으로 지식을 적용하도록 장려합니다. 이는 LLM이 직접 프롬프트될 때 활성화되는 것보다 더 많은 지식을 LLM의 매개변수에서 활용하여 작업을 수행하는 최종 프롬프트를 변경합니다.

일반 원칙에 초점을 맞춤으로써 특정 세부 사항 대신, 스텝백 프롬프팅은 LLM 응답의 편향을 완화하는 데 도움이 될 수 있습니다.

스텝백 프롬프팅이 결과를 향상시킬 수 있는 방법을 이해하기 위해 이러한 예시를 살펴보겠습니다. 먼저 전통적인 프롬프트를 살펴본 다음 스텝백 프롬프트와 비교해 보겠습니다:

|목표|일인칭 슈팅 비디오 게임 레벨의 스토리라인 작성하기|
|---|---|
|모델|gemini-pro|
|온도|1|
|Top-K|40|
|프롬프트|도전적이고 매력적인 일인칭 슈팅 비디오 게임의 새로운 레벨에 대한 스토리라인을 한 단락으로 작성하세요.|
|출력|이 레벨은 플레이어의 분대가 끈질긴 적 파벌에 의해 도심 지역에서 매복 당하면서 시작됩니다. 플레이어는 뒷골목과 황폐한 건물들의 미로를 통해 싸우며 나아가야 하며, 적을 제거하고 탐지를 피하기 위해 은신과 정확성을 활용해야 합니다. 플레이어는 환경을 자신에게 유리하게 사용하여 함정을 설치하고, 엄폐물을 활용하며, 생존하기 위해 계산된 움직임을 해야 합니다. 도중에, 그들은 적이 파괴적인 공격을 계획하고 있다는 것을 암시하는 정보를 발견하게 되고, 플레이어는 적이 그들의 계획을 실행하기 전에 증거를 수집하여 본부에 전달하기 위해 시간과의 경주를 해야 합니다.|

온도를 1로 설정하면 스토리라인에 대한 모든 종류의 창의적인 글을 얻을 수 있지만, 이는 꽤 무작위적이고 일반적입니다. 이제 한 발 물러서서 생각해 봅시다:

|프롬프트|인기 있는 일인칭 슈팅 액션 게임을 기반으로, 일인칭 슈팅 비디오 게임에서 도전적이고 매력적인 레벨 스토리라인에 기여하는 5가지 가상의 주요 배경은 무엇인가요?|
|---|---|
|출력|1. **버려진 군사 기지**: 변이된 군인들과 광란의 로봇들이 들끓는 종말 이후의 광대한 군사 단지로, 도전적인 총기 전투에 이상적입니다.<br>2. **사이버펑크 도시**: 높은 마천루와 빽빽한 골목이 있는 네온 불빛의 미래적인 도시 환경으로, 사이버네틱 강화 적들과 해킹 메커니즘이 특징입니다.<br>3. **외계인 우주선**: 지구에 좌초된 거대한 외계 선박으로, 으스스한 복도, 무중력 구역, 만날 수 있는 외계 생물체가 있습니다.<br>4. **좀비 점령 마을**: 공격적인 좀비 무리에 점령된 황량한 마을로, 격렬한 근접 전투와 안전한 통로를 찾기 위한 퍼즐 해결이 특징입니다.<br>5. **수중 연구 시설**: 물에 잠긴 심해 연구소로, 변이된 수중 생물체로 가득 차 있으며, 생존을 위해 스텔스와 수중 탐험 기술이 필요합니다.|

그렇군요, 이 주제들은 1인칭 슈팅 비디오 게임에 적합해 보입니다. 이제 원래 프롬프트로 돌아가되, 이번에는 스텝백의 답변을 맥락으로 포함하여 어떤 결과가 나오는지 살펴보겠습니다.

|프롬프트|맥락: 1인칭 슈팅 비디오 게임을 위한 5가지 매력적인 테마:<br>1. **버려진 군사 기지**: 변이된 군인들과 광란의 로봇들이 들끓는 종말 이후의 광대한 군사 단지로, 도전적인 총기 전투에 이상적입니다.<br>2. **사이버펑크 도시**: 높은 마천루와 빽빽한 골목이 있는 네온 불빛의 미래적인 도시 환경으로, 사이버네틱 강화 적들과 해킹 메커니즘이 특징입니다.<br>3. **외계인 우주선**: 지구에 좌초된 거대한 외계 선박으로, 으스스한 복도, 무중력 구역, 만날 수 있는 외계 생물체가 있습니다.<br>4. **좀비 점령 마을**: 공격적인 좀비 무리에 점령된 황량한 마을로, 격렬한 근접 전투와 안전한 통로를 찾기 위한 퍼즐 해결이 특징입니다.<br>5. **수중 연구 시설**: 물에 잠긴 심해 연구소로, 변이된 수중 생물체로 가득 차 있으며, 생존을 위해 스텔스와 수중 탐험 기술이 필요합니다.<br><br>이 테마 중 하나를 선택하여 도전적이고 매력적인 일인칭 슈팅 비디오 게임의 새로운 레벨에 대한 스토리라인을 한 단락으로 작성하세요.|
|---|---|
|출력|탁한 심연의 중심부에 위치한 황폐한 수중 연구 시설은 인간의 야망과 그 재앙적 결과를 증명하는 유물로 서 있습니다. 어둠에 휩싸여, 오작동하는 기계의 웅웅거림과 익사한 영혼들의 메아리가 울려 퍼지는 이 시설은 이제 심해에서 태어난 악몽의 번식지가 되었습니다. 플레이어는 첨단 다이빙 장비와 실험적 무기를 갖춘 엘리트 해병으로서, 이 수중 공포의 영역에 모험을 떠나게 됩니다. 회복력과 자원을 갖추고, 그들은 위험한 복도를 헤치고, 암호 퍼즐을 풀고, 깊은 곳에 숨어 있는 끔찍한 해양 괴물과 맞서야 합니다. 심해의 압박감에 대처하는 것부터 교활한 수중 포식자를 능가하는 것까지, 이 미지의 세계의 모든 순간은 인간 인내력과 용기의 한계를 시험합니다.|

재미있는 비디오 게임이 될 것 같네요! 스텝백 프롬프팅 기법을 사용하면 프롬프트의 정확도를 향상시킬 수 있습니다.

## 사고 체인(Chain of Thought, CoT)

사고 체인(CoT) 프롬프팅은 중간 추론 단계를 생성함으로써 LLM의 추론 능력을 향상시키는 기술입니다. 이는 LLM이 더 정확한 답변을 생성하는 데 도움이 됩니다. 더 복잡한 추론이 필요한 작업에서 더 나은 결과를 얻기 위해 퓨샷 프롬프팅과 결합할 수 있습니다. 제로샷 사고 체인으로는 어려울 수 있기 때문입니다.

CoT는 많은 장점이 있습니다. 우선, 오프더셸프 LLM(미세 조정이 필요 없음)과 함께 사용하면서도 매우 효과적이고 노력이 적게 듭니다. 또한 CoT 프롬프팅을 통해 해석 가능성을 얻을 수 있으며, LLM의 응답에서 배우고 따라진 추론 단계를 볼 수 있습니다. 오작동이 있는 경우, 이를 식별할 수 있습니다. 사고 체인은 다른 LLM 버전 간의 이동 시 견고성을 향상시키는 것으로 보입니다. 이는 프롬프트가 추론 체인을 사용하지 않는 경우보다 다른 LLM 간에 성능 편차가 적다는 것을 의미합니다. 물론 단점도 있지만, 그것들은 다소 직관적입니다.

LLM 응답에는 사고 체인 추론이 포함되어 있어 더 많은 출력 토큰이 생성되므로, 예측 비용이 증가하고 시간이 더 오래 걸립니다.

아래 표의 다음 예제를 설명하기 위해, 먼저 대형 언어 모델의 결함을 보여주기 위한 CoT 프롬프팅을 사용하지 않는 프롬프트를 만들어 보겠습니다.

| 프롬프트 | 내가 3살이었을 때, 내 파트너는 나이가 내 나이의 3배였습니다. 지금 나는 20살입니다. 내 파트너의 나이는 몇 살인가요? |
| ---- | --------------------------------------------------------------------- |
| 출력   | 63살                                                                   |

이런! 이것은 분명히 잘못된 답변입니다. 사실, LLM은 수학적 작업에서 종종 어려움을 겪으며 두 숫자를 곱하는 것처럼 간단한 작업에서도 잘못된 답변을 제공할 수 있습니다. 이는 LLM이 대량의 텍스트에 대해 학습되고 수학이 다른 접근 방식을 필요로 할 수 있기 때문입니다. 그럼 중간 추론 단계가 출력을 개선할지 살펴봅시다.

|프롬프트|내가 3살이었을 때, 내 파트너는 나이가 내 나이의 3배였습니다. 지금 나는 20살입니다. 내 파트너의 나이는 몇 살인가요? 단계별로 생각해봅시다.|
|---|---|
|출력|1. 내 현재 나이를 "x"년이라고 가정해봅시다.<br>2. 내가 3살이었을 때, 내 나이는 3년이었습니다.<br>3. 그 당시 내 파트너의 나이는 내 나이의 3배로, 3 * 3 = 9살이었습니다.<br>4. 지금 나는 20살이며, 이는 내가 3살이었을 때보다 20 - 3 = 17년이 지났다는 것을 의미합니다.<br>5. 내 파트너의 나이가 내가 3살일 때 9살이었고, 내 나이가 17년 증가했으므로, 내 파트너의 나이도 17년 증가했어야 합니다.<br>6. 따라서 내 파트너의 현재 나이는 9 + 17 = 26살입니다.<br><br>그래서 내 파트너는 26살입니다.|

좋습니다. 이제 최종 답변이 정확합니다. 각 단계를 설명하라고 LLM에게 명확하게 지시했기 때문에 그냥 답변을 반환하는 대신입니다. 모델이 증가한 17년을 더한 것을 보니 흥미롭습니다. 제 생각에는 내 파트너와 나 사이의 나이 차이를 계산하고 그것을 더했을 것입니다(20+(9-3)). 모델이 저처럼 생각할 수 있도록 도와봅시다.

위 표는 '제로샷' 사고 체인의 예시입니다. 사고 체인 프롬프팅은 싱글샷이나 퓨샷과 결합될 때 매우 강력할 수 있습니다. 아래 표에서 볼 수 있듯이:

|프롬프트|Q: 내 남동생이 2살이었을 때, 나는 그의 나이의 두 배였습니다. 지금 나는 40살입니다. 내 남동생은 몇 살인가요? 단계별로 생각해봅시다.<br>A: 내 남동생이 2살일 때, 나는 2 * 2 = 4살이었습니다. 이는 2살의 나이 차이이며 내가 더 나이가 많습니다. 지금 나는 40살이므로, 내 남동생은 40 - 2 = 38살입니다. 답은 38입니다.<br><br>Q: 내가 3살이었을 때, 내 파트너는 나이가 내 나이의 3배였습니다. 지금 나는 20살입니다. 내 파트너의 나이는 몇 살인가요? 단계별로 생각해봅시다.<br>A:|
|---|---|
|출력|내가 3살이었을 때, 내 파트너는 3 * 3 = 9살이었습니다. 이는 6살의 나이 차이이며 내 파트너가 더 나이가 많습니다. 지금 나는 20살이므로, 내 파트너는 20 + 6 = 26살입니다. 답은 26입니다.|

사고 체인은 다양한 사용 사례에 유용할 수 있습니다. 코드 생성에서는 요청을 몇 가지 단계로 나누고, 그 단계를 특정 코드 라인에 매핑하는 데 유용합니다. 또는 "제품명은 XYZ이며, 제품의 주어진 제목을 기반으로 가정을 안내하는 설명을 작성하세요"와 같은 시드가 있을 때 합성 데이터를 생성하는 데에도 유용합니다. 일반적으로, '말하면서 생각하기'를 통해 해결할 수 있는 모든 작업은 사고 체인에 좋은 후보입니다. 문제를 해결하기 위한 단계를 설명할 수 있다면, 사고 체인을 시도해보세요.

GoogleCloudPlatform Github 저장소에 호스팅된 노트북을 참조하면 CoT 프롬프팅에 대한 더 자세한 내용을 확인할 수 있습니다.

이 장의 모범 사례 섹션에서 사고 체인 프롬프팅에 특화된 몇 가지 모범 사례를 배울 것입니다.

## 자기 일관성(Self-consistency)

대형 언어 모델은, 다양한 NLP 작업에서 인상적인 성공을 보여왔지만, 그 추론 능력은 종종 모델 크기만 증가시켜서는 극복할 수 없는 한계로 여겨집니다. 이전 사고 체인 프롬프팅 섹션에서 배웠듯이, 모델은 문제를 해결하는 인간처럼 추론 단계를 생성하도록 프롬프트될 수 있습니다. 그러나 CoT는 단순한 '탐욕적 디코딩' 전략을 사용하여 그 효과가 제한됩니다. 자기 일관성은 샘플링과 다수결 투표를 결합하여 다양한 추론 경로를 생성하고 가장 일관된 답변을 선택합니다. 이는 LLM이 생성한 응답의 정확성과 일관성을 향상시킵니다.

자기 일관성은 답변이 정확할 가능성에 대한 유사 확률을 제공하지만, 당연히 비용이 높습니다.

다음 단계를 따릅니다:

1. 다양한 추론 경로 생성: LLM에 동일한 프롬프트를 여러 번 제공합니다. 높은 온도 설정은 모델이 문제에 대한 다른 추론 경로와 관점을 생성하도록 장려합니다.
2. 각 생성된 응답에서 답변을 추출합니다.
3. 가장 일반적인 답변을 선택합니다.

이메일을 IMPORTANT 또는 NOT IMPORTANT로 분류하는 이메일 분류 시스템의 예를 살펴보겠습니다. 제로샷 사고 체인 프롬프트를 LLM에 여러 번 보내 응답이 각 제출 후 다른지 확인할 것입니다. 이메일에 사용된 친근한 톤, 단어 선택 및 풍자에 주목하세요. 이 모든 것이 LLM을 속일 수 있습니다.

| 프롬프트    | EMAIL:<br>`<br>안녕하세요,<br>귀하의 웹사이트에 워드프레스를 사용하시는 것을 확인했습니다. 훌륭한 오픈 소스 콘텐츠 관리 시스템이죠. 저도 과거에 사용한 적이 있습니다. 많은 훌륭한 사용자 플러그인이 있고 설정하기도 꽤 쉽습니다.<br><br>연락 양식에서 이름 필드를 선택할 때 발생하는 버그를 발견했습니다. 이름 필드에 텍스트를 입력하는 제 스크린샷을 참고하세요. 제가 inv0k3d한 자바스크립트 경고 상자에 주목하세요.<br><br>하지만 나머지는 훌륭한 웹사이트입니다. 읽는 것을 즐깁니다. 웹사이트에 버그를 그대로 두셔도 괜찮습니다. 제게 더 흥미로운 읽을거리를 제공해주니까요.<br><br>감사합니다,<br>해커 해리<br>`<br><br>위 이메일을 IMPORTANT 또는 NOT IMPORTANT로 분류하세요. 단계별로 생각하고 이유를 설명해보세요.                                                                                                                                                         |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 시도 1 출력 | **1단계: 이메일의 목적 확인하기.** 이메일의 목적은 웹사이트의 연락 양식에 있는 버그를 수신자에게 알리는 것입니다. 발신자는 또한 웹사이트를 즐겨 읽는다고 언급하며 버그는 현재 그대로 두어도 된다고 말합니다.<br><br>**2단계: 버그의 잠재적 영향 평가하기.** 연락 양식의 버그는 공격자가 웹사이트에서 임의의 자바스크립트 코드를 실행할 수 있게 할 수 있습니다. 이로 인해 공격자가 웹사이트를 제어하거나, 민감한 정보를 훔치거나, 웹사이트를 훼손할 수 있습니다.<br><br>**3단계: 발신자의 신뢰성 고려하기.** 이메일 발신자는 자신을 해커 해리라고 주장합니다. 그러나 발신자의 신원을 확인할 방법은 없습니다. 발신자가 수신자를 돕기 위해 노력하는 합법적인 해커일 수도 있지만, 수신자가 악성 링크를 클릭하거나 악성 파일을 다운로드하도록 속이려는 악의적인 행위자일 수도 있습니다.<br><br>**결론: IMPORTANT** 버그의 잠재적 영향과 발신자의 신뢰성을 고려할 때, 이 이메일은 **IMPORTANT**로 분류되어야 합니다. 수신자는 버그를 수정하고 웹사이트를 공격으로부터 보호하기 위해 즉각적인 조치를 취해야 합니다.   |
| 시도 2 출력 | **설명:**<br><br>1. **긴급성 부족:** 이메일은 시간적 긴급성이나 민감성을 전달하지 않습니다. 캐주얼한 인사로 시작하여 사실 기반의 어조로 정보를 제시합니다.<br>    <br>2. **중요하지 않은 버그 보고:** 보고된 연락 양식의 버그는 흥미롭지만 중요하지 않은 것으로 설명됩니다. 이메일 발신자는 웹사이트 소유자가 버그를 그대로 둘 수 있다고 제안합니다.<br>    <br>3. **개인적 영향 부족:** 이메일은 웹사이트 소유자에 대한 직접적이거나 개인적인 영향을 나타내지 않습니다. 단지 발신자가 웹사이트 읽는 것을 즐긴다고 언급합니다.<br>    <br>4. **행동 요청 부재:** 이메일은 웹사이트 소유자에게 어떤 행동도 명시적으로 요청하지 않습니다. 버그를 수정하라고 요청하지 않으며 개선을 위한 특정 제안도 제공하지 않습니다.<br>    <br>5. **발신자의 의도:** 발신자의 의도는 웹사이트에 대한 심각한 우려를 제기하기보다는 관찰을 공유하고 웹사이트에 대한 관심을 표현하는 데 더 초점이 맞춰진 것으로 보입니다.  <br><br>**결론: NOT IMPORTANT**                    |
| 시도 3 출력 | **1단계: 이메일의 목적 확인하기.** 이메일의 목적은 웹사이트의 연락 양식에 있는 버그를 수신자에게 알리는 것입니다. 발신자는 또한 웹사이트를 즐겨 읽는다고 언급하며 버그는 현재 그대로 두어도 된다고 말합니다.<br><br>**2단계: 버그의 잠재적 영향 평가하기.** 연락 양식의 버그는 공격자가 웹사이트에서 임의의 자바스크립트 코드를 실행할 수 있게 할 수 있습니다. 이로 인해 공격자가 웹사이트를 제어하거나, 민감한 정보를 훔치거나, 웹사이트를 훼손할 수 있습니다.<br><br>**3단계: 발신자의 신뢰성 고려하기.** 이메일 발신자는 자신을 해커 해리라고 주장합니다. 그러나 발신자의 신원을 확인할 방법은 없습니다. 발신자가 수신자를 돕기 위해 노력하는 합법적인 해커일 수도 있지만, 발신자가 버그를 자신의 이익을 위해 악용하려는 악의적인 행위자일 수도 있습니다.<br><br>**결론:** 위 요소를 고려할 때, 이 이메일은 **IMPORTANT**로 분류되어야 합니다. 연락 양식의 버그는 심각한 보안 위험이며, 발신자의 신뢰성은 알 수 없습니다. 수신자는 버그를 수정하고 발신자의 주장을 조사하기 위해 즉각적인 조치를 취해야 합니다. |

위의 프롬프트를 사용하여 일관된 분류가 반환되는지 확인해 보세요. 사용 중인 모델과 온도 구성에 따라 "IMPORTANT" 또는 "NOT IMPORTANT"가 반환될 수 있습니다.

여러 개의 사고 체인을 생성하고 가장 일반적으로 발생하는 답변("IMPORTANT")을 취함으로써 LLM에서 더 일관되게 정확한 답변을 얻을 수 있습니다.

이 예시는 여러 관점을 고려하고 가장 일관된 답변을 선택함으로써 LLM 응답의 정확도를 향상시키기 위해 자기 일관성 프롬프팅을 사용할 수 있는 방법을 보여줍니다.

## 사고 트리(Tree of Thoughts, ToT)
이제 사고 체인과 자기 일관성 프롬프팅에 익숙해졌으니, 사고 트리(ToT)를 살펴보겠습니다. 이는 CoT 프롬프팅의 개념을 일반화하여 LLM이 단일 선형 사고 체인을 따르는 대신 여러 다른 추론 경로를 동시에 탐색할 수 있게 합니다. 이는 그림 1에 묘사되어 있습니다.

![[Pasted image 20250413144016.png]]

이 접근 방식은 ToT를 탐색이 필요한 복잡한 작업에 특히 적합하게 만듭니다. 문제 해결을 향한 중간 단계 역할을 하는 일관된 언어 시퀀스를 나타내는 생각들의 트리를 유지함으로써 작동합니다. 그런 다음 모델은 트리의 다른 노드에서 분기함으로써 다른 추론 경로를 탐색할 수 있습니다.

'대형 언어 모델 안내 사고 트리'에 기반한 사고 트리(ToT)를 더 자세히 보여주는 훌륭한 노트북이 있습니다.

## ReAct (추론 & 행동)
추론 및 행동(ReAct) 프롬프팅은 LLM이 자연어 추론과 외부 도구(검색, 코드 인터프리터 등)를 결합하여 복잡한 작업을 해결할 수 있게 하는 패러다임입니다. 이를 통해 LLM은 정보를 검색하기 위해 외부 API와 상호작용하는 것과 같은 특정 행동을 수행할 수 있으며, 이는 에이전트 모델링을 향한 첫 번째 단계입니다.

ReAct는 인간이 실제 세계에서 작동하는 방식을 모방합니다. 우리는 언어적으로 추론하고 정보를 얻기 위한 행동을 취할 수 있습니다. ReAct는 다양한 도메인에서 다른 프롬프트 엔지니어링 접근 방식에 비해 좋은 성능을 보입니다.

ReAct 프롬프팅은 추론과 행동을 사고-행동 루프로 결합하여 작동합니다. LLM은 먼저 문제에 대해 추론하고 행동 계획을 생성합니다. 그런 다음 계획의 행동을 수행하고 결과를 관찰합니다. LLM은 이러한 관찰을 사용하여 추론을 업데이트하고 새로운 행동 계획을 생성합니다. 이 과정은, LLM이 문제에 대한 해결책에 도달할 때까지 계속됩니다.

이를 실제로 보려면 코드를 작성해야 합니다. 코드 스니펫 1에서는 Python용 langchain 프레임워크와 VertexAI(google-cloud-aiplatform) 및 google-search-results pip 패키지를 함께 사용하고 있습니다.

이 샘플을 실행하려면 https://serpapi.com/manageapi-key에서 (무료) SerpAPI 키를 생성하고 SERPAPI_API_KEY 환경 변수를 설정해야 합니다.

다음으로 Metallica 밴드에서 공연하는 유명한 아빠를 둔 자녀가 몇 명인지 알아내는 작업을 LLM이 수행하도록 Python 코드를 작성해 보겠습니다.

```python
from langchain.agents import load_tools
from langchain.agents import initialize_agent
from langchain.agents import AgentType
from langchain.llms import VertexAI

prompt = "How many kids do the band members of Metallica have?"

llm = VertexAI(temperature=0.1)
tools = load_tools(["serpapi"], llm=llm)
agent = initialize_agent(tools, llm, 
agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True)
agent.run(prompt)
```

아래는 결과를 보여줍니다. ReAct가 밴드 이름을 알아내기 위해 5개의 검색을 연결하는 것을 주목하세요. 사실, LLM은 Google 검색 결과를 스크랩하여 밴드 이름을 파악합니다. 그런 다음 관찰로서 결과를 나열하고 다음 검색에 대한 생각을 연결합니다.

```
> Entering new AgentExecutor chain...
Metallica has 4 members. 
Action: Search
Action Input: How many kids does James Hetfield have?
Observation: three children
Thought: 1/4 Metallica band members have 3 children
Action: Search
Action Input: How many kids does Lars Ulrich have?
Observation: 3
Thought: 2/4 Metallica band members have 6 children
Action: Search
Action Input: How many kids does Kirk Hammett have?
Observation: Hammett has been married to his second wife Lani since 1998. 
They have two sons, Angel (b. September 29, 2006) and Vincenzo (b. June 
28, 2008).
Thought: 3/4 Metallica band members have 8 children
Action: Search
Action Input: How many kids does Robert Trujillo have?
Observation: 2
Thought: 4/4 Metallica band members have 10 children
Final Answer: 10
```

위는 Metallica 밴드가 4명의 밴드 멤버를 가지고 있다는 것을 파악합니다. 그런 다음 각 밴드 멤버를 검색하여 자녀의 총 수를 요청하고 합계를 더합니다. 마지막으로 최종 답변으로 자녀의 총 수를 반환합니다.

실제로 ReAct 프롬프팅을 사용하려면 이전 프롬프트/응답을 계속 재전송하고(그리고 추가로 생성된 내용을 제거) 적절한 예제/지시로 모델을 설정해야 합니다. GoogleCloudPlatform Github 저장소에 호스팅된 노트북을 참조하면 더 자세한 예제로 실제 LLM 입력 및 출력을 보여주는 자세한 내용을 확인할 수 있습니다.

## 자동 프롬프트 엔지니어링

이 시점에서 프롬프트 작성이 복잡할 수 있다는 것을 알게 되었을 것입니다. 프롬프트를 작성하는 프롬프트를 자동화하면 좋지 않을까요? 실제로 자동 프롬프트 엔지니어링(Automatic Prompt Engineering, APE)이라는 방법이 있습니다. 이 방법은 사람의 입력 필요성을 줄일 뿐만 아니라 다양한 작업에서 모델의 성능도 향상시킵니다.

모델에게 더 많은 프롬프트를 생성하도록 지시하게 됩니다. 이를 평가하고, 좋은 것들은 수정한 다음 반복합니다.

예를 들어, 밴드 머천다이즈 티셔츠 웹샵용 챗봇 훈련을 돕는 자동 프롬프트 엔지니어링을 사용할 수 있습니다. 고객이 밴드 머천다이즈 티셔츠 주문을 표현할 수 있는 다양한 방식을 파악하고자 합니다.

1. 출력 변형을 생성할 프롬프트를 작성합니다. 이 예제에서는 10개의 지시문을 생성하기 위해 gemini-pro를 사용하고 있습니다. 아래 표를 참조하세요:

| 프롬프트 | 밴드 머천다이즈 티셔츠 웹샵이 있고, 챗봇 훈련을 위해 다양한 주문 방식이 필요합니다: "메탈리카 티셔츠 S사이즈 한 개". 의미는 같지만 표현 방식이 다른 10가지 변형을 생성해주세요.                                                                                                                                                                                                                                             |
| ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 출력   | 1. 메탈리카 티셔츠를 스몰 사이즈로 한 개 구매하고 싶습니다.<br>2. 스몰 사이즈 메탈리카 티셔츠 한 장 주문할 수 있을까요?<br>3. 메탈리카 티셔츠 스몰 사이즈로 하나 구매하고 싶어요.<br>4. 메탈리카 셔츠 스몰 사이즈로 한 장 부탁합니다.<br>5. 메탈리카 티셔츠 스몰 사이즈 한 개 원합니다.<br>6. 메탈리카 티셔츠 스몰 사이즈로 한 장 주문하고 싶습니다.<br>7. 스몰 메탈리카 티셔츠 한 장 주세요.<br>8. 메탈리카 티셔츠 스몰 사이즈 한 장 찾고 있어요.<br>9. 메탈리카 티셔츠 스몰 사이즈로 하나 구해주실 수 있나요?<br>10. 메탈리카 스몰 티셔츠 한 장 부탁해요. |
2.  선택한 지표에 기반하여 모든 지시 후보를 평가하여 점수를 매깁니다. 예를 들어, BLEU(Bilingual Evaluation Understudy) 또는 ROUGE(Recall-Oriented Understudy for Gisting Evaluation)를 사용할 수 있습니다.
3. 평가 점수가 가장 높은 지시 후보를 선택합니다. 이 후보는 소프트웨어 애플리케이션이나 챗봇에서 사용할 수 있는최종 프롬프트가 됩니다. 선택한 프롬프트를 조정하고 다시 평가할 수도 있습니다.

## 코드 프롬프팅
Gemini는 주로 텍스트 기반 프롬프트에 중점을 두고 있으며, 여기에는 코드를 반환하기 위한 프롬프트 작성도 포함됩니다. Vertex AI Studio에서 이러한 프롬프트를 테스트하여 코딩 예제를 살펴보겠습니다.

### 코드 작성을 위한 프롬프트
Gemini는 개발자로서 어떤 프로그래밍 언어로든 코드 작성을 도울 수 있습니다. 개발자로서 이는 코드 작성 과정을 빠르게 진행하는 데 도움이 됩니다.

기기에 있는 폴더에 수백 개의 파일이 있고 이름을 변경해야 한다고 상상해 보세요. 각 파일의 이름을 바꾸는 데 많은 시간이 걸릴 것입니다. Bash를 조금 알고 있어서 이를 자동화하는 스크립트를 작성할 수 있지만, 그것도 시간이 걸릴 수 있습니다. 그래서 프롬프트를 작성해 보겠습니다. 공개 소비자 챗봇 Gemini에 프롬프트를 작성하거나, 기밀 유지에 더 신경 쓰신다면 Google Cloud 계정 내에서 이러한 프롬프트를 작성하고 Vertex AI Studio를 열 수 있습니다. Vertex AI Studio의 장점은 온도 등을 구성할 수 있다는 것입니다.

| 이름    | 1_bash_rename_files_in_folder                                                                    |
| ----- | ------------------------------------------------------------------------------------------------ |
| 목표    | 폴더 내 파일 이름을 변경하는 Bash 코드를 작성하기 위한 프롬프트 작성                                                        |
| 모델    | gemini-pro                                                                                       |
| 온도    | 0.1                                                                                              |
| Top-K | N/A                                                                                              |
| 프롬프트  | 폴더 이름을 요청하는 Bash 코드 스니펫을 작성해주세요. 그런 다음 폴더의 내용을 가져와서 내부의 모든 파일 이름 앞에 'draft'라는 단어를 붙여서 이름을 변경합니다. |
| 출력    | ![[Pasted image 20250413145744.png]]                                                             |

코드가 좋아 보입니다 - 심지어 주석까지 포함되어 있습니다! 그러나 LLM은 추론할 수 없고 학습 데이터를 반복하므로, 먼저 코드를 읽고 테스트하는 것이 필수적입니다.

우리가 모두 기다려온 순간입니다. 정말 작동할까요?

테스트 폴더에 몇 개의 파일이 있고, filename.txt에서 draft_filename.txt로 이름을 바꿔야 하는 상황에서 먼저 시도해 보겠습니다.

1. 표 16의 출력에서 `bash` 텍스트 래퍼 없이 내용을 복사하여 "rename_files.sh"라는 새 파일에 붙여넣습니다.
2. 터미널 창을 열고 다음 명령어를 입력합니다: `. rename_files.sh`. 폴더 이름 입력을 요청할 것입니다. 예를 들어 `test`를 입력하고 엔터를 누릅니다.
3. 스크립트가 잘 실행되는 것처럼 보입니다. "파일 이름이 성공적으로 변경되었습니다."라는 메시지가 표시됩니다.

test 폴더를 살펴보면 모든 파일이 완벽하게 draft_filename.txt로 이름이 변경된 것을 확인할 수 있습니다.

작동합니다!

### 코드 설명을 위한 프롬프트
개발자로서 팀에서 작업할 때 다른 사람의 코드를 읽어야 합니다. Gemini는 이 부분에서도 도움을 줄 수 있습니다. 위 표의 코드 출력을 가져와 주석을 제거하고 대형 언어 모델에게 무슨 일이 일어나고 있는지 설명하도록 요청해 보겠습니다. 아래 표 참조하세요:

| 이름    | 1_bash_explain_the_code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 목표    | Bash 코드를 설명하는 프롬프트 작성                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 모델    | gemini-pro                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 온도    | 0.1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Top-K | N/A                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 프롬프트  | 아래 Bash 코드를 설명해주세요:<br>![[Pasted image 20250413145926.png]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 출력    | 이 Bash 스크립트는 다음 작업을 수행합니다:<br><br>1. **사용자 입력**:<br>- `echo`와 `read` 명령어를 사용하여 사용자에게 폴더 이름을 입력하도록 요청합니다. 입력된 폴더 이름은 `folder_name` 변수에 저장됩니다.<br>2. **폴더 존재 여부 확인**:<br>- `[ ! -d "$folder_name" ]` 조건을 사용하여 지정된 이름의 폴더가 존재하는지 확인합니다. 폴더가 존재하지 않으면 오류 메시지("폴더가 존재하지 않습니다.")를 표시하고 종료 코드 1로 스크립트를 종료합니다.<br> 3. **파일 목록**:<br>- `files=( "$folder_name"/* )` 명령을 사용하여 지정된 폴더 내의 모든 파일 경로를 포함하는 `files`라는 배열을 생성합니다.<br>4. **파일 이름 변경**:<br>- `for` 루프를 사용하여 `files` 배열의 각 파일을 반복합니다.<br>- 각 파일에 대해, `new_file_name="draft_$(basename "$file")"` 명령으로 새 파일 이름을 생성합니다. 이 새 파일 이름은 원본 파일 이름 앞에 "draft_" 문자열을 붙여 만들어집니다.<br>- 그런 다음 `mv "$file" "$new_file_name"` 명령을 사용하여 파일을 새 이름으로 이동(즉, 이름 변경)합니다.<br>5. **성공 메시지**:<br>- 모든 파일 이름 변경 후, 작업이 성공적으로 완료되었음을 알리는 성공 메시지("파일 이름이 성공적으로 변경되었습니다.")를 표시합니다. |

아래부터 원하신 46페이지의 **Prompts for translating code** 섹션을 프론트엔드 개발 문서 번역 가이드라인에 따라 번역하겠습니다. 원하는 분량 이후 "다음"이라고 말씀해 주시면 계속해서 진행하겠습니다.

---

## 코드 번역을 위한 프롬프트(Prompts for translating code)

앞선 표의 Bash 코드가 잘 작동하는 것으로 보입니다. 그러나 이 스크립트는 사용자로부터 파일명을 입력받도록 개선하면 재사용성이 높아질 것입니다. 이상적으로는 UI가 있는 별도의 애플리케이션으로 동작하면 좋겠죠. 이 경우, 웹 애플리케이션으로 적합한 Python이 Bash보다 더 나은 선택이 될 것입니다.  
LLM(대형 언어 모델)은 이러한 코드 번역 작업에도 유용합니다. 다음 표에서는 Bash 코드를 Python 코드로 변환하는 예시를 소개합니다:

| 이름                 | 1_python_rename_files                                                      |
| ------------------ | -------------------------------------------------------------------------- |
| 목표                 | Bash 코드를 Python으로 번역하는 프롬프트 작성                                             |
| 모델                 | gemini-pro                                                                 |
| 온도(Temperature)    | 0.1                                                                        |
| 토큰 제한(Token Limit) | 1024                                                                       |
| Top-K              | N/A                                                                        |
| Top-P              | 1                                                                          |
| 프롬프트               | 다음의 Bash 코드를 Python 코드로 변환하세요:<br>![[Pasted image 20250413152653.png]]<br> |
| 출력                 | ![[Pasted image 20250413152720.png]]                                       |


코드를 리뷰한 뒤, 출력 내용을 복사하여 새 파일 `file_renamer.py`로 저장하고, 터미널에서 `python file_renamer.py` 명령어로 테스트해 보세요.

> [!note] 주의사항:
> Vertex AI의 Language Studio에서 (특히 Python과 같이 들여쓰기가 중요한 코드 생성 시) 반드시 마크다운(`Markdown`) 버튼을 클릭해야 합니다. 그렇지 않으면 들여쓰기가 올바르게 적용되지 않은 일반 텍스트로 출력됩니다.

## 코드 디버깅 및 리뷰를 위한 프롬프트 (Prompts for debugging and reviewing code)
앞서 표에서 제공된 Python 코드에 몇 가지 수정을 직접 가해 보겠습니다. 사용자에게 파일 이름의 접두사를 입력받고, 이를 대문자로 변환하도록 수정해보았습니다. 아래 코드 조각(Snippet 3)을 참조하십시오. 그러나 안타깝게도 Python 에러가 발생합니다!

```python
import os
import shutil

folder_name = input("Enter the folder name: ")
prefix = input("Enter the string to prepend to the filename: ")
text = toUpperCase(prefix)

if not os.path.isdir(folder_name):
    print("Folder does not exist.")
    exit(1)

files = os.listdir(folder_name)

for file in files:
    new_filename = f"{text}_{file}"

shutil.move(os.path.join(folder_name, file), 
os.path.joi(folder_name, new_file_name))

print("Files renamed successfully.")
```

이런! 버그가 생겼네요:

아래 Python 코드는 다음과 같은 에러를 발생시킵니다:

```bash
Traceback (most recent call last):
  File “/Users/leeboonstra/Documents/test_folder/rename_files.py”, line 7, 
in <module>
    text = toUpperCase(prefix)
NameError: name ‘toUpperCase’ is not defined
```

이제, 이 문제를 해결하기 위해 LLM을 활용하여 코드를 디버깅하고 리뷰하는 과정을 수행해 봅시다. 다음 표를 살펴보겠습니다:

| 이름                 | 1_python_debug_code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 목표                 | Python 코드를 디버깅하고 리뷰하기 위한 프롬프트 작성                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 모델                 | gemini-pro                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 온도(Temperature)    | 0.1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 토큰 제한(Token Limit) | 1024                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Top-K              | N/A                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Top-P              | 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 프롬프트               | 아래 Python 코드는 다음과 같은 에러가 발생합니다:<br><br>![[Pasted image 20250413152904.png]]<br><br>무엇이 문제인지 디버그하고, 코드를 개선할 수 있는 방법을 설명해 주세요.<br><br>![[Pasted image 20250413152912.png]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 출력                 | 코드에서 `toUpperCase` 함수를 호출하여 `prefix`를 대문자로 변환하려 했으나, 해당 함수가 정의되지 않아 오류가 발생했습니다.  <br>이 문제를 해결하려면 Python 문자열 클래스의 내장 메소드인 `upper()`를 사용하여 문자열을 대문자로 변환할 수 있습니다. 수정된 코드는 다음과 같습니다:<br><br>![[Pasted image 20250413153020.png]]<br><br>추가로, 이 코드의 다른 개선 사항들도 고려해볼 수 있습니다:<br><br>1. 새로운 파일명을 생성할 때 원본 파일의 확장자를 유지하는 것이 좋습니다. 원본 파일에서 확장자를 분리하여 새 파일명에 추가합니다.<br>    <br>2. 폴더명에 공백이 있을 경우를 처리하는 것이 좋습니다. 공백을 언더스코어나 하이픈으로 대체하여 문제를 예방할 수 있습니다.<br>    <br>3. 문자열 병합 시 전통적인 `+` 연산자 대신 Python의 f-string 방식을 사용하는 것이 가독성과 간결성을 높여줍니다.<br>    <br>4. 파일 이름 변경 과정에서 발생할 수 있는 예외를 처리하기 위해 `shutil.move` 호출을 `try...except` 블록으로 감싸는 것이 좋습니다.<br>    <br><br>이러한 제안 사항을 반영한 개선된 최종 코드는 다음과 같습니다:<br><br>![[Pasted image 20250413153101.png]]<br><br>이러한 개선 사항은 코드의 견고성과 유연성을 높여주며, 가독성도 향상시켜 줍니다. |

## 멀티모달 프롬프팅에 대해서는 어떨까요? (What about multimodal prompting?)

지금까지 다룬 코드 관련 프롬프팅은 기본적으로 일반적인 텍스트 기반의 대형 언어 모델(LLM)을 활용한 것이었습니다. 반면, **멀티모달 프롬프팅(Multimodal prompting)** 은 단순 텍스트 입력 외에도 다양한 형태의 입력을 사용하여 모델을 유도하는 기술입니다. 이는 모델의 역량과 작업에 따라 텍스트, 이미지, 오디오, 코드 등 여러 입력 형식을 혼합하여 사용할 수 있습니다.

## 모범 사례(Best Practices)
최적의 프롬프팅 방법을 찾기 위해서는 여러 번의 실험과 개선이 필요합니다. Google의 Vertex AI에 있는 Language Studio는 다양한 모델과 구성을 빠르게 실험하고 최적화된 프롬프팅을 찾기에 좋은 환경을 제공합니다.

다음의 모범 사례를 참고하여 프롬프팅 전문가로 성장할 수 있습니다.

### 예시 제공하기(Provide examples)

가장 중요한 모범 사례 중 하나는 프롬프트 내에 예시를 제공하는 것입니다. (one-shot/few-shot 프롬프팅)  
예시 제공은 매우 효과적인 학습 도구 역할을 합니다. 예시를 통해 원하는 결과 또는 유사한 응답을 모델이 직접 보게 함으로써, 모델이 이를 기준점으로 삼아 응답의 정확성, 스타일 및 어조를 더욱 정확히 맞출 수 있게 됩니다.

### 단순하게 설계하기(Design with simplicity)

프롬프팅은 간결하고 명확해야 하며, 사용자가 이해하기 쉽도록 구성되어야 합니다. 사용자가 읽기 어렵다면 모델 또한 혼란을 느끼게 됩니다. 복잡한 문장이나 불필요한 정보는 지양하십시오.

예시를 살펴보겠습니다:

**수정 전**

> I am visiting New York right now, and I'd like to hear more about great locations. I am with two 3 year old kids. Where should we go during our vacation?

**수정 후**

> Act as a travel guide for tourists. Describe great places to visit in New York Manhattan with a 3 year old.

명확한 동사 사용은 효과적입니다. 다음의 동사를 참고하세요:

- Act, Analyze, Categorize, Classify, Contrast, Compare, Create, Describe, Define, Evaluate, Extract, Find, Generate, Identify, List, Measure, Organize, Parse, Pick, Predict, Provide, Rank, Recommend, Return, Retrieve, Rewrite, Select, Show, Sort, Summarize, Translate, Write.

### 원하는 출력 형식을 구체화하기(Be specific about the output)

원하는 출력 결과를 명확히 지정하십시오. 간단한 지시어만으로는 LLM을 충분히 유도하지 못하거나 너무 일반적인 결과를 얻을 수 있습니다. 프롬프트에 세부 사항(시스템 또는 컨텍스트 프롬프팅)을 명확하게 제시하면 모델이 중요한 사항에 집중하여 정확성을 높일 수 있습니다.

예시:

✅ **바람직한 예:**

> Generate a 3 paragraph blog post about the top 5 video game consoles.  
> The blog post should be informative and engaging, and it should be written in a conversational style.

❌ **좋지 않은 예:**

> Generate a blog post about video game consoles.

### 제약보다는 명확한 지시어를 사용하기(Use Instructions over Constraints)

프롬프팅에서 지시사항(Instructions)과 제약사항(Constraints)은 모델의 출력을 제어하는 데 사용됩니다.

- **지시사항**은 응답의 형식, 스타일, 내용 등에 대한 명시적 지침을 제공하여 원하는 결과물을 정확하게 얻도록 안내합니다.
- **제약사항**은 응답에 대한 제한이나 금지사항을 제시하여 모델이 하지 말아야 할 행동이나 출력을 제한합니다.


최근 연구에 따르면 제약사항보다 명확한 지시사항을 사용하는 것이 더 효과적일 수 있습니다. 이는 인간이 부정적 금지사항보다는 긍정적인 지침을 선호하는 방식과 일치합니다.

명확한 지시사항은 원하는 결과를 직접 전달하며, 제약사항은 모델이 허용된 내용을 혼동할 가능성을 열어둘 수 있습니다. 제약사항은 유연성을 제한하여 창의성을 방해할 수 있으며, 여러 제약사항이 서로 충돌할 수도 있습니다.

그러나 특정 상황에서 제약사항은 여전히 유용합니다. 예를 들어, 모델이 유해하거나 편향된 내용을 생성하지 않도록 방지하거나, 엄격한 형식의 출력을 요구할 때 활용할 수 있습니다.

가능하면 부정적인 제약사항보다는 긍정적인 지침을 사용하십시오.

✅ **바람직한 예:**

> Generate a 1 paragraph blog post about the top 5 video game consoles. Only discuss the console, the company who made it, the year, and total sales.

❌ **좋지 않은 예:**

> Generate a 1 paragraph blog post about the top 5 video game consoles. Do not list video game names.

모범 사례로는 먼저 명확한 지시사항으로 시작하고, 필요한 경우에만 제약사항을 추가하십시오. 다양한 지시사항과 제약사항을 실험해 최적의 조합을 찾고 문서화하십시오.

### 최대 토큰 길이 제어하기(Control the max token length)
LLM 응답의 길이를 제한하려면 구성(configuration)에서 최대 토큰 제한을 설정하거나 프롬프트에 원하는 길이를 명시적으로 요청할 수 있습니다.

예시:

> "Explain quantum physics in a tweet length message."


### 프롬프트에 변수 사용하기 (Use variables in prompts)
프롬프트의 재사용성과 유연성을 높이기 위해 변수(variables)를 사용하면 좋습니다. 변수는 프롬프트 내에서 반복적으로 변경될 수 있는 입력 값을 처리하는 데 유용합니다. 예를 들어, 특정 도시에 대한 정보를 제공하는 프롬프트에서 도시 이름을 변수로 사용하면, 다양한 도시 이름을 입력하여 손쉽게 프롬프트를 재사용할 수 있습니다. 특히 애플리케이션에 프롬프팅을 통합할 때 더욱 유용합니다.

예시는 다음 표를 참조하세요.

| 프롬프트 예시 | 변수를 활용한 프롬프트                                                                                                                                         |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| 변수 선언   | `{city} = "Amsterdam"`                                                                                                                               |
| 프롬프트    | `You are a travel guide. Tell me a fact about the city: {city}`                                                                                      |
| 출력      | Amsterdam is a beautiful city full of canals, bridges, and narrow streets. It’s a great place to visit for its rich history, culture, and nightlife. |

### 입력 형식과 문체를 다양하게 실험하기 (Experiment with input formats and writing styles)
모델의 종류, 구성, 프롬프트 형식, 어휘 선택 등에 따라 출력 결과가 달라질 수 있습니다. 따라서 프롬프트의 문체, 어휘 선택, 유형(제로샷, 퓨샷, 시스템 프롬프팅 등)을 다양하게 실험해보는 것이 중요합니다.

예를 들어, '혁신적인 게임 콘솔인 세가 드림캐스트(Sega Dreamcast)'에 관한 텍스트 생성 프롬프팅은 질문형, 진술형, 명령형으로 다양하게 구성할 수 있으며, 각각의 방식에 따라 다른 결과가 나옵니다.

- **질문형 (Question):**
    
    > What was the Sega Dreamcast and why was it such a revolutionary console?
    
- **진술형 (Statement):**
    
    > The Sega Dreamcast was a sixth-generation video game console released by Sega in 1999. It...
    
- **명령형 (Instruction):**
    
    > Write a single paragraph that describes the Sega Dreamcast console and explains why it was so revolutionary.
    

### 분류 작업의 Few-shot 프롬프팅 시 클래스 혼합하기
일반적으로 Few-shot 프롬프팅에서 예시들의 순서는 크게 중요하지 않지만, 분류(classification) 작업에서는 가능한 클래스들을 고르게 섞어주는 것이 좋습니다. 특정 클래스의 순서로만 예시를 제공하면, 모델이 특정 순서에 과적합(overfitting)될 수 있기 때문입니다. 클래스들을 섞어서 제공하면, 모델이 각 클래스의 주요 특징을 더 잘 학습할 수 있습니다.

### 모델 업데이트에 따라 프롬프팅 조정하기
대형 언어 모델은 시간이 지나면서 업데이트될 수 있습니다. 이는 동일한 프롬프팅이 다른 모델 버전에서 다른 결과를 생성할 가능성이 있다는 것을 의미합니다. 새로운 모델 버전이 출시되면 기존 프롬프팅을 재평가하고 필요하다면 수정하여 최적의 성능을 유지해야 합니다.

### 출력 형식을 다양하게 실험하기 (Experiment with output formats)
다양한 출력 형식을 실험해 보십시오. 출력 결과의 형식은 모델이 생성하는 내용의 품질과 유용성에 영향을 줄 수 있습니다. 간단한 일반 텍스트, 마크다운, JSON, 코드 형식 등 다양한 출력 형태를 시도해 보십시오. 프롬프팅 과정에서 다양한 출력 형식을 실험하면 최적의 출력을 찾는 데 도움이 됩니다.

## JSON 복구 (JSON Repair)
LLM이 생성하는 JSON 출력이 때때로 유효하지 않은 JSON 형식으로 반환될 수 있습니다. 이는 프롬프팅을 통해 자동으로 복구할 수 있습니다. 예를 들어, 잘못된 JSON을 생성한 경우 LLM에 올바른 형식으로 복구하도록 요청할 수 있습니다.

다음은 잘못된 JSON을 복구하는 프롬프팅 예시입니다.

| 프롬프트 예시 | JSON 복구                                                                                                                        |
| ------- | ------------------------------------------------------------------------------------------------------------------------------ |
| 목표      | 잘못된 JSON 출력을 복구하는 프롬프트 작성                                                                                                      |
| 프롬프트    | 다음 JSON 데이터는 잘못된 형식입니다. 올바른 형식으로 수정해 주세요:`{"movie": "Her", "rating": "positive" "review": "A thought-provoking masterpiece."}` |
| 출력      | ![[Pasted image 20250413153918.png]]                                                                                           |

## 스키마 활용하기 (Working with Schemas)
LLM에 JSON 스키마(schema)를 미리 정의하여 제공하면, 보다 엄격하고 일관성 있는 JSON 출력을 얻을 수 있습니다. 이를 통해 응답을 쉽게 검증하고 파싱할 수 있습니다.

스키마 활용 프롬프팅 예시:

| 프롬프트 예시 | JSON 스키마 활용                                                                                                                              |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 목표      | 영화 리뷰를 JSON 스키마에 맞춰 반환하는 프롬프트 작성                                                                                                         |
| 프롬프트    | 영화 리뷰를 positive, negative 또는 neutral로 분류하고, 다음 JSON 스키마에 따라 출력해 주세요:```json{"movie_reviews": [{"name": "string", "sentiment": "POSITIVE" |
| 출력      | ![[Pasted image 20250413154009.png]]                                                                                                     |

## 다른 프롬프트 엔지니어와 함께 실험하기 (Experiment together with other prompt engineers)
효과적인 프롬프팅 전략을 찾는 것은 팀 작업이 될 때 가장 성공적입니다. 다양한 경험과 배경을 가진 팀원들과 함께 프롬프팅을 실험하여 새로운 아이디어와 관점을 얻을 수 있습니다. 협업을 통해 효율적인 프롬프팅 전략을 빠르게 찾고, 각 팀원이 개발한 프롬프팅 기법을 공유하여 학습할 수 있습니다.

## Chain of Thought (CoT) 모범 사례 (CoT Best practices)

Chain of Thought(생각의 흐름, 이하 CoT) 프롬프팅 기법은 모델의 추론 성능을 높이는 데 유용합니다. 아래는 CoT 프롬프팅을 위한 모범 사례입니다:

- **중간 추론 단계 명시**  
    모델에게 문제 해결 과정을 단계별로 서술하도록 명시적으로 요청하세요.  
    예: "단계별로 생각하면서 답하세요."
- **일관된 예시 제공**  
    몇 가지 일관된 추론 예시를 프롬프팅에 포함하면 모델이 일관된 추론 과정을 학습하여 정확도가 향상됩니다.
- **짧고 명료한 중간 단계 유지**  
    중간 추론 단계를 너무 길거나 복잡하지 않게 유지하세요. 각 단계는 간결하고 명확해야 합니다.

## 다양한 프롬프팅 시도 문서화하기 (Document the various prompt attempts)
프롬프팅 엔지니어링은 반복적인 과정입니다. 효과적인 프롬프팅을 찾기 위해 다양한 시도를 하는 과정에서, 각 프롬프팅의 결과를 체계적으로 문서화하는 것이 중요합니다. 다음과 같은 정보를 포함하여 문서화하세요:

- 프롬프트 내용과 목표
- 사용한 모델과 모델 구성(temperature, top-K 등)
- 출력 결과와 평가 결과
- 성공적이거나 실패한 이유에 대한 메모

이를 통해 시간이 지나도 쉽게 참고할 수 있으며, 팀원들과 협업할 때 프롬프팅 전략을 더욱 명확하게 공유할 수 있습니다.

계속해서 다음 부분의 번역을 진행합니다.

## 요약 (Summary)
프롬프팅 엔지니어링은 LLM이 정확하고 효율적인 출력을 생성할 수 있도록 최적의 입력 문장(프롬프트)을 설계하는 과정입니다. 이 문서에서 다룬 내용을 정리하면 다음과 같습니다.

- **프롬프팅 기본 개념 및 기술**
    - 일반 프롬프팅(zero-shot, one-shot, few-shot)
    - 시스템(system), 맥락(contextual), 역할(role) 프롬프팅
    - 단계별 사고(step-back), Chain of Thought(CoT), Self-consistency, Tree of Thoughts(ToT), ReAct(reason & act) 등 고급 프롬프팅 기법
- **코드 관련 프롬프팅**
    - 코드 작성, 설명, 번역, 디버깅 및 리뷰 프롬프팅 방법 소개
- **모범 사례**
    - 간결하고 명확한 프롬프트 설계하기
    - 구체적인 예시 제공하기
    - 긍정적 지시사항 중심으로 프롬프팅 작성하기
    - 출력 형식 명확히 지정하기
    - 프롬프트에 변수 활용하기
    - JSON 복구 및 스키마 활용하기
    - Chain of Thought(CoT) 모범 사례 활용
    - 프롬프팅 실험 과정을 철저히 문서화하기

프롬프팅 엔지니어링의 성공은 지속적인 반복과 실험에 달려있습니다. 다양한 방법을 실험하고, 최적의 결과를 얻기 위해 프롬프팅을 지속적으로 개선하고, 그 결과를 팀과 함께 공유하세요. 이를 통해 프롬프팅 전문가로 성장할 수 있습니다.