결론부터 말하면, **커밋(Commit) 페이즈를 최대한 빠르고 단순하게 만들기 위해서**입니다. 리액트는 모든 무거운 계산과 준비 작업을 중단 가능한 **렌더(Render) 페이즈**에서 미리 끝내놓는 전략을 사용합니다.
## ## `createElement`를 미리 호출하는 이유 💡

### 1. 커밋 페이즈의 속도와 단순성 확보

**커밋 페이즈**는 실제 DOM을 조작하여 화면에 변화를 보여주는 단계입니다. 이 단계는 사용자가 UI의 변경을 직접 목격하는 과정이므로, **절대로 중단되어서는 안 됩니다.** 만약 이 과정이 중단되면 화면이 깨져 보이거나(tearing) 데이터가 일치하지 않는 등 치명적인 문제가 발생합니다.

중단 없이 빠르게 실행되어야 하므로, 커밋 페이즈는 최대한 "단순하고 멍청하게(dumb)" 설계되어야 합니다.

- 만약 createElement를 커밋 페이즈에서 한다면?
    
    커밋 페이즈는 노드를 생성하고, 속성을 설정하고, 이벤트 리스너를 붙이고, 자식 노드를 붙이는 등 복잡하고 무거운 작업을 동기적으로 처리해야 합니다. 이는 커밋 시간을 길게 만들어 메인 스레드를 오래 차단하고, 앱의 반응성을 떨어뜨립니다.
    
- 리액트의 방식 (현재)
    
    createElement 호출, 속성(props) 계산 등 시간과 CPU를 소모하는 작업은 모두 렌더 페이즈에서 미리 해둡니다. 그 결과, 커밋 페이즈는 미리 만들어진 DOM 노드를 단순히 appendChild나 insertBefore로 붙이고, 미리 계산된 속성을 적용하는 가벼운 작업만을 수행하게 됩니다. 덕분에 커밋 페이즈는 매우 빠르게 실행될 수 있습니다.
    

### 2. 메모리상의 DOM 트리 구성에 대한 오해 바로잡기

"화면 밖에 DOM 트리를 구성한다"는 표현이 완전히 틀린 것은 아니지만, 흔히 생각하는 가상돔(Virtual DOM)처럼 완벽한 복사본 트리를 만드는 것과는 약간 다릅니다.

- 리액트는 **파이버 트리(Fiber tree)**라는 자바스크립트 객체 구조를 메인으로 사용합니다.
    
- 렌더 페이즈의 `completeWork` 단계에서 새로운 DOM 노드가 필요하면, `createElement`로 노드를 생성하고 이 노드를 해당 **파이버 객체의 `stateNode`라는 속성에 저장**해 둡니다.
    

즉, 메모리에 DOM 노드로만 이루어진 별개의 트리를 만드는 것이 아니라, **핵심 자료구조인 파이버 트리에 실제 DOM 노드를 "첨부"해두는 형태**입니다.

이렇게 하면 커밋 페이즈에서는 이펙트 리스트(effect list)를 순회하면서 `stateNode`에 이미 준비된 DOM 노드를 꺼내서 실제 DOM에 붙이기만 하면 되므로 매우 효율적입니다.

---

### ## IKEA 가구 조립 비유 IKEA 🛋️

이 과정을 이케아 가구 조립에 비유할 수 있습니다.

- 렌더 페이즈 (설명서 읽고 부품 준비하기):
    
    거실 바닥에 모든 부품을 펼쳐놓고 설명서를 읽는 단계입니다. 각 나사가 어느 구멍에 들어갈지 미리 확인하고(props 계산), 필요한 부품들을 조립 순서에 맞게 미리 모아둡니다(createElement 및 stateNode에 저장). 이 과정은 시간이 오래 걸리고, 중간에 전화가 오면 잠시 멈췄다가 다시 할 수 있습니다.
    
- 커밋 페이즈 (실제 조립하기):
    
    전동 드릴을 들고, 준비된 계획에 따라 망설임 없이 빠르게 조립만 하는 단계입니다. 어느 나사를 써야 할지 고민할 필요가 없습니다. 그냥 계획대로 나사를 조이고 판자를 붙이기만 하면 됩니다. 이 과정은 한번 시작하면 중간에 멈출 수 없습니다.
    

이처럼 리액트는 **'고민하는 시간(렌더)'**과 **'실행하는 시간(커밋)'**을 철저히 분리하여, 사용자에게 부드러운 UI 경험을 제공하는 것입니다.