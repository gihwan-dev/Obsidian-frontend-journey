- 웹 앱이 복잡해지면서 '실제 DOM'을 관리하는 일 역시 어려워짐. 실제 DOM 관리는 복잡하고 오류가 발생하기 쉬운 작업임.

## 가상 DOM 소개
- 가상 DOM은 실제 DOM을 설명하는 역할을 하는 JS 객체
- 리액트는 `setState` 또는 다른 메커니즘을 통해 UI를 변경하라고 지시할 때마다 가상 DOM을 먼저 업데이트 하고, 가상 DOM의 변경 사항에 맞춰 실제 DOM을 업데이트함. 이를 **재조정** 이라고 함
- 이 과정에서 어떤 알고리즘이 사용되고 최소한의 변경만 DOM에 반영할 수 있음

## 실제 DOM
- 브라우저는 HTML을 읽고 나면, 구문 분석을 통해 노드와 객체의 트리, 다시 말해 DOM이라 부르는 **객체 모델**로 변환
- 대충 아래의 형태를 가짐
```js
const dom = {
	type: "document",
	doctype: "html",
	children: [
		{
			type: "element",
			tagName: "html",
			children: [
				{
					type: "element",
					tagName: "head",
					children: [
						{
							type: "element",
							tagName: "title",
							children: "예시 페이지"
						}
					]
				}
			]
		}
	]
}
```

- 트리의 각 노드에는 다양한 속성과 메서드가 있음
- document.querySelector 메서드를 사용하면 `.heading` 같은 CSS 선택자를 인수로 받아 일치하는 첫 번째 엘리먼트를 반환함
- querySelector 메서드는 CSS 선택자를 기반으로해 복잡한 문서에서 속도가 느려짐
- 선택자의 복잡도에 따라 탐색 과정도 복잡해짐, 브라우저는 선택자 자체를 먼저 평가해야함
- `document.getElementById`는 유효성 검사가 필요 없고, `id` 속성이 고유할 것으로 예상되기 때문에 **특정성**이 높아 대부분 더 효율적임
- 최신 브라우저는 효율적인 ID -> 엘리먼트 매핑을 위해 해시 테이블 같은 해싱 메커니즘을 사용함. `getElementById`의 실행 시간 복잡도는 (O1)에 가까움
- 다만 ID가 고유하지 않아 해시가 충돌하는 경우 조회 시간이 길어지기도함. 브라우저는 ID의 고유성을 강제하지 않기에 충돌 발생 여지가 큼
- 이러한 CPU 효율성에 대해 걱정할 필요가 없다고 말하는 사람도 있음
- 그럼에도
	- 로직을 컴포넌트화 할 수 있다는것
	- DOM 처럼 변동성이 큰 환경에서 상태 관리에 대한 걱정을 덜 수 있다는 점
- 등의 가치는 의심할 여지가 없음
- 엘리먼트를 선택하는 방법상의 미세한 차이는 이렇게 있고, 이제부터는 DOM으로 직접 작업할 때의 문제점을 살펴보겠음

### 실제 DOM의 문제점
- 실제 DOM에는 고성능 웹 앱 개발을 어렵게 만드는 몇 가지 문제점이 있음
- 성능, 브라우저 간 호환성, 보안 취약성 등이 있음

#### 성능
- 실제 DOM 에서 가장 문제시되는 사안은 성능임
- 요소의 추가제거, 텍스트나 속성 업데이트 등으로 DOM이 변경될 때 마다 브라우저는 레이아웃을 다시 계산하고 영향 받는 부분을 다시 그림
- `DOM` 요소의 `offsetWidth` 속성을 읽는 것은 간단해 보이지만, 레이아웃을 다시 계산해야함
- `offsetWidth` 같은 레이아웃 속성에 접근할 때 발생하는 리플로는 몇 가지 방법으로 방지할 수 있음
	- `getBoundingClientRect()` 메서드를 사용해 레이아웃 읽기 및 쓰기를 일괄 처리하는 방법
- 리액트는 가상 DOM을 실제 DOM 작업 중간 계층으로 활용해 이러한 작업을 알아서 처리함
- 