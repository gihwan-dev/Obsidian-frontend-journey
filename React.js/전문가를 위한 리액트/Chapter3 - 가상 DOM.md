- 웹 앱이 복잡해지면서 '실제 DOM'을 관리하는 일 역시 어려워짐. 실제 DOM 관리는 복잡하고 오류가 발생하기 쉬운 작업임.

## 가상 DOM 소개
- 가상 DOM은 실제 DOM을 설명하는 역할을 하는 JS 객체
- 리액트는 `setState` 또는 다른 메커니즘을 통해 UI를 변경하라고 지시할 때마다 가상 DOM을 먼저 업데이트 하고, 가상 DOM의 변경 사항에 맞춰 실제 DOM을 업데이트함. 이를 **재조정** 이라고 함
- 이 과정에서 어떤 알고리즘이 사용되고 최소한의 변경만 DOM에 반영할 수 있음

## 실제 DOM
- 브라우저는 HTML을 읽고 나면, 구문 분석을 통해 노드와 객체의 트리, 다시 말해 DOM이라 부르는 **객체 모델**로 변환
- 대충 아래의 형태를 가짐
```js
const dom = {
	type: "document",
	doctype: "html",
	children: [
		{
			type: "element",
			tagName: "html",
			children: [
				{
					type: "element",
					tagName: "head",
					children: [
						{
							type: "element",
							tagName: "title",
							children: "예시 페이지"
						}
					]
				}
			]
		}
	]
}
```

- 트리의 각 노드에는 다양한 속성과 메서드가 있음
- document.querySelector 메서드를 사용하면 `.heading` 같은 CSS 선택자를 인수로 받아 일치하는 첫 번째 엘리먼트를 반환함
- querySelector 메서드는 CSS 선택자를 기반으로해 복잡한 문서에서 속도가 느려짐
- 선택자의 복잡도에 따라 탐색 과정도 복잡해짐, 브라우저는 선택자 자체를 먼저 평가해야함
- `document.getElementById`는 유효성 검사가 필요 없고, `id` 속성이 고유할 것으로 예상되기 때문에 **특정성**이 높아 대부분 더 효율적임
- 최신 브라우저는 효율적인 ID -> 엘리먼트 매핑을 위해 해시 테이블 같은 해싱 메커니즘을 사용함. `getElementById`의 실행 시간 복잡도는 (O1)에 가까움
- 다만 ID가 고유하지 않아 해시가 충돌하는 경우 조회 시간이 길어지기도함. 브라우저는 ID의 고유성을 강제하지 않기에 충돌 발생 여지가 큼
- 이러한 CPU 효율성에 대해 걱정할 필요가 없다고 말하는 사람도 있음
- 그럼에도
	- 로직을 컴포넌트화 할 수 있다는것
	- DOM 처럼 변동성이 큰 환경에서 상태 관리에 대한 걱정을 덜 수 있다는 점
- 등의 가치는 의심할 여지가 없음
- 엘리먼트를 선택하는 방법상의 미세한 차이는 이렇게 있고, 이제부터는 DOM으로 직접 작업할 때의 문제점을 살펴보겠음

### 실제 DOM의 문제점
- 실제 DOM에는 고성능 웹 앱 개발을 어렵게 만드는 몇 가지 문제점이 있음
- 성능, 브라우저 간 호환성, 보안 취약성 등이 있음

#### 성능
- 실제 DOM 에서 가장 문제시되는 사안은 성능임
- 요소의 추가제거, 텍스트나 속성 업데이트 등으로 DOM이 변경될 때 마다 브라우저는 레이아웃을 다시 계산하고 영향 받는 부분을 다시 그림
- `DOM` 요소의 `offsetWidth` 속성을 읽는 것은 간단해 보이지만, 레이아웃을 다시 계산해야함
- `offsetWidth` 같은 레이아웃 속성에 접근할 때 발생하는 리플로는 몇 가지 방법으로 방지할 수 있음
	- `getBoundingClientRect()` 메서드를 사용해 레이아웃 읽기 및 쓰기를 일괄 처리하는 방법
- 리액트는 가상 DOM을 실제 DOM 작업 중간 계층으로 활용해 이러한 작업을 알아서 처리함
- CSS 선택자 최적화, 이벤트 위임, 읽기/쓰기 DOM 작업 일괄 관리, CSS 애니메이션 사용 등의 기술이 있지만 복잡하고 구현이 어려움
- 가상 DOM은 실제 DOM의 복잡성을 추상화하고 가볍게 표현해 효율적이고 성능이 뛰어남
- 몇 밀리초 절약이 중요할까?
- 중요함. 구글 웹 개발 블로그에 있는 [**"밀리초가 수백만 달러를 만든다"**](https://web.dev/case-studies/milliseconds-make-millions)라는 훌륭한 글이 있음.
- 리액트의 효율적인 렌더링 알고리즘은 이러한 DOM 직접 조작에서 오는 CPU 효율성 문제를 해결해줌

#### 브라우저 간 호환성
- 브라우저마다 문서 모델링 방식이 다름
- 어떤 브라우저는 특정 DOM 요소와 속성을 지원하지 않기도 함
- 리액트의 합성 이벤트 시스템이 해결하고자 한 문제가 바로 그것임
- `SyntheticEvent`는 브라우저의 기본 이벤트를 둘러싼 래퍼 객체로, 여러 브라우저에서 일관성을 보장하기 위해 설계됨

##### 통합 인터페이스
- 자바스크립트에서는 브라우저 간 호환성 문제 때문에 이벤트 처리가 까다로움
- 이벤트 속성 접근 방법이 브라우저마다 달랐음. `event.target`을 사용하는 경우도 있고 `event.srcElement`를 사용하는 경우도 있음. `SyntheticEvent`는 이러한 차이를 추상화해 일관된 방법을 제공함

> 가끔 프론트엔드 개발자로서 왜 이런 부차적인 문제(브라우저 호환성)에도 집중 해야하지? 하는 고민을 한 적이 있음. 서버 개발을 하게 되면 결국 배포 환경에서만 잘 돌아가게 구현하면 되는데 프론트엔드는 아님. 애초에 브라우저가 통일성있게 잘 만들어졌다면 불필요할텐데. 새삼 이러한 문제를 해결한 리액트가 대단하게 보임. 웹 앱 개발 환경에 산재해 있던 수많은 문제를 해결한 프레임워크라는게 보이고, Class -> Function 시스템으로 전환 하는것과 같은 꾸준한 개선도 정말 대단하다는 생각이듬. 나는 참 편한 환경에서 개발하고 있다는 생각이 들어서, 리액트 이전의 개발자들이 참 대단하다는 생각이듬. 나는 사실 레거시 작업을 하지 않다보니, 보통 리액트나 Vue로 개발함. 그래서 항상 팀에 감사하기도 하고, 미안하기도함.

##### 이벤트 위임
- 리액트는 이벤트 리스너를 엘리먼트에 직접 추가하지 않고 루트에서 위임처리함. 이러한 접근 방식은 구형 브라우저의 특정 요소에서 일부 이벤트를 사용할 수 없는 문제를 방지함

##### 다양한 기능 개선
- 네이티브 브라우저 이벤트의 비일관성은 다양한 입력 요소의 특정 이벤트 처리 방식에서도 드러남. 자주 볼 수 있는 예로는 `onChange`가 있음
	- `onChnage` 이벤트 동작은 입력 컴포넌트 종류에 따라 다름
		- `<input type="text">`는 일부 브라우저에서 `onChange` 이벤트가 값이 변경되는 즉시 발생하지 않고, 입력이 포커스를 잃은 경우에만 발생
		- `<select`의 경우, 브라우저에 따라 현재 선택된 옵션을 다시 선택할 때 이벤트가 발생하기도 함
		- 구형 브라우저에서 특정 폼 요소의 모든 사용자 상호 작용에서 `onChange` 이벤트가 발생하지 않는 경우도 있음
	- 리액트의 `SyntheticEvent` 시스템은 이러한 입력 요소 전체에서 `onChange` 이벤트의 동작을 정규화함
		- `<input type="text">`의 `onChange` 이벤트는 키를 입력할 때마다 발생함
		- `<select>` 에서는 선택한 값이 아닌 옵셔을 선택할 때마다 발생함
	- 이처럼 리액트를 사용하면 브라우저의 비일관성을 직접 처리하지 않아도 됨

##### 네이티브 이벤트에 접근
- `event.nativeEvent`를 통해 네이티브 이벤트에 접근할 수 있음. 필요에 따라 추상화의 이점을 그대로 취하면서 필요에 따라 유연하게 사용할 수도 있음


### 문서 조각
- DOM을 직접 조작하는 작업은 성능이 많이 필요함
- DOM이 업데이트 될 때 마다 아래 작업을 수행할 수 있음
	- 레이아웃 재계산
	- UI 리페인팅
	- 화면 업데이트
- 이때 문서 조각이 중요함
- **문서 조각**은 DOM 노드를 저장하는 가벼운 컨테이너로, 기본 DOM에 영향을 주지 않고 여러 가지 업데이트를 수행할 수 있는 임시 저장소처럼 동작
- 업데이트 작업이 완료되면 문서 조각을 DOM에 추가하는 방식으로 리플로와 리페인팅을 한 번만 발생시킴
- 가상 DOM과 매우 유사하게 동작하며 여러 가지 성능 이점이 있음
	- **일괄 업데이트**: 문서의 실제 DOM을 여러 번 개별적으로 업데이트 하지않고 일괄적으로 업데이트
	- **메모리 효율성**: 문서 조각에 추가된 노드는 실제 DOM에서 제거됨
	- **중복 렌더링 방지**: 문서 조각을 변경해도 실제 문서에는 영향을 주지 않으며, 실제 DOM에 추가될 때 까지 스타일과 스크립트가 적용되지 않음
- 아래의 예제에서 실제 DOM은 100번이 아니라 단 한 번 업데이트됨:
	```js
	const fragment = document.createDocumentFragment();
	for (let i = 0; i < 100; i++) {
		const li = document.createElement("li");
		li.textContent = `목록 항목 ${i + 1}`;
		fragment.appendChild(li);
	}
	document.getElementById("myList").appendChild(fragment);
	```

- 리액트의 가상 DOM은 문서 조각 개념을 더 나은 방식으로 구현한 것
- 리액트의 가상 DOM과 문서 조각의 유사점은 아래와 같음:
	- **일괄 업데이트**: 가상 DOM은 여러 변경 사항을 한꺼번에 일괄 처리함
	- **효율적인 비교 알고리즘**: 가상 DOM과 실제 DOM의 차이점을 비교해서 필요한 변경만 발생시킴
	- **단일 렌더링**: 차이점이 식별되면 단 한 번의 일괄 처리를 통해 실제 DOM을 업데이트함

## 가상 DOM 작동 방식
- 가상 DOM은 실제 DOM의 문제점을 완화하는 유용한 기술
- 가상 DOM을 메모리에 만들고 실제 DOM 직접 수정하지 않고 가상 표현을 변경해 요휼적으로 실제 DOM을 업데이트
- 가상 DOM은 브라우저마다 다양한 실제 DOM 구현의 차이를 추상화한 일관된 API를 제공해 엘리먼트를 작성하고 업데이트하는 환경을 개선함

### 리액트 엘리먼트
- 리액트에서 UI는 컴포넌트 또는 리액트 엘리먼트 트리 형태로 표현
- 리액트 엘리먼트는 `React.createElement` 함수를 사용해 생성
```jsx
const element = React.createElement(
	"div",
	{ className: "my-class" },
	"Hello, world!"
);
```

- 여기에 `console.log(element)`를 사용하면 아래와 같은 결과를 볼 수 있음
```ts
{
	$$typeof: Symbol(react.element),
	type: "div",
	key: null,
	ref: null,
	props: {
		className: "my-class",
		children: "Hello, world!"
	},
	_owner: null,
	_store: {}
}
```

- 리액트 엘리먼트는 가장 작은 구성 블록으로 화면에 표현될 내용을 설명하는 자바스크립트 객체

#### `$$typeof`
- 객체가 유효한 리액트 엘리먼트인지 확인할 때 사용하는 특수한 심벌(symbol)
- 위 예제에서는 `Symbol(react.element)`로 설정
- `$$typeof`는 엘리먼트 종류에 따라 값이 다를 수 있음
	- `Symbol(react.fragment)`: 리액트 Fragment를 나타내는 경우
	- `Symbol(react.portal)`: 리액트 포털을 나타내는 경우
	- `Symbol(react.profiler)`: 리액트 프로파일러를 나타내는 경우
	- `Symbol(react.provider)`: 리액트 컨텍스트 제공자를 나타내는 경우
- 일반적으로 `$$typeof`는 리액트 엘리먼트의 종류를 식별하는 표시자 역할을 함

#### `type`
- ype 속성은 엘리먼트가 나타내는 컴포넌트의 종류를 알려줌
- 위 예시에서는 "div"인데 이는 `<div>` DOM 엘리먼트라는 의미
- 이런 DOM 엘리먼트는 "호스트 컴포넌트"라고 부르기도 함
- 리액트 엘리먼트의 `type`은 문자열이거나 함수
- 문자열인 경우에는 "div", "span", "button" 같은 HTML 태그 이름을 나타냄
- 함수인 경우 사용자 정의 리액트 컴포넌트, 즉 JSX를 반환하는 자바스크립트 함수가 됨
- 아래는 리액트 엘리먼트 종류가 사용자 정의 컴포넌트인 경우의 예시
```jsx
const MyComponent = (props) => {
	return <div>{props.text}</div>;
};

const myElement = <MyComponent text="Hello, world!" />;
```

- `myElement`는 아래처럼 표현됨
```ts
{
	$$typeof: Symbol(react.element),
	type: MyComponent,
	key: null,
	ref: null,
	props: {
		text: "Hello, world!"
	},
	_owner: null,
	_store: {}
}
```

- 리액트는 함수 타입인 엘리먼트를 만나면 엘리먼트의 `props`를 전달하며 해당 함수를 호출
- 사용자 정의 리액트 컴포넌트가 렌더링 되는 방식:
	- 스칼라 값(숫자, 문자열, 불리언 처럼 더 이상 분해되지 않는 단 하나의 단일 값)을 만나면 텍스트 노드로 렌더링
	- `null` 또는 `undefined`를 만나면 아무것도 렌더링하지 않음

#### `ref`
- 부모 컴포넌트는 이 속성을 사용해 기본 DOM 노드에 대한 참조를 요청

#### `props`
- 컴포넌트에 전달되는 모든 속성과 props를 포함하는 객체

#### `_owner`
- 프로덕션 빌드가 아닐 때만 접근할 수 있는 속성
- 엘리먼트를 생성한 컴포넌트를 추적하기 위해 리액트 내부적으로 사용
- 프롬이나 상태가 변경될 때 엘리먼트의 업데이트를 담당할 컴포넌트를 결정하는 데 사용
- 아래는 `_owner` 속성이 어떻게 사용되는지 보여주는 예시:
```tsx
function Parent() {
	return <Child />;
}

function Child() {
	const element = <div>Hello, world!</div>;
	console.log(element._owner); // Parent
	return element;
}
```

- 리액트는 이 정보를 사용해 프롭이나 상태가 변경될 때 엘리먼트의 업데이트를 담당할 컴포넌트를 결정
- `_owner` 속성은 리액트가 내부적으로 구현을 위해서만 사용하는 값이므로, 애플리케이션 코드에서 사용하면 안됨

> [!Note] `_owner`가 프로덕션 빌드에서 존재하지 않는 이유
> `_owner` 속성은 **디버깅과 경고 메시지**를 위해 존재하며, 리액트가 컴포넌트 트리를 추적하고 개발자에게 유용한 정보를 제공하는데 도움을 줌. 프로덕션 빌드에서는 `_owner` 속성 자체가 **존재하지 않음**.

#### `_store`
- 엘리먼트에 대한 추가 데이터를 저장하기 위해 리액트가 내부적으로 사용하는 객체
- `_store`에 저장된 특정 속성 및 값은 공개 API의 일부가 아니므로 직접 접근해선느 안됨
- 아래는 `_store` 속성의 예시:
```ts
{
	validation: null,
	key: null,
	originalProps: { className: "my-class", children: "Hello, world!" },
	props: { className: "my-class", children: "Hello, world!" },
	_self: nul,
	_source: { fileName: "MyComponent.js", lineNumber: 10 },
	_owner: {
		_currentElement: [Circular], _debugID: 0, stateNode: [MyComponent]
	},
	_isStatic: false,
	_warnedAboutRefsInRender: false,
}
```

- 위 속성들은 리액트가 내부적으로 엘리먼트의 상태와 컨텍스트의 다양한 측면을 추적할 때 사용됨
- 개발 모드에서 `_source`는 엘리먼트가 생성된 파일 이름과 줄 번호를 추적하는데 사용되어 디버깅에 유용함

### 가상 DOM과 실제 DOM 비교
- `React.createElement`는 리액트 엘리먼트를 생성하며 `document.createElement`는 DOM 노드를 생성함
- 리액트 컴포넌트가 렌더링되면 리액트는 새 가상 DOM 트리를 생성하고 이전 가상 DOM 트리와 비교한 다음, 이전 트리를 새 트리와 일치하도록 업데이트하는 데 필요한 최소 변경 횟수를 계산
- 이를 **재조정 프로세스** 라고 함

### 효율적인 업데이트
- 리액트 컴포넌트의 상태나 프롭이 변경되면 리액트는 새로운 리엑트 엘리먼트 트리를 생성
- 비교 알고리즘을 사용해 새 트리를 이전 트리와 비교해 실제 DOM의 업데이트에 필요한 최소한의 변경 사항을 결정
- 이때 비교는 재귀적으로 발생
- 노드가 변경된 경우 실제 DOM에서 수정, 추가 혹은 제거된 경우 실제 DOM에서 해당 노드를 추가 혹은 제거
- 새 트리와 이전 트리를 노드별로 비교해 어느 부분이 변경되었는지 식별하는 작업을 **디핑(diffing)** 이라 하며, 이때 사용되는 알고리즘을 **디핑(Diffing) 알고리즘** 이라고합
- **Diffing 알고리즘** 은 고도로 최적화 되어있으며, 실제 DOM 변경 횟수 최소화를 목표로함
	- 두 트리의 루트에 있는 노드가 다른 경우, 기존 트리를 전체 새 트리로 대체
	- 루트 노드가 동일하다면 리액트는 노드의 속성이 변경된 경우에만 업데이트
	- 자식 노드가 다른 경우 변경된 자식 노드만 업데이트. 하위 트리 전체를 다시 생성하지 않고 변경된 노드만 업데이트
	- 자식들이 동일하지만 순서가 변경된 경우, 노드를 다시 생성하지 않고 실제 DOM에서 노드의 순서를 다시 설정
	- 트리에서 노드가 제거되면 실제 DOM에서 노드를 제거
	- 새 노드가 추가되면 해당 노드를 실제 DOM에 추가
	- 노드의 종류가 변경된 경우(div -> span) 이전 노드를 제거하고 변경된 종류의 새 노드를 생성
	- key 프롭이 있다면 이를 사용해 노드의 교체가 필요한지 파악

#### 불필요한 리렌더링
- 리렌더링은 애초에 리액트가 설계된 대로 작동하는 방식
- 