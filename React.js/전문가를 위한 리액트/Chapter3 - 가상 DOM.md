- 웹 앱이 복잡해지면서 '실제 DOM'을 관리하는 일 역시 어려워짐. 실제 DOM 관리는 복잡하고 오류가 발생하기 쉬운 작업임.

## 가상 DOM 소개
- 가상 DOM은 실제 DOM을 설명하는 역할을 하는 JS 객체
- 리액트는 `setState` 또는 다른 메커니즘을 통해 UI를 변경하라고 지시할 때마다 가상 DOM을 먼저 업데이트 하고, 가상 DOM의 변경 사항에 맞춰 실제 DOM을 업데이트함. 이를 **재조정** 이라고 함
- 이 과정에서 어떤 알고리즘이 사용되고 최소한의 변경만 DOM에 반영할 수 있음

## 실제 DOM
- 브라우저는 HTML을 읽고 나면, 구문 분석을 통해 노드와 객체의 트리, 다시 말해 DOM이라 부르는 **객체 모델**로 변환
- 대충 아래의 형태를 가짐
```js
const dom = {
	type: "document",
	doctype: "html",
	children: [
		{
			type: "element",
			tagName: "html",
			children: [
				{
					type: "element",
					tagName: "head",
					children: [
						{
							type: "element",
							tagName: "title",
							children: "예시 페이지"
						}
					]
				}
			]
		}
	]
}
```

- 트리의 각 노드에는 다양한 속성과 메서드가 있음
- document.querySelector 메서드를 사용하면 `.heading` 같은 CSS 선택자를 인수로 받아 일치하는 첫 번째 엘리먼트를 반환함
- querySelector 메서드는 CSS 선택자를 기반으로해 복잡한 문서에서 속도가 느려짐
- 선택자의 복잡도에 따라 탐색 과정도 복잡해짐, 브라우저는 선택자 자체를 먼저 평가해야함
- `document.getElementById`는 유효성 검사가 필요 없고, `id` 속성이 고유할 것으로 예상되기 때문에 **특정성**이 높아 대부분 더 효율적임
- 최신 브라우저는 효율적인 ID -> 엘리먼트 매핑을 위해 해시 테이블 같은 해싱 메커니즘을 사용함. `getElementById`의 실행 시간 복잡도는 (O1)에 가까움
- 다만 ID가 고유하지 않아 해시가 충돌하는 경우 조회 시간이 길어지기도함. 브라우저는 ID의 고유성을 강제하지 않기에 충돌 발생 여지가 큼
- 이러한 CPU 효율성에 대해 걱정할 필요가 없다고 말하는 사람도 있음
- 그럼에도
	- 로직을 컴포넌트화 할 수 있다는것
	- DOM 처럼 변동성이 큰 환경에서 상태 관리에 대한 걱정을 덜 수 있다는 점
- 등의 가치는 의심할 여지가 없음
- 엘리먼트를 선택하는 방법상의 미세한 차이는 이렇게 있고, 이제부터는 DOM으로 직접 작업할 때의 문제점을 살펴보겠음

### 실제 DOM의 문제점
- 실제 DOM에는 고성능 웹 앱 개발을 어렵게 만드는 몇 가지 문제점이 있음
- 성능, 브라우저 간 호환성, 보안 취약성 등이 있음

#### 성능
- 실제 DOM 에서 가장 문제시되는 사안은 성능임
- 요소의 추가제거, 텍스트나 속성 업데이트 등으로 DOM이 변경될 때 마다 브라우저는 레이아웃을 다시 계산하고 영향 받는 부분을 다시 그림
- `DOM` 요소의 `offsetWidth` 속성을 읽는 것은 간단해 보이지만, 레이아웃을 다시 계산해야함
- `offsetWidth` 같은 레이아웃 속성에 접근할 때 발생하는 리플로는 몇 가지 방법으로 방지할 수 있음
	- `getBoundingClientRect()` 메서드를 사용해 레이아웃 읽기 및 쓰기를 일괄 처리하는 방법
- 리액트는 가상 DOM을 실제 DOM 작업 중간 계층으로 활용해 이러한 작업을 알아서 처리함
- CSS 선택자 최적화, 이벤트 위임, 읽기/쓰기 DOM 작업 일괄 관리, CSS 애니메이션 사용 등의 기술이 있지만 복잡하고 구현이 어려움
- 가상 DOM은 실제 DOM의 복잡성을 추상화하고 가볍게 표현해 효율적이고 성능이 뛰어남
- 몇 밀리초 절약이 중요할까?
- 중요함. 구글 웹 개발 블로그에 있는 [**"밀리초가 수백만 달러를 만든다"**](https://web.dev/case-studies/milliseconds-make-millions)라는 훌륭한 글이 있음.
- 리액트의 효율적인 렌더링 알고리즘은 이러한 DOM 직접 조작에서 오는 CPU 효율성 문제를 해결해줌

#### 브라우저 간 호환성
- 브라우저마다 문서 모델링 방식이 다름
- 어떤 브라우저는 특정 DOM 요소와 속성을 지원하지 않기도 함
- 리액트의 합성 이벤트 시스템이 해결하고자 한 문제가 바로 그것임
- `SyntheticEvent`는 브라우저의 기본 이벤트를 둘러싼 래퍼 객체로, 여러 브라우저에서 일관성을 보장하기 위해 설계됨

##### 통합 인터페이스
- 자바스크립트에서는 브라우저 간 호환성 문제 때문에 이벤트 처리가 까다로움
- 이벤트 속성 접근 방법이 브라우저마다 달랐음. `event.target`을 사용하는 경우도 있고 `event.srcElement`를 사용하는 경우도 있음. `SyntheticEvent`는 이러한 차이를 추상화해 일관된 방법을 제공함

> 가끔 프론트엔드 개발자로서 왜 이런 부차적인 문제(브라우저 호환성)에도 집중 해야하지? 하는 고민을 한 적이 있음. 서버 개발을 하게 되면 결국 배포 환경에서만 잘 돌아가게 구현하면 되는데 프론트엔드는 아님. 애초에 브라우저가 통일성있게 잘 만들어졌다면 불필요할텐데. 새삼 이러한 문제를 해결한 리액트가 대단하게 보임. 웹 앱 개발 환경에 산재해 있던 수많은 문제를 해결한 프레임워크라는게 보이고, Class -> Function 시스템으로 전환 하는것과 같은 꾸준한 개선도 정말 대단하다는 생각이듬. 나는 참 편한 환경에서 개발하고 있다는 생각이 들어서, 리액트 이전의 개발자들이 참 대단하다는 생각이듬. 나는 사실 레거시 작업을 하지 않다보니, 보통 리액트나 Vue로 개발함. 그래서 항상 팀에 감사하기도 하고, 미안하기도함.

##### 이벤트 위임
- 리액트는 이벤트 리스너를 엘리먼트에 직접 추가하지 않고 루트에서 위임처리함. 이러한 접근 방식은 구형 브라우저의 특정 요소에서 일부 이벤트를 사용할 수 없는 문제를 방지함

##### 다양한 기능 개선
- 네이티브 브라우저 이벤트의 비일관성은 다양한 입력 요소의 특정 이벤트 처리 방식에서도 드러남. 자주 볼 수 있는 예로는 `onChange`가 있음
	- `onChnage` 이벤트 동작은 입력 컴포넌트 종류에 따라 다름
		- `<input type="text">`는 일부 브라우저에서 `onChange` 이벤트가 값이 변경되는 즉시 발생하지 않고, 입력이 포커스를 잃은 경우에만 발생
		- `<select`의 경우, 브라우저에 따라 현재 선택된 옵션을 다시 선택할 때 이벤트가 발생하기도 함
		- 구형 브라우저에서 특정 폼 요소의 모든 사용자 상호 작용에서 `onChange` 이벤트가 발생하지 않는 경우도 있음
	- 리액트의 `SyntheticEvent` 시스템은 이러한 입력 요소 전체에서 `onChange` 이벤트의 동작을 정규화함
		- `<input type="text">`의 `onChange` 이벤트는 키를 입력할 때마다 발생함
		- `<select>` 에서는 선택한 값이 아닌 옵셔을 선택할 때마다 발생함
	- 이처럼 리액트를 사용하면 브라우저의 비일관성을 직접 처리하지 않아도 됨

##### 네이티브 이벤트에 접근
- `event.nativeEvent`를 통해 네이티브 이벤트에 접근할 수 있음. 필요에 따라 추상화의 이점을 그대로 취하면서 필요에 따라 유연하게 사용할 수도 있음


