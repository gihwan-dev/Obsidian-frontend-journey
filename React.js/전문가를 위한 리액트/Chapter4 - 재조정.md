- 지금까지는 우리가 어느정도 알고 있는 `React.createElement`를 배웠음
- 이 장에서는 리액트에서 가상 DOM을 실제로 적용하는 방법을 알아보고 `ReactDOM.createRoot(element).render()`의 동작을 배움

## 재조정 이해하기
- 가상 DOM은 우리가 원하는 UI의 청사진
- 리액트는 이 청사진을 가지고 **재조정(reconciliation)** 이라는 프로세스를 통해 주어진 환경에서 현실로 만듬

```jsx
import { useState } from "react";

const App = () => {
	const [count, setCount] = useState(0);
	
	return (
		<main>
			<div>
				<h1>안녕하세요!</h1>
				<span>카운트: {count}</span>
				<button onClick={() => setCount(count + 1)}>증가</button>
			</div>
		</main>
	);
};
```

- 재조정 과정을 이해하기 위해 위 컴포넌트를 만났을 때 내부적으로 어떻게 처리하는지 알아봄
- JSX는 리액트 엘리먼트의 트리가됨
- App 컴포넌트는 함수로 호출되면 자손 4개를 포함한 리액트 엘리먼트를 반환함

```js
const App = () => {
	const [count, setCount] = useState(0);
	
	return React.createElement(
		"main",
		null,
		React.createElement(
			"div",
			null,
			React.createElement("h1", null "안녕하세요!"),
			React.createElement("span", null, "카운트: ", count),
			React.createElement(
				"button",
				{ onClick: () => setCount(count + 1) },
				"증가"
			)
		)
	);
};
```

- App이 호출되어 생성된 리액트 엘리먼트 트리는 다음같이 표시됨

```jsx
{
	type: "main",
	props: {
		children: { // main은 div라는 단 하나의 자식을 가지므로, children은 배열이 아닌 객체
			type: "div",
			props: {
				children: [
					{
						type: "h1",
						props: {
							children: "안녕하세요!"
						}
					},
					{
						type: "span",
						props: {
							children: ["카운트: ", count]
						}
					},
					{
						type: "button",
						props: {
							onClick: () => setCount(count + 1),
							children: "증가"
						}
					}
				]
			}
		}
	}
}
```

> [!Note] 정리
> 1. **트랜스파일 (Transpilation):** 개발자가 작성한 첫 번째 코드 블록의 JSX 문법(`<main>...</main>`)은 브라우저가 직접 이해할 수 없습니다. 따라서 빌드 과정에서 바벨(Babel)과 같은 트랜스파일러를 통해 이 JSX는 두 번째 코드 블록처럼 `React.createElement(...)` 함수를 호출하는 형태의 자바스크립트 코드로 변환됩니다.
>     
> 2. **컴포넌트 호출 (Execution):** 리액트가 애플리케이션을 렌더링하기 위해 `App` 컴포넌트(함수)를 호출합니다.
>     
> 3. **가상 DOM 생성 (Virtual DOM Creation):** `App` 함수가 실행되면, 그 내부에 있는 트랜스파일된 `React.createElement` 호출들이 실행됩니다. 이 실행 결과로 마지막 코드 블록에 나타난 JSON 형태의 자바스크립트 객체 트리(리액트 엘리먼트 트리, 즉 가상 DOM)가 생성되어 반환됩니다.
>     
> 
> 결론적으로, 말씀하신 대로 JSX는 `React.createElement`를 호출하는 함수로 변경되고, `App`이 호출되면 그 아래의 JSON 형태의 구조를 그리게(생성하게) 됩니다. 이 객체 트리가 바로 UI의 "청사진"입니다.

- 위 JSON은 `Counter` 컴포넌트에서 반환하는 가상 DOM을 나타냄
- 첫 번재 렌더링이기에 이 트리는 최소한의 DOM API 호출을 통해 브라우저에 반영됨
- 필요한 DOM API 호출 최소화 하는 방법은 어떻게 될까? => 일괄 처리(배치 처리)에 있음

## 일괄 처리
- 문서 조각은 다수의 DOM 노드를 포함하는 가벼운 컨테이너로, 일종의 임시 스테이징 영역처럼 동작해서 문서의 실제 DOM에 영향을 주지 않고 여러 변경 사항을 반영한다. 최종적으로 문서 조각을 DOM에 추가하면 단 한 번의 리플로와 리페인팅이 발생한다.
- 비슷한 맥락에서 리액트는 여러 가상 DOM 업데이트를 모아 한 번의 DOM 업데이트로 결합한 후 실제 DOM에 대한 업데이트를 일괄 처리함
- 현대 리액트 내부 동작을 보기 전에, 16 미만 버전에서 사용되는 '스택(stack)' 재조정자의 동작 방식을 소개할 예정. 이를 통해 현대의 '파이버(fiber)' 재조정자의 필요성을 이해할 수 있음

> [!Note] 노트
>지금부터 논의할 모든 주제는 시간이 지나면 변경될 수도 있는 리액트 내부 구현의 세부 사항임


## 기존 기술
- 이전 리액트는 렌더링에 스택 데이터 구조를 사용

### 스택 재조정자
- 이전 리액트 재조정자는 스택 기반 알고리즘을 사용해 새 가상 트리를 이전 가상 트리와 비교하고 그에 따라 DOM을 업데이트
- 간단한 경우 잘 동작하지만 규모가 커지고 복잡해지면 여러 문제가 발생함
- 예를들어, 특정 컴포넌트의 렌더링 비용이 비싼 경우 비싼 컴포넌트가 렌더링을 막아버림. 계산 비용이 비싼 컴포넌트의 렌더링이 만약 그리 중요하지 않다면, 상대적으로 더 중요할 수 있는 사용자 입력을 막기도함
- 만약 이 렌더링과, 사용자 상호작용 사이에 우선순위를 적용해 사용자 입력을 우선 반영하고, 비싼 컴포넌트의 렌더링을 후순위로 처리할 수 있다면 사용자 경험이 올라갈것임
- 스택 재조정자는 업데이트의 우선순위를 설정하지 않음. 그래서 덜 중요한 업데이트가 더 중요한 업데이트를 방해할 수 있었음
- 리액트 앱에서 가상 트리에 대한 업데이트는 중요도가 각기 다를 수 있음
- 이러한 점을 해결하기 위해 리액트 팀은 파이버 트리라는 데이터 구조를 기반으로 하는 파이버 재조정자를 개발함

## 파이버 재조정자
- 파이버 재조정자에는 조정자를 위한 작업 단위를 나타내는 '파이버'라는 데이터 구조가 사용됨
- 파이버는 리액트 엘리먼트에서 생성됨
- 핵심적인 차이점은 파이버는 상태를 저장하고 수명이 긴 반면 리액트 일리먼트는 임시적이고 상태가 없다는 것
- 유명한 리액트 전문가이자 리덕스의 메인테이너인 마크 에릭슨은 파이버를 '특정 시점에 존재하는 실제 컴포넌트 트리를 나타내는 리액트의 내부 데이터 구조'라고 설명
- 리액트는 재조정에 파이버 트리를 사용함. 가상 DOM이 엘리먼트의 트리를 표현하는 것과 비슷함

### 데이터 구조로서의 파이버
- 파이버 재조정자는 업데이트 우선순위를 정하고 동시 실행을 가능케해 성능과 응답성을 향상시킴
- 본질적으로 파이버 데이터 구조는 리액트 앱에서 컴포넌트 인스턴스와 그 상태를 표현
- 파이버 데이터 구조는 변경 가능한 인스턴스로 설계되어 조정 과정에서 필요에 따라 업데이트되고 재배치됨
- 파이버 노드의 각 인스턴스에는 해당 컴포넌트에 대한 정보인 프롭, 상태, 하위 컴포넌트 뿐만 아니라, 컴포넌트 트리에서의 위치 정보, 파이버 재조정자가 업데이트 우선순위를 정하고 실행하는 데 사용하는 메타데이터 등이 들어있음
```js
{
	tag: 3, // 3 = ClassComponent
	type: App,
	key: null,
	ref: null,
	props: {
		name: "Tejas",
		age: 30
	},
	stateNode: AppInstnace,
	return: FiberParent,
	child: FiberChild,
	sibling: FiberSibling,
	index: 0,
	// ...
}
```

- 예시의 파이버 노드는 `ClassComponent` 라는 `App`을 나타냄
- 파이버 노드에는 다음과 같은 컴포넌트에 대한 정보가 들어있음
	- `tag`: 각 컴포넌트 유형(클래스, 함수, Suspense/Error Boundary, Fragment)에는 고유한 숫자 ID가 파이버로 설정됨
	- `type`: `App`은 파이버가 나타내는 함수 또는 클래스 컴포넌트를 나타냄
	- `props`: `{name: "Tejas", age: 30}`는 컴포넌트에 대한 입력 프롭 또는 함수에 대한 입력 인수를 나타냄
	- `stateNode`: 이 파이버가 나타내는 `App` 컴포넌트의 인스턴스. 컴포넌트 트리에서의 위치는 `return`, `child`, `sibling`, `index`로 표현되는데 각각 부모, 자녀, 형제, 파이버의 색인을 의미하며 파이버 재조정자는 이를 사용해 트리를 순회
- 파이버 재조정에는 현재 파이버 트리와 다음 파이버 트리를 비교해 어느 노드를 업데이트, 추가, 제거할지 파악하는 작업이 포함됨
- 조정 과정 중에 파이버 재조정자는 가상 DOM의 각 리액트 엘리먼트에 대해 파이버 노드를 생성함. 이는 `createFiberFromTypeAndProps` 라는 함수가 실행함. 이 함수에서 말하는 `TypeAndProps`는 다른 말로 리액트 엘리먼트라고도 부를 수 있음. 이유는 리액트 엘리먼트는 아래처럼 구성되기 때문.
```js
{
	type: "div",
	props: {
		className: "container"
	}
}
```

- `createFiberFromTypeAndProps` 함수는 엘리먼트에서 파생된 파이버를 반환함. 파이버 노드가 생성되면 재조정자는 **작업 루프(work loop)**를 사용해 사용자 인터페이스를 업데이트
- 작업 루프는 루트 파이버 노드에서 시작해 컴포넌트 트리를 따라 내려가며 업데이트가 필요한 경우 각 파이버 노드를 '더티'로 표시
- 끝에 도달하면 다시 반대로 순회하며 브라우저의 DOM 트리와 분리된 새 DOM 트리를 메모리에 생성함. 새 DOM 트리는 이후 화면에 반영됨
- 이 "반영되는 것"을 다른 말로 "내보내진다(flushed)" 라고도 함
- 이 작업을 두 가지 함수로 표현할 수 있음
	- `beginWork(작업 시작)`: 위에서 아래로 이동하며 컴포넌트를 '업데이트가 필요함'으로 표시
	- `completeWork(작업 완료)`: 다시 위로 이동하며 브라우저에서 분리된 실제 DOM 엘리먼트의 트리를 메모리에 구성
- 이러한 오프스크린 렌더링 프로세스(off-screen rendering process)는 사용자가 볼 수 없기에 언제든지 중단하고 버릴 수 있음
- 파이버 아키텍처는 다음 화면을 화면 밖에서 준비한 다음 현재 화면으로 내보내는 '더블 버퍼링'이라는 게임 엽계의 개념에서 착안함

### 더블 버퍼링
- 더블 버퍼링은 컴퓨터 그래픽 및 비디오 처리에서 깜박임을 줄이고 체감 성능을 개선하는 기술
- 이미지나 프레임을 저장하기 위한 두 개의 버퍼(또는 메모리 공간)를 생성하고 일정한 간격으로 두 버퍼를 전환해 최종 이미지나 동영상을 표시함
	- 첫 번째 버퍼가 초기 이미지나 프레임으로 채워짐
	- 첫 번째 버퍼가 표시되는 동안 두 번째 버퍼가 새 데이터나 이미지로 업데이트됨
	- 두 번째 버퍼가 준비되면 첫 번째 버퍼로 전환되어 화면에 표시됨
	- 첫 번재와 두 번째 버퍼가 일정한 간격으로 전환되어 최종 이미지나 동영상을 표시하는 프로세스가 계속됨
- 더블 버퍼링을 사용하면 최종 이미지나 동영상이 중단이나 지연 없이 표시되어 깜박임 및 기타 시각적 잔상이 줄어듬
- 파이버 재조정은 더블 버퍼링과 유사함
	- 업데이트가 발생하면 현재 파이버 트리가 포크(fork)되어 주어진 사용자 인터페이스의 새로운 상태를 반영하도록 업데이트됨. 이를 **렌더링**이라고 함
	- 이후 현재 트리를 대체할 트리가 준비되고 사용자가 기대하는 상태를 정확하게 반영하면, 현재 파이버 트리와 교체됨. 이를 **커밋 단계** 또는 **커밋** 이라고 함
- 이러한 화면에 표시되지 않는 **작업용 트리**를 사용하면 여러 장점이 있음
	- 실제 DOM에 대한 불필요한 업데이트를 피할 수 있어 성능을 개선하고 깜박임을 줄임
	- 화면 밖에서 UI의 새 상태를 계산하고 우선순위가 더 높은 새로운 업데이트가 필요한 경우 이를 버릴 수 있음
	- 재조정은 화면 밖에서 이루어지므로 사용자가 현재 보고 있는 내용을 망치지 않고 일시 중지했다가 다시 시작할 수도 있음
- 파이버 재조정자를 사용하면 JSX 엘리먼트의 사용자 정의 트리에서 두 가지 트리가 만들어짐. "현재" 파이버를 포함하는 트리와 "작업용"파이버를 포함하는 트리임

### 파이버 재조정
- 파이버 재조정은 렌더링 단계와 커밋 단계로 이루어짐
- 리액트 스케줄러는 5 밀리초마다 실행을 메인 스레드로 돌려줌(5밀리초는 120프레임을 표현하는 기기에서의 1프레임보다 짧은 시간)

![[Pasted image 20250916071351.png]]

#### 렌더링 단계
- **렌더링 단계**는 현재 트리에서 상태 변경 이벤트가 발생하면 시작됨
- 리액트는 각 파이버를 재귀적, 단계적으로 순회하고 업데이트가 보류 중이라는 신호 플래그를 설정해 대체 트리에 **오프스크린** 변경 작업을 수행함. 이는 `beginWork`라는 함수에서 발생함

![[Pasted image 20250916071915.png]]

#### `beginWork(작업 시작)`
- `beginWork`는 작업용 트리에 있는 파이버 노드의 업데이트 필요 여부를 나타내는 플래그를 설정함
- 여려 플래그를 설정하고 다음 파이버 노드로 이동하며 트리의 맨 아래에 도달할 때까지 동일한 작업을 수행함
- 작업이 완료되면 파이버 노드에서 `completeWork`를 호출하고 다시 거슬러 올라가며 순회
- `beginWork`의 시그니처:
```ts
function beginWork(
	current: Fiber | null,
	workInProgress: Fiber,
	renderLanes: Lanes
): Fiber | null;
```

- `current`: 업데이트 중인 작업용 노드에 해당하는 현재 트리의 파이버 노드에 대한 참조. 트리의 이전 버전과 새 버전 간에 변경된 사항과 업데이트할 사항을 결정하는 데 사용됨
- `workInProgress`: 작업용 트리에서 업데이트 중인 파이버 노드. `beginWork` 함수에 의해 업데이트되어 '더티'로 표시된채 반환되는 노드
- `renderLanes`: 렌더 레인은 리액트 파이버 재조정자에서 기존의 [[renderExpirationTime]]을 대체하는 새로운 개념. 이를 통해 리액트가 업데이트 우선순위를 더 잘 정하고 업데이트 프로세스를 더 효율적으로 만들 수 있음. 
  `renderLanes`는 간단히 말해 업데이트가 처리되는 '레인'을 나타내는 비트마스크. 레인은 우선순위를 여러 기준에 따라 업데이트하는 분류 방식. 변경의 우선순위가 높을수록 더 높은 레인이 할당됨. 업데이트가 올바른 순서로 처리되도록 하기 위해 `renderLanes` 값이 `beginWork` 함수에 전달됨.  이렇게 하면 사용자 상호 작용이나 접근성에 영향을 미치는 업데이트처럼 우선순위가 높은 업데이트가 최우선적으로 처리됨. 
  이외에도 리액트가 동시성을 더 잘 관리하도록 지원하기도 함. 리액트는 '타임 슬라이싱'이라는 기술을 사용해 실행 시간이 긴 업데이트를 더 작고 관리하기 쉬운 덩어리로 분할함. 이 과정에서 `renderLanes`가 주된 역할을 하는데, 리액트가 어떤 업데이트를 먼저 처리할지, 어떤 업데이트를 미룰지 결정하기 때문.
  렌더링 단계가 완료되면 `getLanesToRetrySynchronouslyOnError` 함수가 호출되어 렌더링 단계 도중에 미뤄진 업데이트가 있는지 확인함. 미뤄진 업데이트가 있는 경우 `updateComponent` 함수는 새로운 작업 루프를 시작하고 `beginWork`와 `getNextLanes`를 사용해 업데이트를 처리하며 레인에 따라 우선순위를 지정함.

#### `completeWork(작업 완료)`
- `compeleteWork` 함수는 작업용 파이버 노드에 업데이트를 적용하고 애플리케이션의 업데이트된 상태를 나타내는 실제 DOM 트리를 새롭게 생성함
- 호스트 환경이 브라우저라면 `docuemnt.createElement`, `newElement.appendChild` 같은 작업을 수행함
- 핵심은 실제 화면에 적용되지 않고 화면 밖에서 존재하는 DOM 트리라는 것
- 그렇기에 우선순위가 더 높은 업데이트가 예약되면 여기서 만들어진 UI는 버려질 수 있음
- `completeWork`의 시그니처:
```ts
function completeWork(
	current: Fiber | null,
	workInProgress: Fiber,
	renderLanes: Lanes
): Fiber | null;
```

- 이 시그니처는 `beginWork`와 동일함
- `completeWork` 함수는 `beginWork` 함수와 관계가 밀점함. `beginWork`가 파이버 노드에 '업데이트가 필요함' 상태에 대한 플래그를 설정한다면, `completeWork`는 호스트 환경에 커밋할 새 트리를 구성하는 역할
- `completeWork`가 트리 맨 위에 도달해 새 DOM 트리를 구성하면 '렌더링 단계가 완료되었다'고 볼 수 있음. 이후에는 커밋 단계로 넘어가게됨

> [!Note] 참고: [[completeWork에서 DOM을 미리 구성하는 이유]]

#### 커밋 단계
- **커밋 단계**는 렌더링 단계에서 가상 DOM에 적용된 변경 사항을 실제 DOM에 반영함