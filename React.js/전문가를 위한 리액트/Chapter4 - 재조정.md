- 지금까지는 우리가 어느정도 알고 있는 `React.createElement`를 배웠음
- 이 장에서는 리액트에서 가상 DOM을 실제로 적용하는 방법을 알아보고 `ReactDOM.createRoot(element).render()`의 동작을 배움

## 재조정 이해하기
- 가상 DOM은 우리가 원하는 UI의 청사진
- 리액트는 이 청사진을 가지고 **재조정(reconciliation)** 이라는 프로세스를 통해 주어진 환경에서 현실로 만듬

```jsx
import { useState } from "react";

const App = () => {
	const [count, setCount] = useState(0);
	
	return (
		<main>
			<div>
				<h1>안녕하세요!</h1>
				<span>카운트: {count}</span>
				<button onClick={() => setCount(count + 1)}>증가</button>
			</div>
		</main>
	);
};
```

- 재조정 과정을 이해하기 위해 위 컴포넌트를 만났을 때 내부적으로 어떻게 처리하는지 알아봄
- JSX는 리액트 엘리먼트의 트리가됨
- App 컴포넌트는 함수로 호출되면 자손 4개를 포함한 리액트 엘리먼트를 반환함

```js
const App = () => {
	const [count, setCount] = useState(0);
	
	return React.createElement(
		"main",
		null,
		React.createElement(
			"div",
			null,
			React.createElement("h1", null "안녕하세요!"),
			React.createElement("span", null, "카운트: ", count),
			React.createElement(
				"button",
				{ onClick: () => setCount(count + 1) },
				"증가"
			)
		)
	);
};
```

- App이 호출되어 생성된 리액트 엘리먼트 트리는 다음같이 표시됨

```jsx
{
	type: "main",
	props: {
		children: { // main은 div라는 단 하나의 자식을 가지므로, children은 배열이 아닌 객체
			type: "div",
			props: {
				children: [
					{
						type: "h1",
						props: {
							children: "안녕하세요!"
						}
					},
					{
						type: "span",
						props: {
							children: ["카운트: ", count]
						}
					},
					{
						type: "button",
						props: {
							onClick: () => setCount(count + 1),
							children: "증가"
						}
					}
				]
			}
		}
	}
}
```

> [!Note] 정리
> 1. **트랜스파일 (Transpilation):** 개발자가 작성한 첫 번째 코드 블록의 JSX 문법(`<main>...</main>`)은 브라우저가 직접 이해할 수 없습니다. 따라서 빌드 과정에서 바벨(Babel)과 같은 트랜스파일러를 통해 이 JSX는 두 번째 코드 블록처럼 `React.createElement(...)` 함수를 호출하는 형태의 자바스크립트 코드로 변환됩니다.
>     
> 2. **컴포넌트 호출 (Execution):** 리액트가 애플리케이션을 렌더링하기 위해 `App` 컴포넌트(함수)를 호출합니다.
>     
> 3. **가상 DOM 생성 (Virtual DOM Creation):** `App` 함수가 실행되면, 그 내부에 있는 트랜스파일된 `React.createElement` 호출들이 실행됩니다. 이 실행 결과로 마지막 코드 블록에 나타난 JSON 형태의 자바스크립트 객체 트리(리액트 엘리먼트 트리, 즉 가상 DOM)가 생성되어 반환됩니다.
>     
> 
> 결론적으로, 말씀하신 대로 JSX는 `React.createElement`를 호출하는 함수로 변경되고, `App`이 호출되면 그 아래의 JSON 형태의 구조를 그리게(생성하게) 됩니다. 이 객체 트리가 바로 UI의 "청사진"입니다.

- 위 JSON은 `Counter` 컴포넌트에서 반환하는 가상 DOM을 나타냄
- 첫 번재 렌더링이기에 이 트리는 최소한의 DOM API 호출을 통해 브라우저에 반영됨
- 필요한 DOM API 호출 최소화 하는 방법은 어떻게 될까? => 일괄 처리(배치 처리)에 있음

## 일괄 처리
- 문서 조각은 다수의 DOM 노드를 포함하는 가벼운 컨테이너로, 일종의 임시 스테이징 영역처럼 동작해서 문서의 실제 DOM에 영향을 주지 않고 여러 변경 사항을 반영한다. 최종적으로 문서 조각을 DOM에 추가하면 단 한 번의 리플로와 리페인팅이 발생한다.
- 비슷한 맥락에서 리액트는 여러 가상 DOM 업데이트를 모아 한 번의 DOM 업데이트로 결합한 후 실제 DOM에 대한 업데이트를 일괄 처리함
- 현대 리액트 내부 동작을 보기 전에, 16 미만 버전에서 사용되는 '스택(stack)' 재조정자의 동작 방식을 소개할 예정. 이를 통해 현대의 '파이버(fiber)' 재조정자의 필요성을 이해할 수 있음

> [!Note] 노트
>지금부터 논의할 모든 주제는 시간이 지나면 변경될 수도 있는 리액트 내부 구현의 세부 사항임


## 기존 기술
- 이전 리액트는 렌더링에 스택 데이터 구조를 사용

### 스택 재조정자
- 이전 리액트 재조정자는 스택 기반 알고리즘을 사용해 새 가상 트리를 이전 가상 트리와 비교하고 그에 따라 DOM을 업데이트
- 간단한 경우 잘 동작하지만 규모가 커지고 복잡해지면 여러 문제가 발생함
- 예를들어, 특정 컴포넌트의 렌더링 비용이 비싼 경우 비싼 컴포넌트가 렌더링을 막아버림. 계산 비용이 비싼 컴포넌트의 렌더링이 만약 그리 중요하지 않다면, 상대적으로 더 중요할 수 있는 사용자 입력을 막기도함
- 만약 이 렌더링과, 사용자 상호작용 사이에 우선순위를 적용해 사용자 입력을 우선 반영하고, 비싼 컴포넌트의 렌더링을 후순위로 처리할 수 있다면 사용자 경험이 올라갈것임
- 스택 재조정자는 업데이트의 우선순위를 설정하지 않음. 그래서 덜 중요한 업데이트가 더 중요한 업데이트를 방해할 수 있었음
- 리액트 앱에서 가상 트리에 대한 업데이트는 중요도가 각기 다를 수 있음
- 이러한 점을 해결하기 위해 리액트 팀은 파이버 트리라는 데이터 구조를 기반으로 하는 파이버 재조정자를 개발함

## 파이버 재조정자
- 파이버 재조정자에는 조정자를 위한 작업 단위를 나타내는 '파이버'라는 데이터 구조가 사용됨
- 파이버는 리액트 엘리먼트에서 생성됨
- 핵심적인 차이점은 파이버는 상태를 저장하고 수명이 긴 반면 리액트 일리먼트는 임시적이고 상태가 없다는 것
- 유명한 리액트 전문가이자 리덕스의 메인테이너인 마크 에릭슨은 파이버를 '특정 시점에 존재하는 실제 컴포넌트 트리를 나타내는 리액트의 내부 데이터 구조'라고 설명
- 리액트는 재조정에 파이버 트리를 사용함. 가상 DOM이 엘리먼트의 트리를 표현하는 것과 비슷함

### 데이터 구조로서의 파이버
- 파이버 재조정자는 업데이트 우선순위를 정하고 동시 실행을 가능케해 성능과 응답성을 향상시킴
- 본질적으로 파이버 데이터 구조는 리액트 앱에서 컴포넌트 인스턴스와 그 상태를 표현
- 파이버 데이터 구조는 변경 가능한 인스턴스로 설계되어 조정 과정에서 필요에 따라 업데이트되고 재배치됨
- 파이버 노드의 각 인스턴스에는 해당 컴포넌트에 대한 정보인 프롭, 상태, 하위 컴포넌트 뿐만 아니라, 컴포넌트 트리에서의 위치 정보, 파이버 재조정자가 업데이트 우선순위를 정하고 실행하는 데 사용하는 메타데이터 등이 들어있음
```js
{
	tag: 3, // 3 = ClassComponent
	type: App,
	key: null,
	ref: null,
	props: {
		name: "Tejas",
		age: 30
	},
	stateNode: AppInstnace,
	return: FiberParent,
	child: FiberChild,
	sibling: FiberSibling,
	index: 0,
	// ...
}
```

- 예시의 파이버 노드는 `ClassComponent` 라는 `App`을 나타냄
- 파이버 노드에는 다음과 같은 컴포넌트에 대한 정보가 들어있음
	- `tag`: 각 컴포넌트 유형(클래스, 함수, Suspense/Error Boundary, Fragment)에는 고유한 숫자 ID가 파이버로 설정됨
	- `type`: `App`은 파이버가 나타내는 함수 또는 클래스 컴포넌트를 나타냄
	- `props`: `{name: "Tejas", age: 30}`는 컴포넌트에 대한 입력 프롭 또는 함수에 대한 입력 인수를 나타냄
	- `stateNode`: 이 파이버가 나타내는 `App` 컴포넌트의 인스턴스. 컴포넌트 트리에서의 위치는 `return`, `child`, `sibling`, `index`로 표현되는데 각각 부모, 자녀, 형제, 파이버의 색인을 의미하며 파이버 재조정자는 이를 사용해 트리를 순회
- 파이버 재조정에는 현재 파이버 트리와 다음 파이버 트리를 비교해 어느 노드를 업데이트, 추가, 제거할지 파악하는 작업이 포함됨
- 조정 과정 중에 파이버 재조정자는 가상 DOM의 각 리액트 엘리먼트에 대해 파이버 노드를 생성함. 이는 `createFiberFromTypeAndProps` 라는 함수가 실행함. 이 함수에서 말하는 `TypeAndProps`는 다른 말로 리액트 엘리먼트라고도 부를 수 있음. 이유는 리액트 엘리먼트는 아래처럼 구성되기 때문.
```js
{
	type: "div",
	props: {
		className: "container"
	}
}
```

- `createFiberFromTypeAndProps` 함수는 엘리먼트에서 파생된 파이버를 반환함. 파이버 노드가 생성되면 재조정자는 **작업 루프(work loop)**를 사용해 사용자 인터페이스를 업데이트
- 작업 루프는 루트 파이버 노드에서 시작해 컴포넌트 트리를 따라 내려가며 업데이트가 필요한 경우 각 파이버 노드를 '더티'로 표시
- 끝에 도달하면 다시 반대로 순회하며 브라우저의 DOM 트리와 분리된 새 DOM 트리를 메모리에 생성함. 새 DOM 트리는 이후 화면에 반영됨
- 이 "반영되는 것"을 다른 말로 "내보내진다(flushed)" 라고도 함
- 이 작업을 두 가지 함수로 표현할 수 있음
	- `beginWork(작업 시작)`: 위에서 아래로 이동하며 컴포넌트를 '업데이트가 필요함'으로 표시
	- `completeWork(작업 완료)`: 다시 위로 이동하며 브라우저에서 분리된 실제 DOM 엘리먼트의 트리를 메모리에 구성
- 이러한 오프스크린 렌더링 프로세스(off-screen rendering process)는 사용자가 볼 수 없기에 언제든지 중단하고 버릴 수 있음
- 파이버 아키텍처는 다음 화면을 화면 밖에서 준비한 다음 현재 화면으로 내보내는 '더블 버퍼링'이라는 게임 엽계의 개념에서 착안함

### 더블 버퍼링
