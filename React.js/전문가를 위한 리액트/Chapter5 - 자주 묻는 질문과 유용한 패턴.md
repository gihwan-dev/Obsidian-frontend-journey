## `React.memo`를 사용한 메모화
- 메모화(memoization)는 컴퓨터 과학에서 이전에 계산된 결과를 캐싱해 함수의 성능을 최적화하는 기법
- 메모화는 함수의 순수성을 필요로함. 함수가 주어진 입력에 동일한 출력을 예측 가능하게 반환해야함.
- 네트워크 통신 같은 부작용에 의존한다면 메모화할 수 없다는 의미임
- `React.memo` 함수에서 반환하는 새 컴포넌트는 프롭이 변경되었을 때만 다시 렌더링함. '렌더링한다'는 말은 곧 함수를 다시 호출한다는 의미
- 리액트 컴포넌트는 재조정을 위해 호출되는 함수임. 함수 컴포넌트를 프롭과 함께 재귀적으로 호출해서 가상 DOM 트리를 생성하고, 생성된 가상 DOM 트리를 기반으로 재조정에 사용되는 두 개의 파이버 트리를 만듬
- 컴포넌트에서 상태 변경이 발생하면 재조정 과정에서 하위 트리에 있는 모든 함수 컴포넌트가 다시 호출되는 것은 리액트 작동 원리의 핵심임
- 다만 `React.memo`를 감싸면, 프롭이 변경된 경우에만 해당 컴포넌트를 다시 렌더링함

### `React.memo`에 능숙해지기
- 업데이트가 발생하면 리액트는 컴포넌트를 이전 렌더링에서 반환된 가상 DOM 경과와 비교함
	- 예를들어 프롭이 변경되어 비교 결과가 다르다면, 재조정자는 엘리먼트가 호스트 환경에 이미 존재하는 경우 업데이트 효과를 실행하고, 그렇지 않은 경우 배치 효과를 실행함
	- 프롭이 동일하더라도 컴포넌트는 다시 렌더링되고, DOM도 업데이트될 수 있음
- 이때 `React.memo`를 활용하면 각 렌더링 사이에 프롭이 동일한 경우 불필요한 렌더링을 피할 수 있음
- 그렇다면 얼마나 자주 메모화 해야할까? 모든 컴포넌트를 메모화 해야하나?

### 리렌더링되는 메모화된 컴포넌트
- `React.memo`는 얕은 비교를 수행해 프롭의 변경 여부를 확인함
- 문제는 스칼라 타입은 매우 정확하게 비교할 수 있지만, 스칼라가 아닌 타입은 그렇지 않다는 점임

#### 스칼라(원시 타입)
- 기본 자료형을 의미함. 숫자, 문자열, 불리언, `Symbol`, `BigInt`, `undefined`, `null` 등이 있음

#### 스칼라가 아닌 타입(참조 타입)
- 데이터 자체가 아니라 메모리에 저장된 위치에 대한 참조 또는 포인터를 저장함
- 참조 타입을 비교할 때는 내용이나 값이 아닌 메모리 참조를 기준으로함
- 이러한 특성 때문에 `React.memo`를 사용하기 까다로울 수 있음