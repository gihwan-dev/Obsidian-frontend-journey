## `React.memo`를 사용한 메모화
- 메모화(memoization)는 컴퓨터 과학에서 이전에 계산된 결과를 캐싱해 함수의 성능을 최적화하는 기법
- 메모화는 함수의 순수성을 필요로함. 함수가 주어진 입력에 동일한 출력을 예측 가능하게 반환해야함.
- 네트워크 통신 같은 부작용에 의존한다면 메모화할 수 없다는 의미임
- `React.memo` 함수에서 반환하는 새 컴포넌트는 프롭이 변경되었을 때만 다시 렌더링함. '렌더링한다'는 말은 곧 함수를 다시 호출한다는 의미
- 리액트 컴포넌트는 재조정을 위해 호출되는 함수임. 함수 컴포넌트를 프롭과 함께 재귀적으로 호출해서 가상 DOM 트리를 생성하고, 생성된 가상 DOM 트리를 기반으로 재조정에 사용되는 두 개의 파이버 트리를 만듬
- 컴포넌트에서 상태 변경이 발생하면 재조정 과정에서 하위 트리에 있는 모든 함수 컴포넌트가 다시 호출되는 것은 리액트 작동 원리의 핵심임
- 다만 `React.memo`를 감싸면, 프롭이 변경된 경우에만 해당 컴포넌트를 다시 렌더링함

### `React.memo`에 능숙해지기
- 업데이트가 발생하면 리액트는 컴포넌트를 이전 렌더링에서 반환된 가상 DOM 경과와 비교함
	- 예를들어 프롭이 변경되어 비교 결과가 다르다면, 재조정자는 엘리먼트가 호스트 환경에 이미 존재하는 경우 업데이트 효과를 실행하고, 그렇지 않은 경우 배치 효과를 실행함
	- 프롭이 동일하더라도 컴포넌트는 다시 렌더링되고, DOM도 업데이트될 수 있음
- 이때 `React.memo`를 활용하면 각 렌더링 사이에 프롭이 동일한 경우 불필요한 렌더링을 피할 수 있음
- 그렇다면 얼마나 자주 메모화 해야할까? 모든 컴포넌트를 메모화 해야하나?

### 리렌더링되는 메모화된 컴포넌트
- `React.memo`는 얕은 비교를 수행해 프롭의 변경 여부를 확인함
- 문제는 스칼라 타입은 매우 정확하게 비교할 수 있지만, 스칼라가 아닌 타입은 그렇지 않다는 점임

#### 스칼라(원시 타입)
- 기본 자료형을 의미함. 숫자, 문자열, 불리언, `Symbol`, `BigInt`, `undefined`, `null` 등이 있음

#### 스칼라가 아닌 타입(참조 타입)
- 데이터 자체가 아니라 메모리에 저장된 위치에 대한 참조 또는 포인터를 저장함
- 참조 타입을 비교할 때는 내용이나 값이 아닌 메모리 참조를 기준으로함
- 이러한 특성 때문에 `React.memo`를 사용하기 까다로울 수 있음
- `React.memo`는 프롭을 얕게 비교하기 때문에 새 배열 인스턴스를 이전 렌더링에서 사용한 배열과 다른 프롭으로 간주해 불필요하게 다시 렌더링할 수 있음
- 참조 비교에 대한 이해가 없다면 최적화는 커녕 의도하지 않은 성능 문제를 일으킬 수 있음

### 강제가 아닌 권장 사항
- 리액트는 `React.memo`를 재조정자에 대한 힌트로 사용해 컴포넌트의 프롭이 동일하게 유지되면 다시 렌더링하지 않도록 함
- `React.memo`의 동작은 부모로부터 전파되는 리렌더링을 피하기 위해 만들어졌음
- 컴포넌트 트리의 변경, 앱의 전역 상태 변경, `memo`가 적용된 함수 내부 상태 변경 등등으로 인해 메모화된 컴포넌트를 다시 렌더링할 수 있으므로 항상 리렌더링을 방지하는 것은 아님
- 아래는 리액트 소소의 일부 코드임

```jsx
function memo(type, compare) {
  return {
    $$typeof: REACT_MEMO_TYPE,
    type,
    compare: compare === undefined ? null : compare,
  }
}
```

- `React.memo`는 메모호된 컴포넌트를 나타내는 새 객체를 반환함
	- `$$typeof`: 메모화된 컴포넌트를 식별하는 속성
	- `type`: 원본 컴포넌트(함수)에 대한 참조
	- `compare`: 메모화에 사용할 비교 함수를 설정하는 속성
- `updateMemoComponent` 라는 함수(재조정자에서 `memo`를 처리하는 함수)의 동작 방식:
	1. **초기 점검**
		- 현재 파이버, 작업 중인 파이버, 컴포넌트, 새 프롭, 업데이트의 우선순와 타이밍을 나타내는 렌더 레인 등 여러 인수를 받음
		- 초기 검사(`if (current === null)`)를 통해 현재 작업이 컴포넌트의 초기 렌더링인지 아닌지를 결정함
		- `current`가 `null`이면 컴포넌트가 처음 마운트된 것
	2. **타입 및 빠른 경로 최적화**
		- `Component.compare`와 `Component.defaultProps`