## 동기식 렌더링의 문제
- 동기식 렌더링은 메인 스레드를 가로막아 사용자 경험이 저하됨
- 설계 측며에서 동기식 렌더링에는 우선순위라는 개념이 없음
- 중요하지 않은 렌더링이 메인 스레드를 막아버릴 수 있음
- 동시성 렌더링은 작업의 중요도와 긴급도에 우선순위를 정해, 중요한 업데이트가 덜 중요한 업데이트에 가로막히지 않도록함
- 이러한 동시성 렌더링 덕분에 타임 슬라이싱 같은 렌더링 프로세스를 더 작은 덩어리로 분할해 점진적으로 처리하는 기법도 가능해짐

## 파이버 다시 보기
- 파이버 재조정자는 동시성 렌더링을 가능케 하는 리액트의 핵심 메커니즘임
- 리액트 16에 도입되어 이전과 아키텍처 측면에서 크게 변화했음
- 파이버 재조정자는 렌더링 프로세스를 파이버라고 하는 더 작고 관리하기 쉬운 작업 단위로 분할해 처리함
- 리액트는 파이버를 활용해 렌더링 작업을 일시적으로 중지하거나 재개하거나 우선순위를 설정해 중요도에 따라 업데이트를 지연하거나 예약함

## 업데이트 예약과 지연
- 업데이트를 예약하고 지연하는 기능은 응답성을 유지하는데 매우 중요함
- 파이버 재조정자는 이러한 기능을 스케줄어와 여러 API에 의존해 구현함
- 스케줄러는 해야할 업데이트 작업이 있을 떄 `setTimeout`, `MessageChannel` 등의 브라우저 API를 사용해 작업을 예약, 관리하는 시스템
- 렌더링 작업 우선순위를 낮추기 위해서는 상태 업데이트를 `useTransition` 훅의 `startTransition` 함수로 감싸면 됨

## 더 깊이 들어가기
### 스케줄러
- 스케줄러는 타이밍 관련 유틸리티를 제공하는 독립형 패키지로, 파이버 재조정자와는 별개로 동작함
- 스케줄러와 재조정자는 렌더 레인을 통해 작업의 긴급도에 따라 우선순위를 설정하고 정리해 여러 작업이 협력하도록 함
- 주된 기능은 마이크로 태스크를 예약해서 메인 스레드의 제어를 관리하고 원활한 실행을 보장하는 것
- `ensureRootIsScheduled` 함수는 렌더링 프로세스를 관리하는 중요한 함수임
	- `root: FiberRoot`로 표시되는 리액트 루트가 업데이트되면 호출되어 두 가지 작업을 수행함
	- `ensureRootIsScheduled` 함수는 루트 스케줄에 루트가 포함되었는지 확인함
	- 이후 루트 스케줄을 처리하기 위한 마이크로태스크가 대기 중인지 확인함
	- 마이크로태스크는 현재 스크립트 실행 직후에 브라우저가 렌더링이나 이벤트 처리 같은 작업을 수행하기 전에 루트 스케줄의 처리가 높은 우선순위로 이루어지도록 보장하기 위해 사용됨

## 렌더 레인
- 렌더 레인은 렌더링 우선순위를 의미함
- `setStat`가 호출하면 해당 업데이트가 레인으로 보내짐. 업데이트의 우선순위는 업데이트가 발생하는 콘텍스트에 따라 달리 이해하면 됨
	- `setState`가 클릭 핸들러 내부에서 호출되면, 해당 업데이트는 `Sync`레인에 배정되며, 마이크로태스크로 예약됨
	- `setState`가 `startTransition` 내에서 호출되면 트랜지션 레인(우선순위가 낮음)에 배치되고 마이크로태스크로 예약됨
- 아래는 레인의 몇 가지 예시
	- `SyncHydrationLane`: 하이드레이션 도중 사용자가 리액트 앱을 클릭한 경우
	- `SyncLane`: 사용자가 리액트 앱을 클릭한 경우
	- `InputContinuousHydrationLane`: 하이드레이션 도중 발생하는 호버, 스크롤을 비롯한 연속적인 이벤트
	- `InputContinuousLane`: 하이드레이션 이후의 이벤트
	- `DefaultLane`: 네트워크 업데이트, `setTimeout` 같은 타이머, 우선순위가 파악되지 않는 초기 렌더링
	- `TransitionHydrationLane`: 하이드레이션 도중 `startTransition`에서 발생하는 모든 트랜지션
	- `TransitionLanes(1-15)`: 하이드레이션 후 `startTransition`에서 발생하는 모든 트랜지션
	- `RetryLanes(1-4)`: `Suspense`에서 발생하는 모든 재시도

### 렌더 레인 작동 방식
- 컴포넌트 업데이트 및 추가시, 해당 업데이트의 우선순위에 따라 레인을 할당함
- 우선순위는 업데이트 정류와 컴포넌트의 가시성같은 요인에 따라 정해짐
	- **1. 업데이트 수집**: 마지막 렌더링 이후에 예약된 모든 업데이트를 수집해 우선순위에 따라 각 레인에 할당
	- **2. 레인 처리**: 우선순위가 가장 높은 레인부터 시작해 각 레인에 있는 업데이트를 처리함. 같은 레인의 업데이트는 한꺼번에 일괄 처리함
	- **3. 커밋 단계**: 모든 업데이트를 처리한 후, 커밋 단계로 진입해 변경 사항을 DOM에 적용하고, 효과를 실행하고, 기타 마무리 작업을 수행
	- **4. 반복**: 렌더링을 할 때 마다 업데이트가 항상 우선순위대로 처리되도록 보장하고, 우선순위가 높은 업데이트가 우선순위가 낮은 업데이트에 의해 가로막히지 않도록 함
- 업데이트가 발생하면 리액트는 다음 단계를 수행해 우선순위를 결정함:
	- **1. 업데이트의 콘텍스트 확인**: 업데이트가 발생한 콘텍스트를 평가함. 사용자 상호 작용, 상태 혹은 프롭 변경으로 인한 내부 업데이트, 서버 응답에 의한 업데이트 일 수 있음. 콘텍스트는 업데이트의 우선순위를 결정하는데 중요함
	- **2. 컨텍스트에 따라 우선순위 추정**: 콘텍스트에 따라 우선순위를 추정함. 사영자 입력의 결과는 우선순위가 높을 것이며, 백그라운드 프로세스가 발생시킨 업데이트는 우선순위가 낮음.
	- **3. 우선순위 재정의가 있는지 확인**: 경우에 따라 개발자는 리액트의 `useTransition` 또는 `useDeferredValue` 훅을 사용해 업데이트 우선순위를 명시적으로 설정할 수 있음. 우선순위가 재 정의된 경우 명시적으로 설정된 우선순위를 사용하
	- **4. 올바른 레인에 업데이트 할당**: 우선순위가 결정된 후에는 해당 레인에 업데이트를 할당함. 이 과정은 앞서 살펴본 비트마스크를 사용해 이루어지며, 이를 통해 리액트는 여러 레인을 효율적으로 관리하고 업데이트가 올바르게 그룹화되고 처리되도록 보장함

### 레인 처리
- 리액트는 다음 순서로 업데이트를 처리함
	- `ImmediatePriority`
	- `UserBlockingPriority`
	- `NormalPriority`

### 커밋 단계
- 모든 업데이트를 각 레인에서 처리한 후, 리액트는 커밋 단계로 진입해 변경 사항을 DOM에 적용하고 부작용을 실행하며 그 외 마무리 작업을 수행함
- 여기까지의 과정은 훨씬 더 복잡한 부분들이 많음
- 두 레인을 함꼐 처리해야하는 시점을 결정하는 **얽힘** 개념이나, 이미 처리된 업데이트에 새로운 업데이트를 다시 적용할 시점을 결정하는 **리베이스** 같은 개념도 존재함

## `useTranstion`
- `useTransition` 에서 반환된 `startTransition` 함수로 감싸진 모든 업데이트는 트랜지션 레인에 들어감
- 이 훅은 두 요소가 포함된 배열을 반환함
	- `isPending`: 트랜지션이 진행 중인지 여부를 나타내는 불리언값. 흥미로운 점은 `startTransition`을 호출하면 가장 먼저 `isPending` 값을 `false`로 설정하는 동기적인 `setState({ isPending: false })`를 예약한다는 것임. 이는 `isPending`에 의존하는 업데이트가 빠르게 이루어져야 `useTransition`의 목적에 부합한다는 것을 의미함
	- `startTransition`: 지연, 혹은 낮은 우선순위가 부여되어야 하는 업데이트를 감쌀 때 사용하는 함수

### 더 깊이 들어가기
- 파이버 아키텍처, 스케줄러, 우선순위 수준, 렌더 레인 메커니즘에 대한 배경 지식을 바탕으로 더 깊이 들여다봄
- `useTransition` 훅은 트랜지션을 생성하고 해당 트랜지션 내에서 이루어진 업데이트에 특정 우선순위를 할당하는 방식으로 작동함
	- 함수 컴포넌트 내에서 `useTransition` 훅을 가져와 호출함
	- 이 훅은 두 개 요소가 있는 배열을 반환함. `isPending` 상태와 `startTransition` 함수임
	- `startTransition` 함수로 타이밍을 제어하려는 상태 업데이트나 컴포넌트 렌더링을 감쌈
	- `isPending` 상태는 전환이 진행중인지 아니면 완료되었는지 알려줌
	- 리액트는 트랜지션으로 감싸진 업데이트가 적절한 우선순위 수준으로 처리되도록 보장함. 이 과정에서 스케줄러와 렌더 레인 메커니즘을 사용해 업데이트를 할당하고 관리함

## `useDeferredValue`
- `useDeferredValue`는 특정 UI 업데이트를 나중으로 미루는 데 사용되는 리액트 훅
- 과부하 작업이나 연산 집약적 작업을 처리할 때 유용함
- 초기 렌더링 중에 반환되는 지연된 값은 인수로 전달된 값과 동일함. 이후 업데이트에서는 `useDeferredValue`가 오래된 값을 더 오래 유지하고, 새 값으로 업데이트 할 시점을 제어해 부드러운 사용자 경험을 유지하게 함
- 이전 값과 새 값 사이에 렌더링이 여러 번 발생하지 않도록 동작해. 값이 바뀌어도 UI가 매번 새롭게 리렌더링 되지 않음. 대신 새 값으로 업데이트될 시점을 제어해 한 번에 새 값으로 업데이트되게 함.
- 리액트 커밋 기록을 보면 첫 구현은 아래와 같았음:

```js
function useDeferredValue(value) {
  const [newValue, setNewValue] = useState(value); // 초깃값만 저장
  
  useEffect(() => {
    startTransition(() => {
      startNewValue(value);
    });
  }, [value]);
  
  return newValue;
}
```

- 컴포넌트가 지연된 값으로 다시 렌더링되면, 리액트는 일정 시간 동안 이전 값을 계속 표기하며 우선순위가 높은 업데이트가 우선순위가 낮은 업데이트보다 먼저 처리되도록 함

### `useDeferredValue`의 목적
- `useDeferredValue`의 목적은 덜 중요한 업데이트의 렌더링을 지연하는 것
- 디바운싱, 스로틀링과의 차이점: 이 방법들을 지연 시간을 설정해야 하지만 `useDeferredValue`는 렌더링 최적화에 더 특화되어 지연 시간을 사용자 기기의 성능에 맞춰 조정하며 임의로 설정할 필요가 없음
- `useDeferredValue`느 지연 시간을 동적으로 조정하는 접근 방식을 취함
- `useDeferredValue`는 지연된 렌더링을 중단시킬 수 있음
- 디바운싱과 스로틀링은 렌더링과 직접 관련이 없는 시나리오에서 유용할 수 있으며 `useDeferredValue`는 렌더링 관련 시나리오에서 효과적임. 둘 모두를 사용해 종합적인 최적화를 달성할 수도 있음

### `useDefferedValue` 사용 시기
- 대규모 데이터를 검색하거나 필터링할 때
- 복잡한 시각화나 애니메이션을 렌더링할 때
- 백그라운드에서 서버의 데이터를 업데이트할 때
- 사용자 상호 작용에 영향을 미칠 수 있는 연산 집약적 작업을 처리할 때

### `useDefferedValue`가 적합하지 않은 경우
- `useDeferredValue`의 사용 여부를 결정할 때 자문할 마땅한 질문은 '이 업데이트가 사용자 입력에 의한 것인가?' 임
- 사용자가 즉각적인 반응을 기대할 만한 업데이트는 지연하면 안됨

## 동시성 렌더링 관련 문제
- 동시성 렌더링은 성능과 응답성을 높이지만, 새로운 문제도 야기함. 그 중 가장 큰 문제는 업데이트 처리 순서를 예측하기 어렵다는 것임
- 버그의 일종인 **티어링** 이라는 현상은 업데이트 순서가 어긋나면서 UI가 일관성을 잃게 되는 문제를 가리킴
- 이 현상은 애플리케이션이 렌더링되는 동안 업데이트가 발생할 때, 컴포넌트가 일관되지 않은 데이터로 렌더링되면서 발생할 수 있음

### 티어링
- 동기식 세계에서는 컴포넌트 트리를 위에서 아래로 이동하며 차례로 렌더링하기 때문에 항상 일관적임

```jsx
let count = 0;
setInterval(() => count++, 1);

export default function App() {
  const [name, setName] = useState("");
  const [isPending, startTransition] = useTransition();
  
  const updateName = (newVal) => {
    startTransition(() => {
      setName(newVal);
    });
  };
  
  return (
    <div>
      <input value={name} onChange={(e) => updateName(e.target.value)} />
      {isPending && <div>로딩 중...</div>}
      <ul>
        <li><ExpensiveComponent /></li>
        <li><ExpensiveComponent /></li>
        <li><ExpensiveComponent /></li>
        <li><ExpensiveComponent /></li>
      </ul>
    </div>
  );
}

const ExpensiveComponent = () => {
  const now = performance.now();
  
  while(performance.now() - now < 100) {
    // 대기
  }
  
  return <>{count}</>;
}
```

- 위 예시에서 `count` 값은 `setInterval`을 통해 지속적으로 업데이트됨
- `ExpensiveComponent`의 렌더링이 사용자 입력으로 인해 중단되는 경우 오래된 `count` 값을 보여주게 될 수 있음
- 이처럼 사용자 입력에 따라 리액트가 렌더링을 '중지' 하고 텍스트 입력 필드 업데이트와 같은 더 긴급한 업데이트를 우선 처리하게 되는 경우 오래된 값을 렌더링 하게 될 수 있음

#### `useSyncExternalStore`
- 앱 내부 상태와 외부 상태를 동기화하는 리액트 훅
- 외부 저장소에 변화가 발생할 때 동기적으로 업데이트를 강제해 일관성을 유지함

```js
const value = useSyncExternalStore(store.subscribe, store.getSnapshot);
```

- `store.subscribe`
	- 함수 내부에서는 외부 저장소의 변경 사항을 구독하고 저장소에 변화가 생길 때 마다 콜백 함수를 호출
	- 리액트는 이 콜백 함수 호출을, 새 값을 사용해 컴포넌트를 리렌더링하라는 신호로 간주할 수 있음
	- 이 함수를 실행하면 정리 함수를 반환하는데 반한된 함수를 실행하며 외부 저장소의 구독을 취소함
```js
const store = {
  subscribe(rerender) {
    const newData = getNewData().then(rerender);
    return () => {
      // 구독 해제
    };
  };
};

// 사용 사례: resze, scroll 이벤트에 리렌더링을 발생 시키는 예제
const store = {
  subscribe(rerenderImmediately) {
    window.addEventListener("resize", rerenderImmediately);
    return () => {
      window.removeEventListener("resize", rerenderImmediately)
    };
  };
};
```

- `stre.getSnapshot`
	- 외부 저장소의 현잿값을 반환하는 함수
	- 컴포넌트가 렌더링될 때마다 호추되며, 반환된 값은 컴포넌트의 내부 상태를 업데이트하는 데 사용됨
	- 동기적으로 호출되므로 비동기 연산을 수행하거나 부작용이 있ㅇ서는 안됨
	- 렌더링 시점에 일관성을 보장해 여러 인스턴스의 컴포넌트가 동일한 상태를 가짐
```js
const store = {
  subcribe(즉시_리렌더링) {
    window.addEventListener("resize", 즉시_리렌더링);
    return () => {
      window.removeEventListener("resize", 즉시_리렌더링);
    }
  },
  getSnapshote() {
    return {
      width: window.innerWidth,
      height: window.innerHeight,
    };
  },
};
```

- 