## 동기식 렌더링의 문제
- 동기식 렌더링은 메인 스레드를 가로막아 사용자 경험이 저하됨
- 설계 측며에서 동기식 렌더링에는 우선순위라는 개념이 없음
- 중요하지 않은 렌더링이 메인 스레드를 막아버릴 수 있음
- 동시성 렌더링은 작업의 중요도와 긴급도에 우선순위를 정해, 중요한 업데이트가 덜 중요한 업데이트에 가로막히지 않도록함
- 이러한 동시성 렌더링 덕분에 타임 슬라이싱 같은 렌더링 프로세스를 더 작은 덩어리로 분할해 점진적으로 처리하는 기법도 가능해짐

## 파이버 다시 보기
- 파이버 재조정자는 동시성 렌더링을 가능케 하는 리액트의 핵심 메커니즘임
- 리액트 16에 도입되어 이전과 아키텍처 측면에서 크게 변화했음
- 파이버 재조정자는 렌더링 프로세스를 파이버라고 하는 더 작고 관리하기 쉬운 작업 단위로 분할해 처리함
- 리액트는 파이버를 활용해 렌더링 작업을 일시적으로 중지하거나 재개하거나 우선순위를 설정해 중요도에 따라 업데이트를 지연하거나 예약함

## 업데이트 예약과 지연
- 업데이트를 예약하고 지연하는 기능은 응답성을 유지하는데 매우 중요함
- 파이버 재조정자는 이러한 기능을 스케줄어와 여러 API에 의존해 구현함
- 스케줄러는 해야할 업데이트 작업이 있을 떄 `setTimeout`, `MessageChannel` 등의 브라우저 API를 사용해 작업을 예약, 관리하는 시스템
- 렌더링 작업 우선순위를 낮추기 위해서는 상태 업데이트를 `useTransition` 훅의 `startTransition` 함수로 감싸면 됨

## 더 깊이 들어가기
### 스케줄러
- 스케줄러는 타이밍 관련 유틸리티를 제공하는 독립형 패키지로, 파이버 재조정자와는 별개로 동작함
- 스케줄러와 재조정자는 렌더 레인을 통해 작업의 긴급도에 따라 우선순위를 설정하고 정리해 여러 작업이 협력하도록 함
- 주된 기능은 마이크로 태스크를 예약해서 메인 스레드의 제어를 관리하고 원활한 실행을 보장하는 것
- `ensureRootIsScheduled` 함수는 렌더링 프로세스를 관리하는 중요한 함수임
	- `root: FiberRoot`로 표시되는 리액트 루트가 업데이트되면 호출되어 두 가지 작업을 수행함
	- `ensureRootIsScheduled` 함수는 루트 스케줄에 루트가 포함되었는지 확인함
	- 이후 루트 스케줄을 처리하기 위한 마이크로태스크가 대기 중인지 확인함
	- 마이크로태스크는 현재 스크립트 실행 직후에 브라우저가 렌더링이나 이벤트 처리 같은 작업을 수행하기 전에 루트 스케줄의 처리가 높은 우선순위로 이루어지도록 보장하기 위해 사용됨

## 렌더 레인
- 렌더 레인은 렌더링 우선순위를 의미함
- `setStat`가 호출하면 해당 업데이트가 레인으로 보내짐. 업데이트의 우선순위는 업데이트가 발생하는 콘텍스트에 따라 달리 이해하면 됨
	- `setState`가 클릭 핸들러 내부에서 호출되면, 해당 업데이트는 `Sync`레인에 배정되며, 마이크로태스크로 예약됨
	- `setState`가 `startTransition` 내에서 호출되면 트랜지션 레인(우선순위가 낮음)에 배치되고 마이크로태스크로 예약됨
- 아래는 레인의 몇 가지 예시
	- `SyncHydrationLane`: 하이드레이션 도중 사용자가 리액트 앱을 클릭한 경우
	- `SyncLane`: 사용자가 리액트 앱을 클릭한 경우
	- `InputContinuousHydrationLane`: 하이드레이션 도중 발생하는 호버, 스크롤을 비롯한 연속적인 이벤트
	- `InputContinuousLane`: 하이드레이션 이후의 이벤트
	- `DefaultLane`: 네트워크 업데이트, `setTimeout` 같은 타이머, 우선순위가 파악되지 않는 초기 렌더링
	- `TransitionHydrationLane`: 하이드레이션 도중 `startTransition`에서 발생하는 모든 트랜지션
	- `TransitionLanes(1-15)`: 하이드레이션 후 `startTransition`에서 발생하는 모든 트랜지션
	- `RetryLanes(1-4)`: `Suspense`에서 발생하는 모든 재시도

### 렌더 레인 작동 방식
- 컴포넌트 업데이트 및 추가시, 해당 업데이트의 우선순위에 따라 레인을 할당함
- 우선순위는 업데이트 정류와 컴포넌트의 가시성같은 요인에 따라 정해짐
	- **1. 업데이트 수집**: 마지막 렌더링 이후에 예약된 모든 업데이트를 수집해 우선순위에 따라 각 레인에 할당
	- **2. 레인 처리**: 우선순위가 가장 높은 레인부터 시작해 각 레인에 있는 업데이트를 처리함. 같은 레인의 업데이트는 한꺼번에 일괄 처리함
	- **3. 커밋 단계**: 모든 업데이트를 처리한 후, 커밋 단계로 진입해 변경 사항을 DOM에 적용하고, 효과를 실행하고, 기타 마무리 작업을 수행
	- **4. 반복**: 렌더링을 할 때 마다 업데이트가 항상 우선순위대로 처리되도록 보장하고, 우선순위가 높은 업데이트가 우선순위가 낮은 업데이트에 의해 가로막히지 않도록 함
- 업데이트가 발생하면 리액트는 다음 단계를 수행해 우선순위를 결정함:
	- **1. 업데이트의 콘텍스트 확인**: 업데이트가 발생한 콘텍스트를 평가함. 사용자 상호 작용, 상태 혹은 프롭 변경으로 인한 내부 업데이트, 서버 응답에 의한 업데이트 일 수 있음. 콘텍스트는 업데이트의 우선순위를 결정하는데 중요함
	- **2. 컨텍스트에 따라 우선순위 추정**: 콘텍스트에 따라 우선순위를 추정함. 사영자 입력의 결과는 우선순위가 높을 것이며, 백그라운드 프로세스가 발생시킨 업데이트는 우선순위가 낮음.
	- **3. 우선순위 재정의가 있는지 확인**: 경우에 따라 개발자는 리액트의 `useTransition` 또는 `useDeferredValue` 훅을 사용해 업데이트 우선순위를 명시적으로 설정할 수 있음. 우선순위가 재 정의된 경우 명시적으로 설정된 우선순위를 사용하
	- **4. 올바른 레인에 업데이트 할당**: 우선순위가 결정된 후에는 해당 레인에 업데이트를 할당함. 이 과정은 앞서 살펴본 비트마스크를 사용해 이루어지며, 이를 통해 리액트는 여러 레인을 효율적으로 관리하고 업데이트가 올바르게 그룹화되고 처리되도록 보장함

### 레인 처리
- 리액트는 다음 순서로 업데이트를 처리함
	- `ImmediatePriority`
	- `UserBlockingPriority`
	- `NormalPriority`

### 커밋 단계
- 모든 업데이트를 각 레인에서 처리한 후, 리액트는 커밋 단계로 진입해 변경 사항을 DOM에 적용하고 부작용을 실행하며 그 외 마무리 작업을 수행함
- 여기까지의 과정은 훨씬 더 복잡한 부분들이 많음
- 두 레인을 함꼐 처리해야하는 시점을 결정하는 **얽힘** 개념이나, 이미 처리된 업데이트에 새로운 업데이트를 다시 적용할 시점을 결정하는 **리베이스** 같은 개념도 존재함

## `useTranstion`
- `useTransition` 에서 반환된 `startTransition` 함수로 감싸진 모든 업데이트는 트랜지션 레인에 들어감
- 이 훅은 두 요소가 포함된 배열을 반환함
	- `isPending`: 트랜지션이 진행 중인지 여부를 나타내는 불리언값. 흥미로운 점은 `startTransition`을 호출하면 가장 먼저 `isPending` 값을 `false`로 설정하는 동기적인 `setState({ isPending: false })`를 예약한다는 것임. 이는 `isPending`에 의존하는 업데이트가 빠르게 이루어져야 `useTransition`의 목적에 부합한다는 것을 의미함
	- `startTransition`: 지연, 혹은 낮은 우선순위가 부여되어야 하는 업데이트를 감쌀 때 사용하는 함수