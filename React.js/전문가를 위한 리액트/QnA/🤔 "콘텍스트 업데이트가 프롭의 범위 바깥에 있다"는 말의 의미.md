이 말의 핵심은 **데이터가 컴포넌트로 전달되는 경로가 다르다**는 것입니다. 비유를 통해 설명해 드릴게요.

- **Props (소포 📦)**: 부모 컴포넌트가 자식 컴포넌트에게 **직접, 명시적으로** 건네주는 '소포'와 같습니다. 자식은 부모에게서 온 소포의 내용물이 이전과 같은지만 확인하면 됩니다. `React.memo`는 바로 이 소포의 내용물만 검사하는 역할을 합니다.
    
- **Context (사내 방송 📢)**: 컴포넌트 트리 상단 어딘가에 있는 Provider가 "전 직원에게 알립니다!" 하고 외치는 '사내 방송'과 같습니다. 이 방송은 중간 관리자(중간 컴포넌트)들을 거치지 않고, 방송을 듣기로 한(구독한) 모든 직원(컴포넌트)에게 **직접, 암시적으로** 전달됩니다.
    

"콘텍스트 업데이트가 프롭의 범위 바깥에 있다"는 말은 다음과 같이 해석할 수 있습니다.

> `React.memo`는 부모가 직접 건네준 '소포(props)'가 변경되었는지만 감시하고 있는데, 갑자기 '사내 방송(Context)'으로 새로운 지시가 내려왔다. 이 새로운 지시는 소포와는 전혀 다른 경로로 전달되었기 때문에, 소포 내용물이 그대로라고 해서 이 지시를 무시하면 안 된다. 따라서 사내 방송이 울리면, 받던 소포 내용이 같더라도 무조건 새로운 지시에 따라 행동(리렌더링)해야 한다.

즉, **`React.memo`의 주된 관심사는 'props'라는 범위**이지만, **Context 업데이트는 그 범위 밖에서 발생하는 독립적인 렌더링 트리거**이기 때문에 `React.memo`의 비교 로직을 무시하고 강제로 리렌더링을 유발하는 것입니다. 만약 그렇지 않다면 컴포넌트는 낡은 컨텍스트 값을 계속 보여주는 심각한 버그를 일으키게 될 것입니다.