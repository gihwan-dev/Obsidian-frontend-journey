구현하기 전에 알아야할 중요한 포인트들이 있다.

## Interfacing Rust and JavaScript

> [!danger]
> 이 주제는 러스트로 웹 어셈블리를 통합하는데 알아야할 가장 중요한 개념 하나다.

JavaScript의 가비지 컬렉션 힙(heap) -- 객체, 배열, DOM 노드가 할당되는 공간 -- 은 웹 어세블리의 선형 메모리 공간과 구별된다. `Rust`의 값은 웹 어셈블리의 선형 메모리 공간에 존재한다. 현재 웹 어셈블리는 가비지 컬렉션 힙에 직접 접근할 수 없다. 반면 JavaScript는 웹 어셈블리의 선형 메모리 공간을 읽고 쓸 수 있지만, 이는 ArrayBuffer 형식의 스칼라 값(u8, i32, f64 등)만 가능하다. `WebAssembly` 함수도 스칼라 값을 입력으로 받고 반환한다. 웹 어셈블리 함수도 스칼라 값을 입력으로 받고 반환한다. 이러한 스칼라 값들은 웹 어셈블리와 자바스크립트 간의 모든 통신의 기본 요소다.

> [!info] ArrayBuffer 란?
> ArrayBuffer는 자바스크립트에서 바이너리 데이터를 표현하고 조작하기 위한 객체다. 메모리 버퍼로 사용되며, 고정길이의 원시 바이너리 데이터 버퍼를 나타낸다.

`wasm_bindgen`은 이 경계를 넘어 복합 구조체를 작업하는 방법에 대한 공통 이해를 정의한다. 이는 `Rust` 구조체를 박싱하고, 해당 포인터를 `JavaScript` 클래스에 래핑해 사용하거나, `Rust` 에서 `JavaScript` 객체의 테이블에 인덱싱하는 것을 포함한다. `wasm_bindgen`은 매우 편리하지만, 데이터 표현과 경계를 넘어 전달되는 값과 구조체를 고려할 필요성을 제거하지는 않는다. `wasm_bindgen`은 선택한 인터페이스 설계를 구현하기 위한 도구로 생각해야 한다.

`WebAssembly`와 `JavaScript` 간의 인터페이스를 설계할 때, 다음의 속성을 최적화하는 것이 중요하다:

1. **불필요한 복사 최소화**: `WebAssembly` 선형 메모리로의 불필요한 복사는 오버헤드를 증가시킨다. 이를 최소화해야 한다.
2. **직렬화 및 역직렬화 최소화**: 직렬화와 역직렬화도 복사와 마찬가지로 오버헤드를 초래한다. 데이터 구조에 대한 불투명 핸들을 전단할 수 있다면, 한쪽에서 데이터를 직렬화하고 `WebAssembly` 선형 메모리의 특정 위치로 복가한 후, 다른 쪽에서 역직렬화 하는 과정을 피할 수 있다. 이는 많은 오버헤드를 줄이는 데 도움이 된다. `wasm_bindgen`은 `JavaScript` 객체나 박싱된 `Rust` 구조체에 대한 불투명 핸들을 정의하고 다루는데 유용하다.

> [!info] 불투명 핸들이란?
> 내부 구조를 숨기고 참조만을 제공하는 방식이다. 복잡한 데이터 구조를 직접 전달하는 대신, 해당 구조에 대한 포인터나 참조를 전달함으로써 오버헤드를 줄일 수 있다. 예를 들어, `JavaScript`에서 `WebAssembly` 함수에 큰 데이터를 전달할 때, 데이터를 직접 복사하는 대신 해당 데이터에 대한 핸들을 전달해 처리할 수 있다.

일반적으로, 효율적인 `JavaScript` <=> `WebAssembly` 인터페이스 설계는 큰 장기 데이터 구조를 `WebAssembly` 선형 메모리에 있는 `Rust` 타입으로 구현하고, 이를 `JavaScript`에 불투명 핸들로 노출하는 것이다. `JavaScript`는 이 불투명 핸들을 사용해 `WebAssembly` 함수를 호출하고, 데이터 변환, 무거운 계산 수행, 데이터 조회 등을 처리한다. 결국, 작고 쉽게 복사 가능한 결과를 반환함으로써 `JavaScript`의 가비지 컬렉션 힙과 `WebAssembly` 선형 메모리 간의 불필요한 복사  및 직렬화를 피할 수 있다.

