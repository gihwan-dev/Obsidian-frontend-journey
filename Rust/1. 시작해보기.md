## 1.1 설치하기
> [!note] rustup 이외의 다른 방법으로 설치하길 원한다면 기타 러스트 설치 방법 페이지를 참고하기 바랍니다.

러스트 컴파일러 최신 stable 버전을 설치하는 내용이다. 러스트에는 안정성 보증이 적용되어 있다. 간혹 에러나 경고 메세지가 변경되는 일이 있기에 출력은 버전마다 조금 다를 수 있으나, 이 책 에 등장하는 모든 예제는 향후 버전에서도 책 내용에서 설명하는대로 동작할 거다.

### rustup 설치(리눅스 및 macOS)

터미널을 열고 다음 명령어를 입력해라.
```bash
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

최신 stable 버전 러스트를 설치하는 데 사용할 rustup 도구를 설치하는 명령어다.

러스트가 컴파일 결과를 하나의 파일로 묶는 데 사용하는 링커(linker)도 필요하다. 링커는 기본적으로 설치되지만 러스트 컴파일 시에 링커를 실행할 수 없다는 에러가 나타나면 따로 설치해야 한다.

### 트러블 슈팅

러스트가 제대로 설치되었는지 확인하는 방법

```bash
rustc --version
```

만약 버전 정보가 보이지 않는다면 환경 변수에 러스트가 포함되어 있는지 확인해라.

### 업데이트 및 삭제

```bash
// 업데이트
rustup update
// 삭제
rustup self uninstall
```

### 로컬 문서

러스트 설치 시 로컬 문서도 같이 설치된다. 오프라인 상태로도 이용할 수 있으며, `rustup doc` 명령어로 브라우저에서 열어볼 수 있다.

### 러스트 프로그램 작성하고 실행하기

`*.rs`의 형태로 소스 파일을 만들어 실행한다. 러스트에서 파일 명을 지을 때는 두 단어 이상으로 이루어질 경우 `hello_world.rs`처럼 단어 사이에 밑줄(\_)을 넣는 것이 관례다. 다음과 같은 코드를 작성해보자.

```rust
fn main() {
	println!("Hello, world!");
}
```

위와 같은 형식의 파일을 작성하고

```bash
rustc main.rs
```

로 실행할 수 있다.

### 러스트 프로그램 뜯어보기

`main`함수는 특별한 함수다. 러스트 실행 프로그램에서 가장 먼저 실행되는 함수다.

> [!note] 러스트 프로젝트의 코드를 표준 스타일로 통일시키고 싶다면, 코드를 특정 스타일로 포매팅해주는 rustfmt라는 일므의 자동 포매팅 도구를 사용할  수 있다. 기본 러스트 배포에 포함되어 있어, 이미 설치되어 있을거다.

`main`함수 내 코드를 살펴보자.

 1. 러스트에서는 탭 대신 스페이스 4칸을 사용한다.
 2. `println!`는 러스트의 매크로(macro) 호출 코드다. 함수 호출 코드였다면 `!`없이 `println`이라고 되어 있었을거다.
 3. 라인은 세미콜론(`;`)으로 끝난다. 러스트 코드의 거의 모든 라인이 세미콜론으로 끝난다.

### 컴파일과 실행은 별개의 과정이다.

러스트 프로그램을 실행하기 전에, 아래와 같이 `rustc` 명령어에 소스 파일명을 넘겨주어 컴파일해야 하는 과정이 있다.

```bash
rustc main.rs
```

러스트는 소스 파일 컴파일에 성공하면 실행할 수 있는 바이너리를 만들어낸다.

루비, 파이썬, 자바스크립트는 파일을 다른 곳에서 싫행하려면 해당 언어의 구현체를 설치해야한다. 반면 러스트는 `AOT(ahead-of-time)컴파일` 언어로, 컴파일과 실행이 별개인 대신 프로그맹을 컴파일 하여 만든 실행 파일을 러스트가 설치되지 않은 곳에서도 실행할 수 있다.

### 카고를 사용해 보자.

카고는 러스트 빌드 시스템 및 패키지 매니저다. 외부 라이브러리를 다운로드 할 때나, 라이브러리를 제작할 때 겪는 귀찮은 일들을 상당수 줄여주는 편리한 도구다.

다음 명령어로 카고가 설치되어 있는지 확인할 수 있다.

```bash
cargo --version
```

### 카고로 프로젝트 생성하기

프로젝트 디렉터리로 돌아가 다음 명령어를 실행해보자.

```bash
cargo new hello_cargo
```

우리가 한 일은 다음과 같다:

1. 프로젝트 이름을 `hello_cargo`로 지정했다.
2. `Cargo.toml`파일과 `src` 디렉터리를 확인할 수 있다. 또한 `src` 디렉터리 내에는 `main.rs`파일이 있는 것도 볼 수 있다.
3. `.gitifnore`파일과 함께 새 `Git`저장소가 초기화된다.

`Cargo.toml`파일은 `TOML(Tom's Obvious Minimal Language)` 포맷으로 되어 있고, 이 포맷은 카고 설정에서 사용하는 포맷이다.

### 카고로 프로젝트를 빌드하고 실행하기

다음 명령어를 통해 빌드 할 수 있다.

```bash
cargo build
```

이 명령어는 현재 디렉터리가 아닌 `target/debug/hello_cargo`로 실행 파일을 생성한다. 기본 빌드가 디버그 빌드기 때문에, 카고는 `debug`라는 디렉터리에 바이너리를 생성한다. 실행 파일은 다음 명령어로 실행할 수 있다.

```bash
./target/debug/hello_cargo
```

`Hello, world!`가 출력되면 제대로 진행된거다. 처음 `cargo build` 명령어를 실행하면 최상위 디렉터리에 `Cargo.lock` 파일이 생성될 텐데, 이 파일은 프로젝트에서 사용하는 디펜던시의 정확한 버전을 자동으로 기록해두는 파일이다. 직접 수정할 필요는 없다.

컴파일과 실행을 한 번에 진행하는 `cargo run` 명령어도 있다.

```bash
cargo run
```

출력 내용에 `hello_cargo`를 컴파일 중이라는 내용어 없다. 이는 카고가 파일 변경 사항이 없음을 알아채고 기존 바이너리를 그대로 실행했기 때문이다. 소스 코드를 수정한 뒤 명령어를 다시 실행해보면 프로젝트를 다시 빌드한 후에 바이너리를 실행한다.

현재까지 카고에 대해 배운 내용을 요약하면 다음과 같다:

1. `cargo new`로 새 프로젝트를 생성할 수 있다.
2. `cargo build` 명령으로 프로젝트를 빌드할 수 있다.
3. `cargo run` 명령어는 한 번에 프로젝트를 빌드하고 실행할 수 있다.
4. `cargo check` 명령으로 바이너리를 생성하지 않고 프로젝트의 에러를 체크할 수 있다.
5. 빌드로 만들어진 파일은 작성한 소스 코드와 뒤섞이지 않도록 `target/debug` 디렉터리에 저장된다.

운영체제에 상관없이 같은 명령어를 사용한다는 것도 카고 사용으로 얻는 추가적인 장점이다.

### 릴리스 빌드 생성하기

`cargo build --release` 명령어를 사용해 릴리스 빌드를 생성할 수 있다. 일반 빌드와 차이점은 `target/release`에 실행 파일이 생성된다. 그리고 컴파일 시 최적화를 진행하여 컴파일이 오래 걸리는 대신 러스트 코드가 더 빠르게 동작한다는 점이다.

### 관례로서의 카고

여러 개의 파일 혹은 디펜던시를 필요로 하는 복잡한 프로젝트에서는 카고가 빌드를 조정하게 하는 것이 훨씬 쉽다.

## 정리 

이 장에서 배운 내용은 다음과 같다:

1. `rustup`으로 최신 stable 버전 러스트를 설치하기
2. 러스트를 새 번전으로 업데이트하기
3. 로컬 설치된 문서 열어보기
4. 직접 `rustc`를 사용해 'Hello, world!' 프로그램을 작성하고 실행해보기
5. 일반적인 카고의 사용법으로 프로젝트를 생성하고 실행하기