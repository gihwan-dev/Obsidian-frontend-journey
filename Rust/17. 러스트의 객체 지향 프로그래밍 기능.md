객체 지향 프로그래밍은 프로그램을 모델링 하는 방식이다. 이 장에서는 일반적으로 객체 지향이라고 간주하는 특성들을 알아보고 이런 특성들이 러스트다운 표현들로 어떻게 변환되는지 알아보자. 이후 객체 지향적 디자인 패턴을 러스트에서 구현하는 방법을 보여주고, 그렇게 했을 때와 러스트가 가진 강점 중 일부를 사용하여 구현했을 경우의 장단점에 대해 논의해보겠다.

## 객체 지향 언어의 특성

OOP 언어라면 거의 틀림없이 몇 가지 공통된 특성을 공유한다. 여기에는 객체, 캡슐화, 상속 등이 있다.

### 객체는 데이터와 동작을 담는다.

`<<GoF의 디자인 패턴>>` 이라는 책에서는 OOP를 다음과 같이 정의한다.

> *객체 지향 프로그램은 객체로 구성된다. **객체**는 데이터 및 이 데이터를 활용하는 프로시저를 묶는다. 이 프로시저들을 보통 **메서드** 혹은 **연산**이라고 부른다.

이 정의에 따르면, 러스틑 객체 지향적이다. 구조체와 열거형에는 데이터가 있고, `impl` 블록은 그 구조체와 열거형에 대한 메서드를 제공한다. 설령 메서드가 있는 구조체와 열거형이 객체라고 **호칭**되지는 않아도, 객체에 대한 정의에 따르면 이들은 동일한 기능을 제공한다.

### 상세 구현을 은닉하는 캡슐화

**캡술화**는 객체를 이용하는 코드에서 그 객체의 상세 구현에 접근할 수 없게 하는 것이다. 객체와 상호작용하는 유일한 방법은 해당 객체의 공개 API를 통하는 것이다.

```rust
pub struct AverageCollection {
	list: Vec<i32>,
	average: f64,
}
```

구조체는 `pub`로 표시되어 다른 코드가 이를 사용할 수 있지만, 구조체 안에 존재하는 필드들은 여전히 비공개다.

```rust
impl AverageCollection {
	pub fn add(&mut self, value: i32) {
		self.list.push(value);
		self.update_average();
	}

	pub fn remove(&mut self) -> Option<i32> {
		let result = self.list.pop();
		match result {
			Some(value) => {
				self.update_average();
				Some(value)
			}
			None => None,
		}
	}

	pub fn average(&self) -> f64 {
		self.average
	}

	fn update_average(&mut self) {
		let total: i32 = self.list.iter().sum();
		self.average = total as f64 / self.list.len() as f64;
	}
}
```

공개 메서드 `add`와 `remove`, `average`는 `AveragedCollection` 인스턴스의 데이터에 접근하거나 수정할 수 있는 유일한 방법이다. `add` 메서드를 사용해 `list` 에 아이템을 추가하거나 `remove`로 제거하면 각 구현에서 비공개 메서드 `update_average`도 호출한다.

`list`와 `average` 필드는 비공개로 했기 때문에 외부 코드가 `list` 필드에 직접 아이템을 추가하거나 제거할 방법은 없다.

`AveragedCollection`의 세부 수현은 캡슐화되었기 때문에, 향후에 데이터 구조와 같은 측면은 쉽게 변경할 수 있다. `add`, `remove`, `average` 공개 메서드의 시그니처가 그대로 유지되는 한, `AverageCollection`을 사용하는 코드들은 변경될 필요가 없다.

캡슐화가 객체 지향 언어로 간주하기 위해 필요한 측면이라면, 러스트는 해당 요구 사항을 충족한다.

### 타입 시스템과 코드 공유로서의 상속