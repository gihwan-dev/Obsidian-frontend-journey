실제 프로젝트에서 몇몇 일반적인 러스트의 개념이 어떻게 활용되는지 소개하려 한다.

### 새로운 프로젝트 준비하기

다음의 명령어로 프로젝트르 생성하자.

```bash
cargo new guessing_game
```

`cargo run`으로 프로그램을 컴파일하고 실행해보자.

### 추릿값 처리하기

사용자 입력 요청, 입력값의 처리 후 입력값이 기대하던 형식인지 검증한다.

첫 시작으로 플레이어가 추리한 값을 입력받을 수 있게 하자.

```rust
use std:io;

fn main() {
	println!("Guess the number!");
	println!("Please input your guess");

	let mut guess = String::new();

	io::stdin()
		.read_line(&mut guess)p
		.expect("Failed to read line");

	pprintln!("You guessed: {guess}");
}
```

이 코드에 담긴 다양한 정보를 한 줄씩 살펴보자. 사용자 입력을 받고 결과값을 표시하기 위해서는 `io`입출력 라이브러리를 스코프로 가져와야 한다. `io` 라이브러리는 `std`라고 불리는 표준 라이브러리에 있다.

```rust
use std::io;
```

러스트는 모든 프로그램의 스코프로 가져오는 표준 라이브러리에 정의된 아이템 집합을 가지고 있다. 이 집합을 **프렐루드**라고 부르며, 이와 관련한 것은 표준 라이브러리 문서에서 찾아볼 수 있다.

만약 원하는 타입이 프렐루드에 없다면 `use` 문을 활용하여 명시적으로 그 타입을 가져와야 한다. `std::io`는 사용자의 입력을 받는 것을 포함하여 `io`와 관련된 기능들을 제공한다.

1장에서 보았듯이 `main`함수는 프로그램의 진입점이다.

```rust
fn main() {}
```

`fn` 문법은 새로운 함수를 선언하며, 괄호 `()`는 매개변수가 없음을 나타내고 중괄호 `{}`는 함수 본문을 나타낸다.

`println!()`은 문자열을 콘솔에 출력하는 매크로다.

```rust
println!("Guess the number!");

println!("Please input your guess.");
```

### 변수에 값 저장하기

아래와 같이 사용자의 입력값을 저장할 **변수**를 생성한다.

```rust
let mut guess = String::new();
```

변수를 만드는 데에는 `let` 구분을 사용한다. 다음 코드도 변수를 선언하는 예시다.

```rust
let apples = 5;
```

이 라인은 `apples`라는 변수를 생성하고 `5`라는 값을 바인딩한다. 러스트에서 변수는 기본적으로 불변이다. 변수의 값을 가변(mutable)하게 만들려면 `mut`를 변수명 앞에 추가한다.

```rust
let apples = 5; // immutable
let mut bananas = 5; // mutable
```

`등호(=)`는 지금 해당 변수에 어떤 값을 바인딩하고자 함을 뜻한다. 등호의 오른쪽에는 `guess`에 바인딩 한 값이 있다. `String::new`의 결과값인 새로운 `String` 인스턴스가 바인딩 된다. `String`은 포준 라이브러리에서 제공하는 확장 가능한 UTF-8 인코딩의 문자열 타입이다.

`::new`에 있는 `::`는 `new`가 `String`타입의 **연관 함수(associated function)** 임을 나타낸다. 연관 함수란 어떤 타입에 구현된 함수고, 위의 경우에는 `String`타입에 만들어진 함수다. 이 `new` 함수는 비어있는 새 문자열을 생성한다.

요약하면 `let mut guess = String::new();`라인은 새로운 빈 `String` 인스턴스를 바인딩한 가변 변수를 생성하낟.

### 사용자 입력 받기

`use std::io;`를 사용해서 표준 라이브러리의 입출력 기능을 가져온 것을 상기해 보자. `io`모듈의 연관 함수인 `stdin`을 호출해 사용자 입력을 처리할 수 있다.

```rust
io:stdin()
	.read_line(&mut guess);
```

프로그램 시작 지점에서 `use std::io`를 통해 `io` 라이브러리를 가져오지 않았더라도, 함수 호출 시 `std::io::stdin`처럼 작성하는 것으로 이 함수를 이용할 수 있다. `stdin`함수는 터미널의 표준 입력 핸들을 나타내는 타입인 `std::io::Stdin`의 인스턴스를 돌려준다.

`read_line(&mut guess)`는 사용자로부터 입력받기 위해 표준 입력 핸들(Stdin)에서 `read_line`메서드를 호출한다. 여기에서 `&mut guess`를 `read_line`의 인수로 전달하여 사용자 입력이 어떤 문자열에 저장될 것인지 알려준다. 메서드가 문자열의 내용물을 바꿀 수 있기 때문에 이 문자열 인수는 가변이여야 한다.

`&`는 코드의 여러 부분에서 데이터를 여러 번 메모리로 복사하지 않고 접근하기 윟나 방법을 제공하는 **참조자**임을 나타낸다. 지금 당장 여러 부분을 이해할 필요는 없다. **참조자**가 변수처럼 기본적으로 불변임을 알기만 하면 된다. 따라서 `&guess`가 아니라 `&mut guess`로 작성하여 가변으로 만들 필요가 있다.

### Result 타입으로 잠재적 실패 다루기

다음 메서드를 살펴보자.

```rust
	.expect("Failed to read line");
```

위 코드를 아래처럼 쓸 수도 있다.

```rust
io:stdin().read_line(&mut guess).expect("Failed to read line");
```

