이 장에서는 거의 모든 프로그래밍 언어에 등장하는 개념들과 그 개념들이 러스트에 어떻게 작동하는지 소개한다.

> [!info] **키워드**
> 러스트 언어는 대부분의 다른 언어들과 마찬가지로 이 언어만 사용 가능한 **키워드**라는 집합이 있다. 키워드는 함수명이나 변수명으로 사용할 수 없음을 알아둬라.

## Table of contents

## 변수와 가변성

변수는 기본적으로 **불변(immutable)** 이다. 이는 러스트가 제공하는 안정성과 동시성을 활용하는 방식으로 코드를 작성하도록 유도하는 너지(nudge, 슬며시 선택을 유도하기) 중 하나다. 여전히 변수를 가변으로 만들 수 있다. 어떻게 하는지 살펴보고 왜 러스트가 불변성을 권하는지와 어떨 때 가변성을 써야 하는지 알아보자.

다음과 같은 코드를 작성해보자.

```rust
fn main() {
	let x = 5;
	println!("The value of x is: {x}");
	x = 6;
	println!("The value of x is: {x}");
}
```

`cargo run`으로 프로그램을 실행하면, 불변성 에러에 관한 에러 메시지를 받을거다.

값이 바뀌지 않을 것이라고 지정하면 러스트 컴파일러는 실제로 그렇게 되도록 보증한다. 이 말은 코드를 읽고 쓸 때 값이 어디서 어떻게 바뀔지 추적할 필요가 없다는 것이다. 코드의 흐름을 따라가기 쉬워진다.

하지만 가변성은 아주 유용할 수 있다. 변수가 기본적으로 불변이더라도 `mut`를 변수명 앞에 붙여서 가변으로 만들 수 있다. 또한 이 `mut`는 이 변수의 값이 변경될거라는 의도를 전달할 수 있게 해준다.

```rust
fn main() {
	let mut x = 5;
	println!("The value of x is: {x}");
	x = 6;
	println!("The valu of x is: {x}");
}
```

### 상수

**상수(constant)** 는 불변 변수와 비슷한데, 어떤 이름에 묶여 있는 값이고 값을 바꾸는 것이 허용되지 않지만, 변수와는 약간 다른 점들이 있다.

상수는 `mut`와 함께 사용할 수 없다. 즉 항상 불변이다. `let`키워드 대신 `const` 키워드로 선언하며, 값의 타입은 **반드시** 명시되어야 한다.

상수는 전역 스코프를 포함한 어떤 스코프에서도 선언 가능하므로 코드의 많은 부분에서 알 필요가 있는 값에 유용하다.

상수는 반드시 상수 표현식으로만 설정될 수 있도록 하고 런타임에서만 계산될 수 있는 결괏값으로 안 된다는 것이다.

아래는 상수 선언의 예제다.

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

러스트의 이름 짓기 관례에서 상수는 단어 사이에 밑줄을 사용하고 모든 글자를 대문자로 쓰는 것이다.

상수는 선언된 스코프 내에서 프로그램이 작동하는 전체 시간 동안 유효하다. 이러한 특성은 플레이어가 얻을 수 있는 점수의 최댓값이라든가 빛의 속도와 같이, 프로그램 여러 부분에서 알 필요가 있는 값들에 유용하다.

하드 코딩된 값에 상수로서 이름을 붙이는 것은 미래의 코드 관리자에게 그 값의 의미를 전달하는 데 유용하다.

### 섀도잉

새 변수를 이전 변수명과 같은 이름을 선언할 수 있다. 이를 첫 번째 변수가 두 번째 변수에 의해 **가려졌다(shadowed)** 고 표현 하며, 이는 해당 변수의 이름을 하용할 때 컴파일러가 두 번째 변수를 보게 될 것이라는 의미다.

사실상 두 번째 변수는 첫 번째 것을 가려서, 스스로를 다시 가리거나 스코프가 끝날 때까지 변수명의 사용을 가져가버린다. 아래처럼 변수명을 가릴 수 있다.

```rust
fn main() {
	let x = 5;
	let x = x + 1;

	{
		let x = x * 2;
		println!("The value of x in the inner scope is: {x}");
	}

	println!("The value of x is: {x}");
}
```

**중괄호** 를 사용해서 만들어진 안쪽 스코프 내에 있는 세 번째 `let` 구문 또한 `x`를 가리고 새로운 변수를 만드는데, 이 스코프가 끝나면 섀도잉은 끝나서 `x`는 다시 `6`으로 돌아온다.

`mut`과 섀도잉은 다르다.

1. `let`으로 섀도잉을 하면, 값을 변형하면서 변형이 완료된 후에는 불변으로 유지할 수 있다.
2. `let` 키워드를 사용하여 새로운 변수를 만드는 것이기 때문에 같은 변수명으로 다른 타입의 값을 저장할 수 있다.

```rust
fn main() {
	let spaces = " ";
	let spaces = spaces.len();
}
```

여러 변수명을 사용하지 않고 `spaces`라는 이름을 재사용할 수 있게 해준다.

만약 여기서 `mut`를 사용하려 하면 컴파일 타임 에러가 발생한다.

```rust
fn main() {
	let mut spaces = "    ";
	spaces = spaces.len();
}
```

에러는 변수의 타입을 바꿀 수 없다고 알려준다.

## 데이터 타입

러스트의 모든 값은 특정한 **데이터 타입(data type)** 을 가진다. 타입은 스칼라 타입과 복합 타입, 두 가지 부분 집합으로 나눌 수 있다.

`String`에 `parse`를 사용하여 숫자로 변환했던 경우처럼 여러 가지 타입이 가능한 경우에는 다음과 같이 반드시 타입 명시를 추가해야 한다.

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

### 스칼라 타입

**스칼라(scalar)** 타입은 하나의 값을 표현한다.
- 정수
- 부동소수점 숫자
- 불리언
- 문자
이렇게 네 가지 스칼라 타입이 있다.

#### 정수형
**정수형(integer)** 은 소수점이 없는 숫자다. 다음 표는 러스트에서 사용되는 정수형들을 보여준다. 이 변형 중 어떤 것이라도 정숫값의 타입 선언에 사용할 수 있다.

| 길이      | 부호 있음 (signed) | 부호 없음 (unsigned) |
| ------- | :------------: | :--------------: |
| 8-bit   |       i8       |        u8        |
| 16-bit  |      i16       |       u16        |
| 32-bit  |      i32       |       u32        |
| 64-bit  |      i64       |       u64        |
| 128-bit |      i128      |       u128       |
| arch    |     isize      |      usize       |

부호 있는 혹은 부호 없는 타입이며 명시된 크기를 갖는다. 숫자가 양수라고 생각해도 문제없는 상황에는 부호가 없이 표시한다. 부호 있는 숫자는 2의 보수 형태를 사용해 저장된다.

`isize`와 `usize` 타입은 컴퓨터 환경에 따라 결정된다. `64-bit` 아키텍처이면 64비트를, `32-bit` 아키텍처이면 32비트를 갖게 된다.

정수형 리터럴은 다음 표에서 보이는 것과 같은 형태로 작성할 수 있다. `1_000`과 같이 시각적인 구분을 위해 `_`을 사용할 수 있다.

| 숫자 리터럴    | 예           |
| --------- | ----------- |
| 십진        | 98_222      |
| 16진       | 0xff        |
| 8진        | 0o77        |
| 2진        | 0b1111_0000 |
| 바이트 (u8만) | b'A'        |

어떤 타입의 정수를 사용해야 하는지 확실히 정해진 경우가 아니라면 러스트의 기본값인 `i32`가 일반적으로 좋은 시작 지점이 된다. `isize`나 `usize`는 주로 어떤 컬렉션 종류의 인덱스에 사용된다.

#### 부동소수점 타입

소수점을 갖는 숫자를 가리킨다. 부동소수점 타입은 `f32`와 `f64`로, 각각 32비트와 64비트의 크기를 갖는다. 기본 타입은 f64인데 이유는 현대의 CPU상에서 `f64`가 `f32`와 대략 비슷한 속도를 내면서도 더 정밀하기 때문이다. 모든 부동 소수점 타입은 부호가 있다.

```rust
fn main() {
	let x = 2.0; // f64
	let y: f32 = 3.0; // f32
}
```

#### 수치 연산

러스트는 모든 숫자 타입에 대해 기본 수학 연산 기능을 제공한다.

```rust
fn main() {
	let sum = 5 + 10;

	let difference = 95.5 - 4.3;

	let product = 4 * 30;

	let quotient = 56.7 / 32.2;
	let truncated = -5 / 3;

	let remainder = 43 % 4;
}
```

#### 불리언 타입

```rust
fn main() {
	let t = true;

	let f: bool = false;
}
```

#### 문자 타입

러스트의 `char`는 가장 기본적인 알파벳 타입니다.

```rust
fn main() {
	let c= 'z';
	let z: char = 'Z';
}
```

러스트의 `char`타입은 4바이트 크기이며 유니코드 스칼라값을 표현한다. 이는 `ASCII`보다 훨씬 더 많은 값을 표현할 수 있다는 의미이다. 억양 표시가 있는 문자, 한국어/중국어/일본어 문자, 이모지, 넓이가 0인 공백 문자 모두가 러스트에서는 유효한 `char`값이다.

### 복합 타입

**복합 타입(compound type)** 은 여러 값을 하나의 타입으로 묶을 수 있다. 튜플, 배열, 두 가지 기본 복합 타입이 있다.

#### 튜플 타입
**튜플(tuple)** 은 다양한 타입의 여러 값을 묶어 하나의 복합 타입으로 만드는 일반적인 방법이다. 튜플은 고정된 길이를 갖는다. 한번 선언되면 그 크기를 늘리거나 줄일 수 없다.

괄호 안에 쉼표로 구분해 값들의 목록을 작성해 튜플을 만들 수 있다.

```rust
fn main() {
	let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

튜플은 하나의 복합 요소로 취급된다. 개별 값을 얻어오려면 아래와 같이 패턴 매칭을 하여 튜플값을 해체해서 사용하면 된다.

```rust
fn main () {
	let tup = (500, 6.4, 1);

	let (x, y, z) = tup;

	println!("The value of y is:{y}");
}
```

이를 **구조 해체(destructuring)** 라고 부른다. 점(.)뒤에 접근하고자 하는 값의 인덱스를 쓰는 방식으로도 튜플 요소에 접근할 수 있다.

```rust
fn main() {
	let x: (i32, f64, u8) = (500, 6.4, 1);

	let five_hundred = x.0;

	let six_point_four = x.1;

	let one = x.2;
}
```

아무 값도 없는 튜플은 **유닛(unit)** 이라는 특별한 이름을 갖는다. 이 값과 타입은 모두 ()로 작성되고 빈 값이나 비어 있는 반환 타입을 나타낸다.

#### 배열 타입

튜플과는 달리 배열의 모든 요소는 같은 타입이어야 한다. 러스트의 배열은 고정된 길이를 갖는다.

```rust
fn main() {
	let a = [1, 2, 3, 4, 5];
}
```


힙보다는 스택에 데이터를 할당하고 싶을 때나 항상 고정된 개수의 요소로 이루어진 경우라면 배열이 유용하다. 하지만 배열은 벡터 타입처럼 유연하지는 않다. 벡터는 표준 라이브러리가 제공하는 배열과 유사한 컬렉션 타입인데 크기를 늘리거나 줄일 수 있다. 배열을 이용할지 벡터를 이용할지 잘 모르겠다면, 아마도 벡터를 사용해야 할거다.

다음과 같이 배열의 길이와 타입을 명시적으로 선언할 수 있다.

```rust
fn main() {
	let a:[i32; 5] = [1, 2, 3, 4, 5];
}
```

또한 다음과 같이 대괄호 안에 초깃값과 세미콜론을 쓴 다음 배열의 길이를 적는 방식을 사용해 모든 요소가 동일한 값으로 채워진 배열을 초기화할 수도 있다.

```rust
let a = [3; 5];
```

이는 `let a = [3, 3, 3, 3, 3];`이라고 쓴 것과 똑같지만 좀 더 편리한 방식이다.

#### 배열 요소에 접근하기

배열은 스택에 할당될 수 있는 계산 가능한 고정된 크기의 단일 메모리 뭉치다. 인덱스를 통해 배열 요소에 접근할 수 있다.

```rust
fn main() {
	let a = [1, 2, 3, 4, 5];

	let first = a[0];
	let second = a[1];
}
```

#### 유효하지 않은 배열 요소에 대한 접근

만약 배열의 끝을 넘어선 요소에 접근하려고 하면 성공적으로 컴파일은 되게 된다. 다만 **런타임** 에러를 발생하게 된다.

인덱스가 배열 길이보다 크거나 같을 경우 러스트는 패닉(panic)을 일으키게 된다. 많은 저수준 언어에서는 이러한 검사가 이루어지지 않고, 메모리에 접근이 가능하다. 러스트는 이런 메모리 접근을 허용하고 실행하는 대신 실행을 즉시 종료해 에로로부터 보호해준다.

## 함수

러스트에서는 함수나 변수 이름을 위한 관례로 **스네이크 케이스(snake case)** 방식을 이용한다.

```rust
fn main() {
	println!("Hello world!");

	another_function();
}

fn another_function() {
	println!("Another function");
}
```

여기서 `another_function`이 `main`함수 **이후에** 정의되어 있다는 점에 주목해라. 러스트에서는 함수 위치를 고려할 필요가 없다. 스코프 어딘가에 정의만 되어 있으면 된다.

### 매개변수

함수는 **매개변수**를 가질 수 있다. 이를 통해 인수를 전달할 수 있다.

```rust
fn main() {
	another_function(5);
}

fn another_function(x: i32) {
	println!("The value of x is: {x}");
}
```

함수 시그니처에서는 각 매개변수의 타입을 **반드시** 선언해야 한다.

### 구문과 표현식

함수 본문은 필요에 따라 표현식(expression)으로 끝나는 구문(statement)의 나열로 구성된다.

- **구문**은 어떤 동작을 수행하고 값을 반환하지 않는 명령이다.
- **표현식**은 결괏값을 평가한다.

다음은 구문 하나로 되어있는 `main` 함수다.

```rust
fn main() {
	let y = 6;
}
```

함수 정의도 구문이다. 위 예제는 그 자체로 구문에 해당된다.

구문은 값을 반환하지 않는다. 따라서 아래와 같이 `let` 구문을 다른 변수에 할당하려고 하면 에러가 난다.

```rust
fn main() {
	let x = (let y = 6);
}
```

`let y = 6`구문은 값을 반환하지 않으므로 `x`에 바인딩 시킬 것이 없다. `C`나 `루비`에서는 `x = y = 6`이라고 작성해 `x`와 `y`에 모두 6을 대입할 수 있지만 러스트는 아니다.

작성하는 러스트 코드의 대부분은 표현식이다. 이는 어떤 값을 평가한다. `5 + 6`은 11이라는 값을 평가하는 표현식이다.

`let y = 6`에서 `6`은 값 `6`을 평가하는 표현식이다. 함수를 호출하는 것도, 매크로를 호출하는 것도 표현식이다. 아래 예제처럼 중괄호로 만들어진 새로운 스코프 블록도 표현식이다.

```rust
fn main() {
	let y = {
		let x = 3;
		x + 1
	};

	println!("The value of y is: {y}");
}
```

`x + 1`의 마지막 부분에 세미콜론이 없음에 주의해라. 표현식은 종결을 나타내는 세미콜론을 쓰지 않는다. 만약 표현식 끝에 세미콜론을 추가하면, 표현식은 구문으로 변경되고 값을 반환하지 않게 된다. 이 점을 상기하면서 이후부터 함수의 반환값과 표현식을 살펴보길 바란다.

### 반환값을 갖는 함수

`화살표(->)`를 사용해서 반환 타입을 정의할 수 있다. 반환되는 값을 반드시 명명할 필요는 없다. 러스트에서 함수의 반환값은 함수 본문의 마지막 표현식의 값과 동일하다. `return`키워드와 값을 지정해 함수로부터 일찍 값을 반환할 수 있지만, 대부분의 함수들은 암묵적으로 마지막 표현식값을 반환한다.

```rust
fn five() -> i32 {
	5
}

fn main() {
	let x = five();

	println!("The value of x is: {x}");
}
```

다른 예제도 살펴보자.

```rust
fn main() {
	let x = plus_one(5);

	println!("The value of x is:{x}");
}

fn plus_one(x: i32) -> i32 {
	x + 1
}
```

## 주석

간단한 주석의 예를 보자.

```rust
// hello, world
```

러스트는 `문서화 주석(documentation comment)`라고 불리는 또 다른 주석 형태를 가지고 있는데, 이후 다루도록 한다.

## 제어 흐름

### if 표현식

모든 `if` 표현식은 `if`라는 키워드로 시작하고 그 뒤에 조건이 온다. `if` 표현식의 조건과 관련된 코드 블록은 `match`식의 **갈래(arm)** 와 마찬가지로 갈래로 불리곧 한다.

```rust
fn main () {
	let number = 3;

	if number < 5 {
		println!("condition was true");
	} else {
		println!("condition was false");
	}
}
```

중요한건 조건식이 **반드시** `bool` 이어야 한다. 다음과 같은 방법은 안된다.

```rust
fn main() {
	let number = 3;

	if number {
		println!("number was three");
	}
}
```

자바스크립트 같은 언어와 달리 러스트는 불리언 타입이 아닌 값을 불리언 타입으로 자동 변환하지 않는다. 다음처럼 수정해야 정상적으로 실행된다.

```rust
fn main() {
	let number = 3;

	if number != 0 {
		println!("number was something other than zero");
	}
}
```

#### else if로 여러 조건식 다루기

```rust
fn main() {
	let number = 6;

	if number % 4 == 0 {
		println!("number is divisible by 4");
	} else if number % 3 == 0 {
		pritln!("number is divisible by 3");
	} else if number % 3 == 0 {
		println!("number is divisible by 2");
	} else {
		println!("number is not divisible by 4, 3, 2");
	}
}
```

 `else if ` 표현식을 너무 많이 사용하면 코드가 복잡해질 수 있다. 표현식이 두 개 이상이면 코드를 리팩터링하는 것이 좋다. `match`를 사용할 수 있다.
#### let 구문에서 if 사용하기

`if`는 표현식이기 때문에 변수에 결과를 할당하기 위해 let 구문의 우변에 사용할 수 있다.

```rust
fn main() {
	let condition = true;
	let number = if condition { 5 } else { 6 };

	println!("The value of number is: {number}");
}
```

`if` 표현식의 각 갈래의 결괏값은 같은 타입이어야 한다. 러스트는 컴파일 시점에 `number`라는 변수의 타입이 무엇인지 확실히 알아야 한다. 그래야 컴파일 시점에 `number`가 사용되는 모든 곳에서 해당 타입이 유효한지 검증할 수 있기 때문이다.

### 반복문을 이용한 반복

러스트에는 몇 가지 **반복문(loop)** 가 제공된다.
- loop
- while
- for
라는 세 종류의 반복문이 있다.

#### loop로 코드 반복하기

`loop` 키워드는 그만두라고 명시적으로 알려주기 전까지 코드 블록을 반복 수행하도록 한다.

```rust
fn main() {
	let mut count = 0;
	loop {
		if count >= 5 { break; }
		println!("again!");
		count += 1;
	}
}
```

`break`를 사용해 멈추거나, `continue`를 이용해 반복문의 남은 코드를 넘기고 다음 회차로 넘어가게 할 수 있다.

#### 반복문에서 값 반환하기

`loop`의 용례 중 하나는 어떤 스레드가 실행 완료되었는지 검사하는 등 실패할지도 모르는 연산을 재시도할 때다. 여기서 해당 연산의 결과를 이후의 코드에 전달하고 싶을 수도 있다. 이를 위해서는 루프 정지를 위해 사용한 `break` 표현식 뒤에 반환하고자 하는 값을 넣으면 된다.

```rust
fn main() {
	let mut counter = 8;

	let result = loop {
		counter += 1;

		if counter == 10 {
			break counter * 2;
		}
	};

	println!("The result is {result}");
}
```

#### 루프 라벨로 여러 반복문 사이에 모호함 없애기

루프 안에 루프가 있다면, `break`와 `continue`는 해당 지점의 바로 바깥쪽 루프에 적용된다.

**루프 라벨(loop label)** 을 추가적으로 명시하면 `break`나 `continue`와 함께 이 키워드들이 바로 바깥쪽 루프 대신 라벨이 적힌 특정한 루프에 적용되도록 할 수 있다. 루프 라벨은 반드시 작은 따옴표로 시작해야 한다.

```rust
fn main() {
	let mut count = 0;
	'counting_up: loop {
		println!("count = {count}");
		let mut remaining = 10;

		loop {
			println!("remaining = {remaining}");
			if remaining == 9 {
				break;
			}
			if count == 2 {
				break 'counting_up;
			}
			remaining -= 1;
		}

		count += 1;
	}
	println!("End count = {count}");
}
```

#### while을 이용한 조건 반복문

조건이 `true`인 경우 계속 반복한다.

```rust
fn main() {
	let mut number = 3;

	let result = while number != 0 {
		println!("{number}!");

		number -= 1;

	}

	println!("LIFTOFF!!!");
}
```

#### for를 이용한 컬렉션에 대한 반복문

```rust
fn main() {
	let a = [10, 20, 30, 40, 50];

	for element in a {
		println!("the value is: {element}");
	}
}
```

`for`루프를 사용하면 배열 내 값의 개수를 변경시키더라도 수정해야 할 다른 코드를 기억해둘 필요가 없어진다.

이러한 안정성과 간편성 덕분에 `for` 반복문은 러스트에서 가장 흔하게 사용되는 반복문 구성 요소다. 표준 라이브러리가 제공하는 `Range` 타입을 사용하면 특정 횟수만큼의 반복문을 구현할 수 있다.

다음처럼 할 수 있다. `rev`메서드는 범윗값을 역순으로 만들어 준다.

```rust
fn main() {
	for number in (1..4).rev() {
		println!("{number}");
	}
	println!("LIFTOFF!!!");
}
```

> [!note] [start..end]에서 `end`값은 포함되지 않는다.
> 즉 1보다 크거나 같고 4보다 작은 범위를 생성한다는 의미다.

#Rust