
소유권은 러스트에서 가장 독특한 기능이며 언어 전반에 깊은 영향을 끼친다. 소유권은 러스트가 가비지 컬렉터 없이 메모리 안정성을 보장하도록 해주므로, 소유권이 어떻게 작동하는지를 이해하는 것은 중요하다.

## 소유권이란?

**소유권(ownership)** 러스트 프로그램의 메모리 관리법을 지배하는 규칙 모음이다. 다른 언어들과 달리 러스트는 소유권이라는 시스템을 만들고, 컴파일러가 컴파일 중에 검사할 여러 규칙을 정해 메모리를 관리하는 방식이다.

> [!info] 스택 영역과 힙 영역
> 러스트 같은 시스템 프로그래밍 언어에서는 값을 스택에 저장하는냐 힙에 저장하느냐의 차이가 프로그램의 작동 및 프로그래머의 의사 결정에 훨씬 큰 영향을 미친다.
> 
> **스택** 
> 값이 들어온 순서대로 저장하고, 역순으로 제거 (last in, first out)한다.
> 스택에 저장되는 데이터는 모두 명확하고 크기가 정해져 있어야 한다. 컴파일 타임에 크기를 알 수 없거나, 크기가 변경될 수 있는 데이터는 스택 대신 힙에 저장되어야 한다.
> 
> **힙**
> 힙은 스택보다 복잡하다. 데이터를 힙에 넣을 때 다음의 일이 일어난다.
> 
> 1. 먼저 저장할 공간이 있는지 운영체제에 확인한다. 
> 2. 메모리 할당자는 커다란 힙 영역에서 어떤 빈 지점을 찾는다.
> 3. 해당 지점에 사용 중이라고 표시한다.
> 4. 해당 지점을 가리키는 **포인터(pointer)** 를 반환한다.
> 
> 이 과정을 **힙 공간 할당(allocating on the heap)**, 줄여서 **할당(allocation)** 이라고 한다(스택에 값을 푸시하는 것은 할당이라 부르지 않는다). 포인터는 크기가 정해져 있어 스택에 저장할 수 있지만, 포인터가 가리키는 실제 데이터를 사용하고자 할 때는 포인터를 참조해 해당 포인터가 가리키는 위치로 이동하는 과정을 거쳐야 한다.
> 
> 스택 영역은 메모리 할당자가 새로운 데이터를 저장할 공간을 찾을 필요가 없이 항상 스택의 가장 위에 데이터를 저장하면 되기 때문에 빠르다.
> 
> 힙 영역은 포인터가 가리키는 곳을 찾아가는 과정으로 인해 느려진다.
> 
> 우리가 함수를 호출하면, 호출한 함수에 넘겨준 값(값 중엔 힙 영역의 데이터를 가리키는 포인터도 있을 수 있다)과 해당 함수의 지역 변수들이 스택에 푸시된다. 그리고 이 데이터들은 함수가 종료될 때 팝된다.
> 
> 코드 어느 부분에서 힙의 어떤 데이터를 사용하는지 추적하고, 힙에서 중복되는 데이터를 최소화하고, 쓰지 않는 데이터를 힙에서 정리해 영역을 확보하는 등의 작업은 모두 소유권과 관련되어 있다. 즉, 소유권을 한번 이해하고 나면 스택, 힙 영역으로 고민할 일이 줄어들 거란 뜻이다.
> 
> 소유권의 주요 목표가 힙 데이터의 관리라는 점을 알고 있으면 소유권의 작동 방식을 이해하는 데 도움이 된다.

### 소유권 규칙

수유권 규칙부터 알아보자. 계속해서 다음 규칙을 명심해라.

- 러스트에서, 각각의 값은 **소유자(owner)** 가 정해져 있다.
- 한 값의 소유자는 하나다.
- 소유자가 스코프 밖으로 벗어날 때, 값은 벼려진다(dropped).

### 변수의 스코프

스코프란, 프로그램 내에서 아이템이 유효한 번위를 의미한다. 다음과 같은 변수가 있다고 가정해보자.

```rust
fn main() {
	let s = "hello";
}
```

이 변수는 선언된 시점부터 현재의 **스코프**를 벗어날 때까지 유효하다.

중요한 점은 두가지다.

1. `s`가 스코프 **내에** 나타나면 유효하다.
2. 유효 기간(생명 주기)은 스코프 **밖으로** 벗어나기 전까지다.

이제 `String` 타입을 탐구해가며 본격으로 소유권을 이해해보자.

### String 타입

명확한 크기를 가지고 있다면, 전부 스택에 저장되고 스코프를 벗어날 때 제거되며, 코드의 다른 쪽의 스코프 내에서 같은 값을 사용하려 할 때 새 독립적인 인스턴스를 빠르고 간단하게 만들어 낼 수 있다. 지금은 힙에 저장되면서 러스트의 데이터 정리 과정을 알아보는데 적합한 타입이 필요하다. `String`이 그 좋은 예다.

여기서는 `String`의 소유권과 관련된 부부에만 집중한다. 

하드코딩된 방식의 문자열 리터럴은 편리하지만 불변성(immutable)을 지니기에 변경할 수 없다. 그래서 러스트는 또 다른 문자열 타입인 `String`을 제공한다. 이 타입은 힙에 할당된 데이터를 다루기 때문에, 컴파일 타임에 크기를 알 수 없는 텍스트도 저장할 수 있다. 다음과 같이 생성 가능하다.

```rust
fn main() {
	let s = String::from("hello");
}
```

이중 콜론 `::`은 우리가 함수를 사용할 때 `string_from` 같은 함수명을 사용하지 않고 `String` 타입에 있는 특정된 `from` 함수라는 것을 지정할 수 있게 해주는 네임스페이스 연산자다. 이후에 더 자세히 알아보자.

이 `String` 문자열은 변경이 가능하다.

```rust
fn main() {
	let mut s = String::from("hello");

	s.push_str(", world!"); // push_str()이 문자열에 리터럴을 추가한다.

	println!("{}", s); // 이 줄이 'hello, world!'를 출력한다.
}
```

문자열 리터럴은 변경 불가능하고 `String`은 변경 가능한 이유가 뭘까? 차이점은 각 타입의 메모리 사용 방식에 있다.

### 메모리와 할당

문자열 리터럴은 컴파일 타임에 내용을 알 수 있으므로, 텍스트가 최종 실행 파일에 하드코딩 된다. 빠르고 효율적이지만, 문자열이 변하지 않을 경우에만 사용할 수 있다.

반면 `String` 타입은 힙에 메모리를 할당하는 방식을 사용한다. 그렇기에 텍스트 내용 및 크기를 변경할 수 있다. 하지만 이는 다음을 의미하기도 한다.

- 실행 중 메모리 할당자로부터 메모리를 요청해야한다.
- `String` 사용을 마쳤을 때 메모리를 해제할(즉, 할당자에게 메모리를 반납할) 방법이 필요하다.

이 중 첫 번째는 해결했다. `String::from`을 호출하게 되면 필요한 만큼 메모리를 요청하도록 구현되어 있다. 프로그래밍 언어 사이에서 일반적으로 사용하는 방식이다.

하지만 두 번째는 다르다. **가비지 컬렉터(garbage collector, GC)** 를 갖는 언어에서는 GC가 사용하지 않는 메모리를 찾아 없애주므로 프로그래머가 신경 쓸 필요 없다. GC가 없는 대부분의 언어에서는 할당받은 메모리가 필요 없어지는 지점을 프로그래머가 직접 찾아 메모리 해제 코드를 작성해야 한다. 다만 메모리 allocate(할당)과 free(해제)를 직접 다루는 작업은 역사적으로 어려운 프로그래밍 문제였다.

러스트에서는 이 문제를 변수가 자신이 소속된 스코프를 벗어나는 순간 자동으로 메모리를 해제하는 방식으로 해결했다. 다음 예시를 보자.

```rust
fn main() {
	let s = String::from("hello"); // s는 이 지점부터 유요하다.

	// s를 가지고 무언가를 한다.
} // 스코프가 종료되었고 s가 더 이상 유효하지 않다.
```

`s`가 스코프 밖으로 벗어나면 러스트가 `drop`이라는 특별한 함수를 호출한다. 이 함수는 해당 타입을 개발한 개발자가 직접 메모리 해제 코드를 작성해 넣을 수 있게 되어있으며, 위의 경우 `String`개발자가 작성한 메모리 해제 코드가 들어가있을거다. `drop`은 닫힌 중괄호가 나타나는 지점에서 자동으로 호출된다.

#### 변수와 데이터 간 상호작용 방식: 이동

러스트에서는 동일한 데이터에 여러 변수가 서로 다른 방식으로 상호작용할 수 있다.

```rust
fn main() {
	let x = 5;
	let y = x;
}
```

이 코드는 다음의 일을 한다:

- 5를 x에 바인딩한다.
- x값의 복사본을 만들어 y에 바인딩 한다.

정수형 값은 크기가 정해진 단순한 값이다. 그렇기에 두 5값은 스택에 푸시된다.

앞선 예제를 `String`으로 바꿔 보자.

```rust
fn main() {
	let s1 = String::from("hello");
	let s2 = s1;
}
```

이번엔 전혀 다른 방식으로 작동한다.

다음 그림을 보자.
![[Pasted image 20240607115800.png]]
`String`은 그림 좌측 처럼 세 부분으로 이루어져 있다. 문자열 내용이 들어 있는 힙 메모리를 가리키는 포인터, 문자열 길이, 메모리 용량이다. 이 데이터는 스택에 저장된다. 우측은 문자열 내용이 들어 있는 힙 메모리다.

문자열 길이와 메모리 용량의 차이점이 궁금할 수 있다.

- 문자열 길이: `String`의 내용이 현재 사용하고 있는 메모리를 바이트 단위로 나타낸 것
- 메모리 용량: 메모리 할당자가 `String`에 할당한 메모리 양

이제 `s2`에 `s1`을 대입 하면 어떻게 동작하는지 살펴 보자. `s2`에 `s1`을 대입하면 `String` 데이터가 복사된다. 이때 데이터는 스택에 있는 포인터와, 길이, 용량값을 말한다. 힙 영역의 데이터가 복사되지 않는다. 즉 다음 그림과 같은 구조를 가지게 된다.

![[Pasted image 20240607120625.png]]

앞서 변수가 스코프 밖으로 벗어날 때 러스트에서 자동으로 `drop` 함수를 호출해 해당 변수가 사용하는 힙 메모리를 제거한다고 했다. 만약 위 그림처럼 두 포인터가 같은 곳을 가리키면 어떻게 될까? `s1`, `s2`가 스코프 밖으로 벗어날 때 각각 메모리를 해제하게 되면 **중복 해제(double free)** 에러가 발생할거다.

메모리 안정성을 보장하기 위해, 러스트는 `let s2 = s1;` 라인 뒤로는 `s1`이 더 이상 유효하지 않다고 판단한다. 이로써 러스트는 `s1`이 스코프를 벗어나더라도 아무것도 해제할 필요가 없어진다.

즉 다음과 같은 코드는 에러를 발생시킨다.

```rust
fn main() {
	let s1 = String::from("hello");
	let s2 = s1;

	println!("{}, world!", s1); // 유효하지 않은 참조자의 사용 감지했다는 에러가 발생
}
```

다른 프로그래밍 언어에서 **얕은 복사(shallow copy)**, **깊은 복사(deep copy)** 라는 용어를 들어봤다면, 그렇게 생각할 수 있다. 러스트에서는 기존의 변수를 무효화하기 때문에 이를 얕은 복사가 아닌 **이동(move)** 라고 하고, 따라서 앞선 코드는 `s1`은 `s2`로 **이동되었다**라고 표현한다.

![[Pasted image 20240607172646.png]]

러스트는 절대 자동으로 '깊은' 복사로 데이터를 복하는 일이 없다. 따라서, 러스트가 **자동으로** 수행하는 모든 복사는 런타임 성능 측면에서 효율적이라 볼 수 있다.

#### 변수와 데이터 간 상호작용 방식: 클론

`String`의 힙 데이터까지 깊이 복사하고 싶을 때 `clone`이라는 공용 메서드를 사용할 수 있다.

```rust
fn main() {
	let s1 = String::from("hello");
	let s2 = s1.clone();

	println!("s1 = {}, s2 = {}", s1, s2);
}
```

#### 스택에만 저장되는 데이터: 복사

아직 다루지 않은 부분이 있다. 다음 코드를 보자.

```rust
fn main() {
	let x = 5;
	let y = x;

	println!("x = {}, y = {}", x, y);
}
```

이 코드는 정상적으로 동작한다. 이전과는 다른데 그 이유는 정수형 등 컴파일 타임에 크기가 고정되는 타입은 모두 스택에 저장되기 때문이다. 스택에 저장되니, 복사본을 빠르게 만들 수 있고, 따라서 굳이 `y`를 생성하고 나면 `x`를 무효화할 필요가 없다.

러스트에는 정수형처럼 스택에 저장되는 타입에 붙여놓을 수 있는 **Copy** 트레이트가 있다. 만약 어떤 타입에 이 **Copy** 트레이트가 구현되어 있다면, 이 타입의 변수는 사용되어도 이동되지 않고 자명하게 복사되며, 대입 연산 후에도 사용할 수 있다.

하지만 구현하려는 타입이나, 구현하려는 타입 중 일부분에 **Drop** 트레이트가 구현된 경우엔 **Copy** 트레이트를 애너테이션(annotation)할 수 없다.

그렇다면 **Copy** 가능한 타입은 뭘까? 일반적으로 단순한 스칼라값의 묶음은 **Copy** 가능하고, 할당이 필요하거나 리소스의 일종인 경우엔 불가능하다. 다음은 **Copy** 가능한 타입 목록 중 일부다.

- 모든 정수형 타입(예: u32)
- boolean 타입
- 부동소수점 타입(예: f64)
- 문자 타입 char
- **Copy** 가능한 타입만으로 구성된 튜플

### 소유권과 함수

함수로 값을 전달하는 메커니즘은 변수에 값을 대입할 때와 유사하다. 함수에 변수를 전달하면 대입 연산과 마찬가지로 이동이나 복사가 일어난다.

```rust
fn main() {
	let s = String::from("hello"); // s가 스코프 안으로 들어온다.

	takes_ownership(s); // s의 값이 함수로 이동된다.

	let x = 5; // x가 스코프 안으로 들어온다.

	makes_copy(x); // x가 함수로 이동될 것이다.
				   // 다만 i32는 Copy이므로 앞으로 계속 x를 사용할 수 있다.
				   
} // x, s가 스코프 밖으로 벗어난다. 그러나 s의 값이 이동되었으므로 별다른 일이 발생하지 않는다.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어온다.
	println!("{}", some_string);
} // 여기서 some_string이 스코프 밖으로 벗어나고 'drop'이 호출되며 메모리가 해제된다.

fn makes_copy(some_integer: i32) { // some_integer가 스코프 안으로 들어온다.
	println!("{}", some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어난다. 별다른 일이 발생하지 않는다.
```

`takes_ownership`함수를 호출한 이후에 `s`를 사용하려 하면 컴파일 타임 에러가 발생한다.

### 반환값과 스코프

소유권은 값을 반환하는 과정에서 이동한다. 다음을 살펴보자.

```rust
fn main() {
	let s1 = gives_ownership(); // gives_ownership이 자신의 반환값을 s1로 이동시킨다.

	let s2 = String::from("hello"); // s2가 스코프 안으로 들어온다.

	let s3 = takes_and_gives_back(s2); // s2는 takes_and_gives_back으로 이동된다.
									   // 이 함수 또한 자신의 반환값을 s3로 이동시킨다.
} // 여기서 s3가 스코프 밖으로 벗어나면서 버려진다. s2는 이동되어서 아무 일도 일어나지 않는다.
  // s1은 스코프 밖으로 벗어나고 버려진다.

fn gives_ownership() -> String { // gives_ownership은 자신의 반환값을
								 // 자신의 호출자 함수로 이동시킨다.

	let some_string = String::from("yours"); // some_string이 스코프 안으로 들어온다.

	some_string // some_string이 반한되고 호출자 함수 쪽으로 이동한다.

}

// 이 함수는 String을 취하고 같은 것을 반환한다.
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프 안으로
													  // 들어온다.
	a_string // a_string이 반환되고 호출자 함수 쪽으로 이동한다.
}
```

상황은 다양하더라도 소유권 규칙은 언제나 동일하다. 어떤 값을 다른 변수에 대입하면 값이 **이동**하고, 힙에 데이터를 갖는 변수가 스코프를 벗어나면, 사전에 해당 데이터가 이동해 소유권이 다른 변수에 이동되지 않은 이상 `drop`에 의해 데이터가 제거된다.

함수에 넘겨줄 값을 이후에도 계속 쓰려면 어떻게 할 수 있을까? 다음처럼 가능하다.

```rust
fn main() {
	let s1 = String::from("hello");

	let (s2, len) = calculate_length(s1);

	println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
	let length = s.len();

	(s, length)
}
```

이는 조금 번거롭다. 러스트에는 소유권 이동 없이 값을 사용할 수 있는 **참조자**라는 기능을 가지고 있다.

## 참조와 대여

위 처럼 하는 대신 **참조자**를 사용하면 굳이 `s`를 반환해 `s2`에  할당하지 않아도 된다.

```rust
fn main() {
	let s1 = String::from("hello");

	let len = calculate_length(&s1);

	println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
	s.len()
}
```

튜플 코드가 사라졌다. `s1`대신 `&s1`을 전달하고, 매개변수 타입에 `String` 대신 `&String`을 사용했다.

> [!note] &를 이용한 참조의 반대는 **역참조(dereferencing)**라 한다. 역참조 기호는 *이며 이후 다룰 예정이다.

이처럼 참조자를 만드는 행위를 **대여(borrowing)** 라고 한다. 만약 빌린 값을 수정하면 어떻게 될까?

```rust
fn main() {
	let s = String::from("hello");

	change(&s);
}

fn change(some_string: &String) {
	some_string.push_str(", world");
}
```

이 코드는 동작하지 않는다. 변수가 기본적으로 불변성을 지니듯, 참조자도 마찬가지로 참조하는 것을 수정할 수 없다.

### 가변 참조자

**가변 참조자(mutable reference)** 를 사용하는 식으로 수정하면 에러를 없앨 수 있다.

```rust
fn main() {
	let mut s = String::from("hello");

	change(&mut s);
}

fn change(some_string: &mut String) {
	some_string.push_str(", world")
}
```

1. 우선 `s`를 `mut`로 변경한다.
2. `chage`함수를 호출하는 곳에서 `&mut s`로 가변 참조자를 생성해 전달한다.
3. `some_string: &mut String`으로 수정한다.

가변 참조자는 한 가지 큰 제약이 있다.

*"어떤 값에 대한 가변 참조자가 있다면, 그 값에 대한 참조자는 더 이상 만들 수 없다."*

값의 변경에 대한 원활한 제어를 제공하기 위해서다. 장애물 처럼 느껴질 수 있지만 이 제약 덕분에 러스트는 컴파일 타임에 **데이터 경합(data race)** 을 방지할 수 있다. 데이터 경합이란 다음 세 가지 상황이 겹칠 때 일어나는 특수한 경합 조건(race condition)이다.

- 둘 이상의 포인터가 동시에 같은 데이터에 접근
- 포인터 중 하나 이상이 데이터에 쓰기 작업을 수행
- 데이터 접근 동기화 메커니즘이 없음

데이터 경합은 정의되지 않은 동작을 일으키고, 런타임에 문제 진단 및 수정이 어렵다.

물론 중괄호로 새로운 스코프를 만들어, 가변 참조자를 여러개 만들어서 **동시에** 존재하는 상황을 회피하는 방법이 있다.

```rust
fn main() {
	let mut s = String::from("hello");

	{
		let r1 = &mut s;
	} // 여기서 r1이 스코프 밖으로 벗어나며, 따라서 아무 문제 없이 새 참조자를 만들 수 있다.

	let r2 = &mut s;
}
```

가변 참조자와 불변 참조자를 혼용할 때도 유사한 규칙이 적용된다. 다음 코드는 컴파일 에러를 발생시킨다.

```rust
fn main() {
	let mut s = String::from("hello");

	let r1 = &s; // 문제없음
	let r2 = &s; // 문제없음
	let r3 = &mut s; // 큰 문제

	println!("{}, {}, and {}", r1, r2, r3);
}
```

즉, 어떤 값에 대한 불변 참조자가 있는 동안 같은 값의 가변 참조자를 만드는 것 **또한** 불가능하다.

참조자는 정의된 지접부터 시작해 해당 참조자가 마지막으로 사용된 부분까지 유효하다. 다음처럼 사용하면 에러를 해결할 수 있다.

```rust
fn main() {
	let mut s = String::from("hello");

	let r1 = &s;
	let r2 = &s;

	println!("{} and {}", r1, r2);

	let r3 = &mut s;

	println!("{}", r3);
}
```

위 코드는 문제가 없다. 불변 참조자 `r1`, `r2`의 스코프는 자신들이 마지막으로 사용된 `println!`이후로 종료된다. 그러므로 가변 참조자 `r3` 가 생성될 때는 스코프가 겹치지 않아 문제가 없다는걸 컴파일러는 안다.

### 댕글링 참조

**댕글링 모인터(dangling pointer)** 란, 어떤 메모리를 가리키는 포인터가 남아 있는 상황에서 일부 메모리를 해제해버림으로써, 다른 개체가 할당받았을지도 모르는 메모리를 참조하게 된 포인터를 말한다.

포인터가 있는 언에서는 자칫 잘못하면 이 댕글링 포인터를 만들기 쉽다.

하지만 러스트는 어떤 데이터의 참조자를 만들면, 해당 참조자가 스코프를 벗어나기 전에 데이터가 먼저 스코프를 벗어나는지 컴파일러에서 확인하여 댕글링 참조가 생성되지 않도록 보장한다.

```rust
fn main() {
	let reference_to_nothing = dangle();
}

fn dangle() -> &String {
	let s = String::from("hello");

	&s
}
```

아직 다루지 않은 라이프타임이라는 내용의 에러 메시지가 등장한다. 이는 이후 알아보고 핵심 이유는 다음과 같다.

> 이 함수는 빌린 값을 반환하고 있으나, 빌린 실젯값이 존재하지 않는다.

`dangle`함수에서 어떤 일이 일어나는지 단계별로 보자.

```rust
fn dangle() -> &String { // dangle은 String의 참조자를 반환한다.
	let s = String::from("hello"); // s는 새로운 String이다.

	&s // String s의 참조자를 반환한다.
} // 여기서 s는 스코프 밖으로 벗어나고 벼러진다. 해당 메모리는 해제된다.
```

이는 유효하지 않은 `String`을 가리키는 참조자를 반환하는 행위다. 이런 경우엔 `String`을 직접 반환해야 한다.

```rust
fn dangle() -> String {
	let s = String::from("hello");

	s
}
```

### 참조자 규칙

참조자에 대해 배운 내용을 정리해보자.

- 단 하나의 가변 참조자만 갖거나, 여러 개의 불변 참조자를 가질 수 있다.
- 참조자는 항상 유요해야 한다.

## 슬라이스 타입

**슬라이스(slice)** 는 컬렌션을 통째로 참조하는 것이 아닌, 컬렉션의 연속된 일련의 요소를 참조하도록 해준다. 슬라이스는 참조자의 일종으로서 소유권을 갖지 않는다.

공백 문자로 구분된 단어들의 문자열을 입력받아 해당 문자열의 첫 번째 단어를 반환하는 함수를 작성해보자.

```rust
fn first_word(s: &String) -> usize {
	let bytes = s.as_bytes();

	for (i, &item) in bytes.iter().enumerate() {
		if item == b' ' {
			return i;
		}
	}

	s.len()
}
```

이 코드는 나눠서 살펴보겠다. 우선 `String`을 하나하나 쪼개서 해당 요소가 공백값인지 확인한다.

```rust
let bytes = s.as_bytes();
```

그 다음 바이트 배열에 사용할 반복자(iterator)를 `iter` 메서드로 생성했다.

```rust
for (i, &item) in bytes.iter().enumerate() {}
```

`iter` 메서드는 컬렉션의 각 요소를 반환하고, `enumerate` 메서드는 `iter`의 각 결괏값을 튜플로 감싸 반환한다. 이때 반환하는 튜플은 `(index, ref of element)`의 형태다.

`for` 반복문 내에서는 바이트 리터럴 문법으로 공백 문자를 나타내는 바이트를 찾고, 찾으면 해당 위치를 반환한다. 찾지 못했을 땐 `s.len()`으로 문자열의 길이를 반환한다.

```rust
for (i, &item) in bytes.iter().enumerate() {
	if item == b' ' {
		return i;
	}

	s.len
}
```


이제 문자열에서 첫 번째 단어 끝의 인덱스를 찾는 방법이 생겼다. `usize`를 반환하고 있는데, 이는 `&String`의 콘텍스트에서만 의미 있는 숫자다. 다음을 살펴보자.

```rust
fn main() {
	let mut s = String::from("hello woirld");

	let word = first_word(&s); // word는 값 5를 받는다.

	s.clear(); // 이 코드는 String을 비워서 ""으로 만든다.

	// 여기서 word에는 여전히 5가 들어 있지만, 이 5를 의미있게 쓸 수 있는 문자열이 없다.
	// word는 이제 전혀 유효하지 않다.
}

fn first_word(s: &String) -> usize {
	let bytes = s.as_bytes();

	for (i, &item) in bytes.iter().enumerate() {
		if item == b' ' {
			return i;
		}
	}

	s.len()
}
```

`word`를 사용해 단어를 추출하는 코드를 작성해도 `word` 는 `s`와 분리되어 있기 때문에 여전히 `&String` 컨텍스트 내에서만 유효하다. `word`에 담긴 값을 사용해 `s`에서 첫 단어를 추출하는 데 사용할 경우, 버그를 유발할 수도 있다. `s`의 내용물을 변경 되었기 때문이다.

> [!info] 코드 때문에 이해가 잘 안간다!
> 그냥 그러려니 하자. 문자열 슬라이스에 대한 이해를 돕기 위한 예제이다. 이해하려 하지말고 다음으로 넘어가자.

### 문자열 슬라이스

문자열 슬라이스는 `String`의 일부를 가리키는 참조자를 말한다.

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

만드는 방식은 `String` 참조자와 유사하지만, `hello`는 추가적인 `[0..5]`으로 명시된 `String`의 일부를 가리키는 참조자다.

![[Pasted image 20240607172712.png]]

`..` 범위 표현법은 인덱스 0부터 시작하는 경우, 앞의 값을 생략할 수 있다.

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

마찬가지로, `String` 맨 마지막 바이트까지 포함하는 슬라이스는 뒤의 값을 생략할 수 있다.

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

앞뒤 모두 생략하면 전체 문자열이 슬라이스로 생성된다.

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

여태 다룬 내용으로 `first_word` 함수가 슬라이스를 반환하도록 재작성해보자. 문자열 슬라이스를 나타내는 타입은 `&str`로 작성한다.

```rust
fn first_word(s: &String) -> &str {
	let bytes = s.as_bytes();

	for (i, &item) in bytes.iter().enumerate() {
		if item == b' ' {
			return &s[..i];
		}
	}

	&s[..]
}
```

사용법이 훨씬 직관적이어졌다. 첫 단어의 끝부분 인덱스를 찾은 이후 문자열이 비워지면 찾아낸 인덱스가 쓸어없어지는 문제도 해결했다. 이제는 컴파일러가 `String`을 가리키는 참조자의 유효함을 보증한다. 기존 코드는 논리적으로 맞지 않음에도 불구하고 에러가 나타나지 않았다. 하지만 이제 `word`를 반환받고 `s.clear()`를 한다면 에러가 발생된다.

```rust
fn main() {
	let mut s = String::from("hello world");

	let word = first_word(&s);

	s.clear(); // 에러!

	println!("the first word is: {}", word);
}
```

대여 규칙 중 특정 대상의 불변 참조자가 이미 존재할 경우 가변 참조자를 만들 수 없다는 규칙이 있다. `clear` 함수는 `String`의 길이를 변경해야 하니 가변 참조자가 필요하다. `clear` 호출 이후 `prinln!`에서 `word`가 사용되므로 불변 참조자는 그 지점까지 활성되어있어야 한다.

#### 슬라이스로서의 문자열 리터럴

문자열 리터럴은 바이너리 내에 저장된다.

```rust
let s = "hello, world!";
```

여기서 `s`는 바이너리의 특정 지점을 가리키는 슬라이스다. `&str` 타입이다. `&str`은 불변 참조자이므로, 문자열 문자열 리터럴을 왜 변경할 수 없는지에 대한 의문도 풀린다.

#### 문자열 슬라이스를 매개변수로 사용하기

리터럴과 `String`의 슬라이스를 만들 수 있다는 걸 알고 나면 `first_word` 함수 정의를 다음과 같이 작성할 수 있다.

```rust
fn first_word(s: &String) -> &str {}
```

좀 더 경험이 많다면 `&String`값과 `&str` 값 모두 사용 가능한 함수를 작성할거다.

```rust
fn first_word(s: &str) -> &str {}
```

문자열 슬라이스라면 바로 인수로 전달할 수 있다. `String`이라면 `String`의 슬라이스 혹은 `String`에 대한 참조자를 전달할 수 있다. 이러한 유연성은 **역참조 강제(deref coercion)** 기능을 이용한다. 이는 나중에 다룬다.

`String`에 대한 참조자 대신 문자열 슬라이스를 배개변수로 하는 함수를 정의하면 기능 면에서 손해보지 않으면서 `API`를 더 일반적이고 유용하게 만들어준다.

```rust
fn main() {
	let my_string = String::from("hello world");

	// 'first_word' 는 'String'의 일부 혹은 전체 슬라이스에 대해 작동한다.
	let word = first_word(&my_string[0..6]);
	let word = first_word(&my_string[..]);

	// 또한 'first_word"는 'String'의 전체 슬라이스와 동일한 'String'의
	// 참조자에 대해서도 작동한다.
	let word = first_word(&my_string);

	let my_string_literal = "hello world";

	// 'first_word'는 문자열 리터럴의 일부 혹은 전체 슬라이스에 대해 작동한다.
	let word = first_word(&my_string_literal[0..6]);
	let word = first_word(&my_string_literal[..]);

	// 문자열 리터럴은 *곧* 문자열 슬라이스다.
	let word = first_word(my_string_literal);
}
```

### 그 외 슬라이스

문자열 슬라이스는 문자열에만 특정되어 있다. 하지만 더 범용적인 슬라이스 타입도 존재한다.

```rust
let a = [1, 2, 3, 4, 5];
```

배열 일부를 참조하고 싶다면 다음과 같이 할 수 있다.

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

이 슬라이스는 `&[i32]` 타입이다. 작동 방식은 문자열 슬라이스와 동일한다.

#Rust 