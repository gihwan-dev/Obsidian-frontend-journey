러스트 표준 라이브러리에는 **컬렌션(collection)** 이라 불리는 유용한 데이터 구조들이 여러 개 포함되어 있다. 내장된 배열이나 튜플 타입과는 달리, 이 컬렉션들이 가리키고 있는 데이터들은 힙에 저장된다. 이 장에서는 자주 사용되는 세 가지 컬렉션에 대해 다뤄본다.

- **벡터(vector)** 는 여개의 값을 서로 붙어 있제 저장할 수 있도록 해준다.
- **문자열(string)** 은 문자의 모음이다. 이번 장에서 더 깊게 다뤄본다.
- **해시 맵(hash map)** 은 어떤 값을 특정한 키와 연관지어주도록 해준다.

## 벡터에 여러 값의 목록 저장하기

벡터는 같은 타입의 값만을 저장할 수 있다.

### 새 벡터 만들기

**초기 값이 없는 경우**
```rust
let v: Vec<i32> = Vec::new();
```

**초기 값이 있는 경우**
```rust
let v = vec![1, 2, 3];
```

### 벡터 업데이트하기

**push**
```rust
let mut v = Vec::new();

v.push(5);
v.push(4);
v.push(3);
```

어떤 변수의 값을 변경하려면 `mut` 키워드를 사용해 가변 변수로 만들어 줘야 하낟. 타임을 추론하기 때문에 제네릭 타입을 명시할 필요가 없다.

### 벡터 요소 읽기

인덱싱과 `get` 메서드 두 가지가 있다.

```rust
fn main() {
	let v = vec![1, 2, 3, 4, 5];

	let third: &i32 = &v[2];
	println!("The third element is {third}");

	let third: Option<&i32> = v.get(2);
	match third {
		Some(third) => println!("The third element is {third}"),
		None => println!("There is no third element."),
	}
}
```

`&`와 `[]`를 사용하면 인덱스값에 위치한 요소의 참조자를 얻게 된다.

`get` 함수에 인덱스를 매개변수로 넘기면, `match`를 통해 처리할 수 있는 `Option<&T>`를 얻게 된다.

어떤걸 사용하는게 좋을까? 다음을 보자.

```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

인덱스로 접근한 방법은 패닉을 발생시키며 프로그램이 종료된다. `get`을 이용한 접근은 패닉 없이 `None`이 반환된다. 다만 `Some`과 `None`에 대한 처리가 필요하다.

사용자의 관점에서 2번째 방법이 친화적이다. 프로그램이 종료되지 않고 에러를 처리할 수 있기 때문이다.

프로그램에 유요한 참조자가 있다면, 대여 검사기(borrow checker)가 소유권 및 대여 규칙을 짐행해 이 참조자가 벡터의 내용물로부터 얻은 다른 참조자들이 계속 유효하게 남아있도록 보장한다.

같은 스코프에서는 가변 참조자와 불변 참조자를 가질 수 없다는 규칙을 상기해라.

다음 예제를 보자.

```rust
fn main() {
	let mut v = vec![1, 2, 3, 4, 5];

	let first = &v[0];

	v.push(6);

	println!("The first element is: {first}");
}
```

위 코드는 에러를 발생시킨다.

벡터는 모든 요소가 서로 붙어서 메모리에 저장된다. 그리고 새로운 요소를 벡터 끝에 추가할 경우, 현재 벡터 메모리 위치에 새로운 요소를 추가할 공간이 없다면, 다른 넉넉한 곳에 메모리를 새로 할당하고 기존 요소를 새로 할당한 공간에 복사한다. 이 경우, 기존 요소의 참조자는 해제된 메모리를 가리키게 되기 때문에, 이러한 상황을 대여 규칙으로 막아둔 것이다.

> [!success] 다른 참조자들이 있는 경우 가변 참조자를 사용할 수 없다. 가변 참조자가 정의되면 가변 참조자만 존재해야 한다.
> 

### 벡터값에 대해 반복하기

**for 루프**
```rust
fn main() {
	let v = vec![100, 32, 57];
	for i in &v {
		println!("{i}");
	}
}
```

요소를 변경하기 위해 가변 벡터의 각 요소에 대한 가변 참조자로 반복 작업을 할 수 있다.

```rust
fn main() {
	let mut v = vec![1, 2, 3, 4, 5];
	for i in &mut v {
		*i += 50;
	}
}
```

가변 참조자가 가리키는 값을 수정하려면 `*` 역참조 연산자로 `i`의 값을 얻어야 한다.

> [!question] `i`는 현재 벡터의 요소에 대한 참조 이기 때문에?
> `C++` 에서와 마찬가지로 `i`는 현제 벡터 요소에 대한 참조 이기 때문에 값을 얻으려면 `*`로 값을 얻어야 하는 것 같다! [[15. 포인터를 따라가서 값 얻기]] 에서 알아볼 예정이다.

벡터에 대한 반복 처리는 불변이든 가변이든 상관없이 대여 검사 규칙에 의해 안전다하. 만약 아이템을 추가하거나 지우는 시도를 했다[](15.%20스마트%20포인터.md)열거형을 이용해 여러 타입 저장하기

예제를 보자.

```rust
fn main() {
	enum SpreadsheetCell {
		Int(i32),
		Float(f64),
		Text(String),
	}
	
	let row = vec![
		SpreadsheetCell::Int(3),
		SpreadsheetCell::Text(String::from("blue")),
		SpreadsheetCell::Float(10.12),
	];
}
```

각 요소를 저장하기 위해 얼마만큼의 힘 메모리가 필요한지 알아야 하기 때문에 벡터의 타입에 대한 정보가 필요하다. 벡터에 저장할 모든 타입 집합을 알지 못할 수 있는데 이때 트레이트 객체를 이용할 수 있다. 트레이트 객체는 [[17. 러스트의 객체 지향 프로그래밍 기능]] 에서 배울 수 있다.

### 벡터가 버려지면 벡터의 요소도 버려진다.

`struct`와 마찬가지로, 벡터는 스코프를 벗어날 때 해제된다. 백터가 버려질 때 벡터의 내용물도 전부 버려진다. 즉, 벡터가 가지고 있던 정수들의 메모리도 정리된다.

## 문자열에 UTF-8 텍스트 저장하기

갓 입문한 경우에 보통 세 가지 이유의 조합에 의해 문자열 부분에서 막힌다.

1. 에러를 최대한 표시하는 러스트의 성향
2. 문자열이 복잡한 자료구조라는 점
3. UTF-8

이 이유다.

### 문자열이 뭘까?

러스트 언어의 핵심 기능에서는 딱 한 가지의 문자열 타입만 제공한다. 참조자 형태인 `&str`을 통해 많이 봤던 문자열 슬라이스 `str`이다. 이는 `UTF-8`로 인코딩되어 다른 어딘가에 저장된 문자열 데이터의 참조자다. 예를 들어, 문자열 리터럴은 프로그램의 바이너리 결과물 안에 저장되어 있으며, 그러므로 문자열 슬라이스다.

`String` 타입은 언어의 핵심 기능에 구현된 것이 아니고 러스트의 표준 라이브러리를 통해 제공되며, 커질 수 있고, 가변적이며, 소유권을 갖고 있고, UTF-8으로 인코딩된 문자열 타입이다.

### 새로운 문자열 생성하기

**비어 있는 새로운 `String` 생성하기
```rust
fn main() {
	let mut s = String::new();
}
```

이 라인은 어떤 데이터를 담을 수 있는 `s`라는 빈 문자열을 만들어 준다. `to_string`을 사용해 문자열 리터럴로부터 `String`을 생성할 수 있다.

```rust
fn main() {
	let data = "initial contents";

	let s = data.to_string();

	// 이 메서드는 리터럴에서도 바로 작동한다.
	let s = "initial contents".to_string();
}
```

문자열 리터럴로부터 `String`을 생성하기 위해 `String::from` 함수를 이용할 수도 있다.

```rust
fn main() {
	let s = String::from("initial contents");
}
```

**문자열이 UTF-8로 인코딩 되었음을 기억해라**

적합하게 인코딩된 모든 데이터를 집어넣을 수 있다.

### 문자열 업데이트하기

**`push_str`과 `push`를 이용해 문자열 추가하기**
```rust
fn main() {
	let mut s = String::from("foo");
	s.push_str("bar");
}
```

`push_str` 메서드는 문자열 슬라이스를 배개변수로 갖는다. 이는 매개변수의 소유권을 가져올 필요가 없기 때문이다.

```rust
fn main() {
	let mut s1 = String::from("foo");
	let s2 = "bar";
	s1.push_str(s2);
	println!("s2 is {s2}");
}
```

만약 `push_str` 함수가 소유권을 가져갔다면 값을 출력할 수 없었을 거다.

`push` 메서드는 한 개의 글자를 매개변수로 받아 `String`에 추가한다.

```rust
fn main() {
	let mut s = String::from("lo");
	s.push('l');
}
```

> [!info] 문자는 작은따옴표 `'` 에 감싸져야 한다.

**`+` 연산자나 `format!` 매크로를 이용한 접합**
```rust
fn main() {
	let s1 = String::from("Hello, ");
	let s2 = String::from("world!");
	let s3 = s1 + &s2; // s1은 여기로 이동되어 더 이상 사용할 수 없음에 주의해야 한다.
}
```

`s1`이 더하기 연산 이후에 더 이상 유효하지 않은 이유와 `s2`의 참조자가 사용되는 이유는 `+` 연산자를 사용했을 때 호출되는 함수의 시그니처와 맞춰야 하기 때문이다. `+` 연산자는 `add` 메서드를 사용하는데, 이 메서드의 시그니처는 아래처럼 생겼다.

```rust
fn add(self, s:&str) -> String {}
```

이 시그니처는 `+` 연산자의 까다로운 부분을 이해하는 데 필요한 단서를 준다.

`s2`에 `&`가 있다. 즉, 첫 번째 문자열에 두 번째 문자열의 **참조자**를 더하고 있다. `String`에는 `&str`만 더할 수 있고, 두 `String` 끼리는 더하지 못한다. 그러나 `&s2` 의 타입은 `&String` 이지, `&str`이 아니다. 왜 컴파일 되는걸까?

이는 `&String` 인수가 `&str`로 **강제(coerce)** 될 수 있기 때문이다. `add` 함수가 호출되면 러스트는 **역참조 강제**를 사용해 `&s2`를 `&s2[..]`로 바꾼다. 역참조 강제는 [[15. 스마트 포인터]] 에서 자세히 다룬다.

두 번째로, 시그니처에서 `add`가 `self`의 소유권을 가져가는 것을 볼 수 있는데, 이는 `self`가 `&`를 **안 가지고** 있기 때문이다. 즉 `s1`이 `add`로 호출되어 이동된 이후에는 더 이상 유효하지 않을 것이라는 의미다. 따라서 `let s3 = s1 + &s2`가 마치 두 문자열을 복사해 새로운 문자열을 만드는 것 처럼 보일지라도, 실제로는 `s1`의 소유권을 가져가 `s2`의 내용물의 복사본을 추가한 다음, 결과물의 소유권을 반환한다.

만일 여러 문자열을 붙이고자 하면 `+`의 동작은 다루기 불편하다.

```rust
fn main() {
	let s1 = String::from("tic");
	let s2 = String::from("tac");
	let s3 = String::from("toe");

	let s = s1 + "-" + &s2 + "-" + &s3;
}
```

`format!` 매크로를 사용하면 더 간단하게 할 수 있다.

```rust
fn main() {
	let s1 = String::from("tic");
	let s2 = String::from("tac");
	let s3 = String::from("toe");

	let s = format!("{s1}-{s2}-{s3}");
}
```

### 문자열 내부의 인덱싱

러스트에서 인덱싱 문법을 이용해 `String`의 부분에 접근하고 하면 에러를 얻게 된다.

#### 내부적 표현
`String`은 `Vec<u8>`을 감싼 것이다.

```rust
let hello = String::from("Hola");
```

이 경우 `len`은 4가 되는데, 이는 문자열 `'Hola'`를 저장하고 있는 `Vec`의 길이가 4바이트 길이라는 뜻이다. `UTF-8`로 인코딩되면 각각의 글자들이 1바이트씩 차지한다는 것이다.

그런데 힌디어 작성하면 문자 하나당 2바이트를 차지하게 된다. 따라서, 문자열 바이트 안의 인덱스는 유효한 유니코드 스칼라값과 항상 대응되지 않는다는 의미다.

러스트에서는 인덱스를 통한 접근을 컴파일에서부터 막아 이러한 오해들을 개발 과정 내에서 방지한다.

#### 바이트와 스칼라값과 문자소 클러스터
러스트의 관점에서 문자열을 세 가지 관련 방식이 있다.

- 바이트
- 스칼라값
- 문자소 클러스터(우리가 **글자**라고 부르는 것과 가장 근접한 것)

> [!warning] 
> 아래는 그저 예시일 뿐입니다....

힌디어 `어떤 문자열`을 보면 다음과 같은 `u8`값들이 `Vec`로 저장된다.
```text
[224, 164, 168, 224, 164, 174, 224, .....]
```

18바이트고 이것이 실제로 컴퓨터가 이 데이터를 저장하는 방법이다. 이를 유니코드 **스칼라값**, 즉 러스트의 `char` 타입인 형태로 보면 다음과 같다.

```text
['어', '떤', '?', '문', '자', '열', '?']
```

4번째 7번째는 발음 기호다. 마지막으로 이 문자열을 문자소 클러스토로 본다면 다음과 같다.

```
['어','떤','문','자','열']
```

러스트는 컴퓨가 저장하는 원시 문자열을 번역하는 다양한 방법을 제공해 데이터가 담고 있는 것이 무슨 언어든 상관없이 각 프로그램이 필요로 하는 통역방식을 선택할 수 있도록 한다.

러스트가 `String`을 인덱스로 접근하여 문자를 얻지 못하도록 하는 마지막 이유는 인덱스 연산이 언제나 상수 시간(O(1))에 실행될 것으로 기대받기 때문이다. 그러나 `String`을 가지고 그러한 성능을 보장하는 것은 불가능하다. 문자열 내에 유효한 문자가 몇 개 있는지 알아내기 위해 내용물을 시작 지점부터 인덱스로 지정된 곳까지 훑어야 하기 때문이다.

### 문자열 슬라이싱하기

문자열 인덱싱의 반환 타입이 어떤 것(바이트값, 캐리턱, 문자소 클러스터, 문자열 슬라이스인지) 되어야 하는지 명확하지 않기 때문에 문자열의 인덱싱은 종종 좋지 않은 생각이다. 러스트는 좀 더 구체적인 지정을 요청한다.

다음과 같이 문자열 슬라이스를 만들 수 있다.

```rust
let hello = "안녕하세요";

let s = &hello[0..4];
```

`s`는 문자열의 첫 4바이트를 담고 있는 `&str`이 된다. 만약 글자들이 각각 2바이트를 차지한다면 `s`가 `'안녕'` 이 된다는 의미다.

만약 유효하지 않은 인덱스의 슬라이스를 얻으려 했다면 어떻게 될까? 런타임에 패닉을 발생시킬 것이다. 그렇기에 범위를 지정해 문자열 슬라이스를 생성할때는 조심해서 사용해야 한다.

### 문자열에 대한 반복을 위한 메서드

문자열 조각에 대한 연산을 하는 가장 좋은 방법은 명시적으로 문자를 원하는 것인지 아니면 바이트를 원하는 것인지 지정하는 것이다. 개별적인 유니코드 스칼라값에 대해서는 `chars` 메서드를 사용할 수 있다.

```rust
fn main() {
	for c in "안녕하세요".chars() {
		println!("{c}");
	}
}
```

바이트를 원한다면 `bytes` 메서드를 사용할 수 있다.

```rust
fn main() {
	for b in "안녕하세요".bytes() {
		println!("{b}");
	}
}
```

하지만 중요한 것은 유니코드의 스칼라값이 하나 이상의 바이트로 구성될지도 모른다는 것이다.

> [!tip]
> 확인해보면 알겠지만 한국어는 하나의 문자가 3바이트로 구성된다

### 문자열은 그렇게 단순하지 않다

문자열은 복잡하다. 러스트는 `String` 데이터의 올바른 처리를 모든 러스트 프로그램의 기본 동작으로 선택했다. 이는 프로그래머가 `UTF-8` 데이터를 처리할 때 미리 더 많은 생각을 해야 함을 의미한다. 문자열의 복잡성을 더 많이 노출시키지만, 한편으로는 개발 생명주기 후반에 `ASCII` 아닌 문자와 관련된 에러를 처리해야 할 필요가 없도록 해준다.

## 해시 맵에 서로 연관된 키와 값 저장하기

`HashMap<K, V>` 타입은 `K` 타입의 키와 `V` 타입의 값에 대해 **해시 함수(hashing function)** 을 사용하여 매핑한 것을 저장하는데 이 해시 함수는 이 키와 값을 메모리 어디에 저장할지 결정한다.

### 새로운 해시 맵 생성하기

`new`를 사용한 뒤 `insert`를 사용해 요소를 추가하는 방법이 있다.

```rust
use std::collections::HashMap;

fn main() {
	let mut scores = HashMap::new();

	scores.insert(String::from("Blue"), 10);
	scores.insert(String::from("Red"), 50);
}
```

`use`로 `HashMap`을 가져오고 사용하면 된다.

벡터와 마찬가지로, 해시 맵도 데이터를 힙에 저장한다. 모든 키는 서로 같은 타입이어야 하고, 모든 값도 같은 타입이어야 한다.

### 해시 맵의 값 접근하기

`get`메서드에 키를 제공해 해시 맵으로부터 값을 얻어올 수 있다.

```rust
use std::collections::HashMap;

fn main() {
	let mut scores = HashMap::new();

	scores.insert(String::from("Blue"), 10);
	scores.insert(String::from("Red"), 50);

	let team_name = String::from("Blue");
	let blue_score = scores.get(&team_name).copied().unwrap_or(0);
}
```

`get` 메서드는 `Option<&V>`를 반환한다. 해당 키에 대한 값이 없다면 `None`을 반환할 것이다. 이 프로그램에서는 `copied`를 호출해 `Option<&i32>` 타입의 참조가 가리키는 값을 복사해 `Option<i32>`를 얻어온 다음, `upwrap_or`를 써서 `scores`가 해당 키에 대한 아이템을 가지고 있지 않을 경우 `score`에 0을 설정하도록 처리한다.

벡터에서와 유사한 방식으로 `for` 루프를 사용해 반복 작업을 할 수 있다.

```rust
use std::collections::HashMap;

fn main() {
	let mut scores = HashMap::new();

	scores.insert(String::from("Blue"), 10);
	scores.insert(String::from("Red"), 50);

	for (key, value) in &scores {
		println!("{key}: {value}");
	}
}
```

### 해시 맵과 소유권

`String`처럼 소유권이 있는 값의 경우 값들이 이동되어 해시 맵의 그 값의 소유자가 된다.

```rust
use std::collections::HashMap;

fn main() {
	let field_name = String::from("Favorite color");
	let field_value = String::from("Blue");

	let mut map = HashMap::new();
	map.insert(field_name, field_value);
	// field_name과 field_value는 이 시점부터 유효하지 않다.
}
```

해시 맵 값에 참조자를 삽입하면 이 값들은 이동되지 않을거다. 하지만 참조자가 가리키고 있는 값은 해시 맵이 유효할 때까지 계속 유효해야 한다. 이와 관련된 니용은 [[10. 제네릭 타입, 트레이트, 라이프타임]]에서 더 자세히 얘기할 예정이다.

### 해시 맵 업데이트하기

키와 값 쌍의 개수는 늘어날 수 있지만, 각각의 유일한 키는 연관된 값을 딱 하나만 가질 수있다.

해시 맵의 데이터를 변경하고 싶을 때는 키에 이미 값이 할당되어 있을 경우에 대한 처리 방법을 결정해야 한다. 예전 값을 완전히 무시하고, 해당 키에 값이 할당되어 있니 **않을** 경우에만 새 값을 추가하는 방법을 선택할 수도 있다. 또는 예전 값과 새 값을 조합할 수도 있다.

#### 값을 덮어쓰기
```rust
use std::collections::HashMap;

fn main() {
	let mut scores = HashMap::new();

	scores.insert(String::from("Blue"), 10);
	scores.insert(String::from("Blue"), 50);

	println!("{:?}", scores);
}
```

이 코드는 `{"Blue": 50}`을 출력한다. 원래의 값 10이 50으로 덮어써졌다.

#### 키가 없을 때만 키와 값 추가하기
```rust
use std::collections::HashMap;

fn main() {
	let mut scores = HashMap::new();

	scores.insert(String::from("Blue"), 10);

	scores.entry(String::from("Yellow")).or_insert(50);
	scores.entry(String::from("Blue")).or_insert(50);

	println!("{:?}", scores);
}
```

`entry` 라고 하는 메서드는 `Entry` 타입을 반환한다. `Entry`의 `or_insert` 메서드는 해당 키가 존재할 경우 `Entry`키에 대한 연관된 값을 반환하도록 정의되어 있고, 그렇지 않을 경우 매개변수로 제공된 값을 해당 키에 대한 새 값으로 삽입하고 수정된 `Entry`에 대한 값을 반환한다.

#### 예전 값을 기반으로 값을 업데이트하기
```rust
use std::collections::HashMap;

fn main() {
	let text = "hello world wonderful world";

	let mut map = HashMap::new();

	for word in text.split_whitespace() {
		let count = map.entry(word).or_insert(0);
		*count += 1;
	}

	println!("{:?}", map);
}
```

> [!tip]
> 해시 맵에 대한 반복 처리는 임의의 순서로 일어난다.

`split_whitespace`는 공백 문자를 기준으로 서브 슬라이스에 대한 반복자를 반환한다. `or_insert`는 해당 키에 대한 값의 가변 참조자를 반환한다. `count` 변수에 가변 참조자를 저장했고, 여기에 값을 할당하기 위해 `*`을 통해 역참조 해야한다. 가변 참조자는 `for` 루프의 끝에서 스코프 밖으로 벗어나고, 모든 값의 변경은 안전하고 대여 규칙에 위배되지 않는다.

### 해시 함수

기본적으로 `HashMap`은 해시 테이블과 관련된 서비스 거부 공격(Dos attack)에 저항 기능을 제공할 수 있는 `SipHash`라 불리는 해시 함수를 사용한다. 가장 빠른 해시 알고리즘은 아니지만, 성능이 낮더라도 보안이 더 강해 사용할 가치가 있다.

만약 너무 느리다면 다른 해셔를 지정해 해시 함수를 다른 함수로 바꿀 수 있다. **해셔(hasher)** 는 `BuildHasher` 트레이트를  구현한 타입을 말한다. 트레이트와 이를 구현하는 방법에 대해서는 [[10. 제네릭 타입, 트레이트, 라이프타임]]에서 배운다.