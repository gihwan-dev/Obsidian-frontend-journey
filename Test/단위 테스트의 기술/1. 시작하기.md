- 코드를 매번 직접 검증하는 것은 어려움
- 코드를 작성하면 다양한 것들을 해야함
	- 제대로 동작하는지 검증
	- 앱이 제대로 동작하도록 설정을 맞춰야함
	- 기존 코드와 충돌이 있는지 확인해야함
- 이것들을 수동으로 하면 오류도 발생하기 쉽고 시간도 많이 걸림
- 테스트를 자동화하면 이런 것들에 힘을 쏟지 않을 수 있음
- 단위 테스트와 통합 테스트는 서로 헷갈리기 쉬운 개념이지만 매우 중요한 개념이기에 명확히 구분할 줄 알아야함
- TDD와 테스트는 다름

## 단위 테스트 정의

- 테스트를 작성할 대상은 테스트 중인 주제(subject), 시스템(system), 테스트 대상(Suite Under Test) 이다.

> [!Note] SUT 정의
> SUT는 테스트 중인 주제, 시스템, 테스트의 모음(suite)을 의미하며, 일부 사람들은 테스트 중인 컴포넌트, 츨래스, 코드를 의미하는 CUT 라는 용어를 사용하기도 한다. 무언가를 테스트할 때, 테스트하고자 하는 주요 대상을 SUT라고 한다.

- 단위 테스트에서 단위(unit)란?
	- 시스템 내 '작업 단위' 또는 '사용 사례'를 의미함
	- 작업 단위에는 시작과 끝이 있으며, 이를 진입점과 종료점 이라고 함
	- 작업 단위의 간단한 예로는 무언가를 계산하고 계산된 값을 반환하는 함수를 생각할 수 있음
	- 다만 함수는 내부에서 다른 함수나, 모듈, 컴포넌트 따위를 사용할 수도 있으므로 진입점부터 종료점까지 아우르는 하나의 작업 단위는 단순한 함수 이상의 의미일 수 있음

> [!Note] 작업 단위
> 작업 단위는 진입점의 호출부터 하나 이상의 종료점까지, 눈에 띄는 결과가 나타날 때까지 발생하는 모든 작업을 의미한다. 진입점은 설정하기 나름이다. 가령 어떤 동작을 수행하는 함수를 생각하면 다음 구조로 나뉜다.
> - 함수의 바디는 작업 단위 전체나 일부를 의미한다.
> - 함수의 선언과 서명(시그니쳐: 매개변수 형식과 반환 형식)은 바디로의 진입점이다.
> - 함수의 출력이나 실행 결과는 함수의 종료점이다.

## 진입점과 종료점
- 작업 단위에는 항상 하나의 진입점과 하나 이상의 종료점이 있다.
- 작업 단위는 함수 하나만 의미할 수도 있고, 여러 함수를 의미할 수도 있음
- 모듈 혹은 컴포넌트도 작업 단위가 될 수 있음
- 작업 단위가 어떤 것이든 진입점이 존재하며 '의미 있는' 작업을 하기 마련임
	- 의미 있는 작업이란?
	  값을 반환하는 것 부터 시작해 어떤 상태를 변경하거 서드 파티 코드를 호출하는 등 뭔가 눈에 띄는 동작을 의미함. 이러한 동작을 **종료점**이라고 하기도 함.

> [!Note] 종료점 의미
> - 일반적으로 함수나 컴포넌트 등 무언가를 실행했을 때(진입점) 그 안에서 상태 값을 변경하거나 서드 파티를 호출하는 등 의미 있는 작업을 실행할 것이라고 여김.
> - 테스트 코드를 실행하다 어떤 함수가 호출 되었을 때 함수의 종료점은 해당 함수의 작업 단위가 돌아가는 실행 컨텍스트에서 벗어나 다시 테스트 코드가 있던 곳으로 돌아감.
> - 그런 의미에서 종료점 이라고 함.


- 아래 코드 예시를 참고:

```js
const sum = (numbers) => {
	const [a, b] = numbers.split(',');
	const result = parseInt(a) + parseInt(b);
	
	return result;
}
```

- 위 `sum` 함수는 진입점이며, 최종 결과로 두  숫자의 합을 반환하기 때문에 종료점 역할도 함.
- 함수를 실행한 동일한 위치에서 반환 값도 얻으므로 진입점이 종료점이기도 함
- 아래 코드 다시 참고:

```js
let total = 0;

const totalSoFar = () => {
	return total;
};

const sum = (numbers) => {
	const [a, b] = numbers.split(',');
	const result = parseInt(a) + parseInt(b);
	
	total += result; // 추가된 부분
	
	return result;
}
```

- 위 예제에서 `sum` 함수는 두 가지 종료점을 가짐
	- 숫자의 합을 반환함
	- 숫자의 합을 `total`에 추가하는 누적 함계를 계산함. `total`은 하나의 상태값으로 간주되며 `toatalSoFar` 함수의 종료점으로 확인할 수 있음. `totalSoFar` 함수는 `sum` 함수를 호출한 진입점에서 호출될 수 있음
- 외부 상태를 변경하거나, 값을 반환하는 로직을 종료점으로 볼 수 있음
- 의존성 호출(서드 파티 호출)도 하나의 종료점으로 볼 수 있다
- 종료점마다 테스트를 만들어 분리하면 각 테스트끼리 영향을 주지 않고, 더 읽기 쉬우며 디버깅하기도 쉽다.

## 다른 종료점, 다른 기법
- 반환 값이 있는 종료점: 가장 테스트 하기 쉬운 타입. 결과값 검증만 하면 됨.
- 상태 값을 변경하는 종료점: 좀 더 많은 작업이 필요함. 어떤 것을 호출한 후 다른 무언가를 확인하거나 하는 로직이 필요
- 서드 파티를 호출하는 종료점: 가장 많은 작업이 필요한 테스트. 외부에 실행 주도권이 있어 코드 간섭이 힘듬. 모의 객체를 만들어 테스트 결과를 임의로 조작하는 방법 등을 사용해야함.

## 좋은 단위 테스트
- 테스트 작성자 의도를 이해하기 쉬어야 함
- 읽고 쓰기 쉬워야 함
- 자동화할 수 있이어야함
- 같은 조건에서 실행 결과는 항상 같아야함
- 의미 있는 테스트여야 하고, 구체적인 결과를 제공해 문제를 쉽게 파악하고 해결할 수 있어야 함
- 누구나 쉽게 실행할 수 있어야함
- 실패할 경우 무엇이 잘못되었는지 쉽게 알 수 있어야함
- 빠르게 실행되어야 함
- 결과가 항상 예측 가능해야 함
- 완전히 독립적으로 실행되어야 함
- 메모리 내에서 실행되어야 함
- 가능한 동기적인 흐름으로 실행되어야 함

### 단위 테스트 체크 리스트
아래의 모든 질문에 해당되어야 단위 테스트라 불릴 수 있음
- 2주, 2개월, 2년 전에 만든 테스트가 여전히 잘 돌아가는가?
- 내가 2개월전에 작성한 테스트를 팀 내 다른 동료가 실행했을 때 문제없이 결과를 받을 수 있는가?
- 내가 만든 테스트가 수분 내로 전부 실행되는가?
- 버튼 하나만 눌러서 내가 작성한 모든 테스트를 실행할 수 있는가?
- 기본적인 테스트를 몇 분 내로 작성할 수 있는가?
- 다른 팀 코드에 버그가 있어도 내 테스트는 통과하는가?
- 내 테스트는 다른 실행 환경에서 실행해도 동일한 결과를 보장하는가?
- 데이터베이스나 네트워크, 배포 없이도 내 테스트는 동작하는가?
- 하나의 테스트를 삭제, 이동, 변경해도 다른 테스트는 영향을 받지 않고 잘 실행되는가?

## 통합 테스트
